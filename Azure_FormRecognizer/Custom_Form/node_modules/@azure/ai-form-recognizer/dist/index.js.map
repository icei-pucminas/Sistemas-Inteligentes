{"version":3,"file":"index.js","sources":["../src/constants.ts","../src/logger.ts","../src/tracing.ts","../src/utils/utils.node.ts","../src/common.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/generatedClientContext.ts","../src/generated/generatedClient.ts","../src/lro/analyze/contentPoller.ts","../src/transforms.ts","../src/lro/analyze/recognitionPoller.ts","../src/azureKeyCredentialPolicy.ts","../src/formRecognizerClient.ts","../src/lro/train/poller.ts","../src/lro/copy/poller.ts","../src/formTrainingClient.ts","../src/generated/models/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"3.1.0\";\n\nexport const DEFAULT_COGNITIVE_SCOPE = \"https://cognitiveservices.azure.com/.default\";\n\nexport const LIB_INFO = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;\n\n/**\n * Maximum size of input documents allowed by the Azure Form Recognizer service.\n * @internal\n */\nexport const MAX_INPUT_DOCUMENT_SIZE = 50 * 1024 * 1024; // 50 MB\n\nexport const FormRecognizerLoggingAllowedHeaderNames = [\n  \"apim-request-id\",\n  \"Location\",\n  \"Operation-Location\",\n  \"Strict-Transport-Security\",\n  \"X-Content-Type-Options\",\n  \"x-envoy-upstream-service-time\"\n];\n\nexport const FormRecognizerLoggingAllowedQueryParameters = [\n  \"includeTextDetails\",\n  \"includeKeys\",\n  \"op\"\n];\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The \\@azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"ai-form-recognizer\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createSpanFunction } from \"@azure/core-tracing\";\n\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const createSpan = createSpanFunction({\n  packagePrefix: \"Azure.CognitiveServices.FormRecognizer\",\n  namespace: \"Microsoft.CognitiveServices\"\n});\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nconst SIZE_ONE_MEGA = 1024 * 1024;\n\n/**\n * Reads a readable stream into buffer entirely. NodeJS only.\n * The maximum allowed size is specified in {@link MAX_INPUT_DOCUMENT_SIZE}.\n *\n * @param stream - A Node.js Readable stream\n * @returns The resultant buffer.\n * @throws If buffer size is not big enough.\n */\nexport async function streamToBuffer(\n  stream: NodeJS.ReadableStream,\n  maxSize: number\n): Promise<Buffer> {\n  let pos = 0; // Position in stream\n  let size = SIZE_ONE_MEGA;\n  let buffer = Buffer.alloc(size);\n\n  return new Promise<Buffer>((resolve, reject) => {\n    stream.on(\"readable\", () => {\n      const chunk = stream.read();\n      if (!chunk) {\n        return;\n      }\n      const nextPos = pos + chunk.length;\n      if (size < nextPos && nextPos <= maxSize) {\n        // Keep doubling buffer until it is large enough or over max size\n        const oldSize = size;\n        while (size < nextPos && size * 2 < maxSize) {\n          size *= 2;\n        }\n\n        if (nextPos < size && size < maxSize) {\n          const newBuffer = Buffer.alloc(size - oldSize);\n          buffer = Buffer.concat([buffer, newBuffer]);\n        } else {\n          const newBuffer = Buffer.alloc(maxSize - oldSize);\n          size = maxSize;\n          buffer = Buffer.concat([buffer, newBuffer]);\n        }\n      } else if (nextPos > maxSize) {\n        reject(new Error(`Input stream exceeds maximum allowed size: ${maxSize}`));\n        return;\n      }\n\n      buffer.fill(chunk, pos, nextPos);\n      pos = nextPos;\n    });\n\n    stream.on(\"end\", () => {\n      resolve(buffer.slice(0, pos));\n    });\n\n    stream.on(\"error\", reject);\n  });\n}\n\nexport function getFirstFourBytesFromBlob(_data: Blob): Promise<Uint8Array> {\n  throw new Error(\"Blob is not supported in NodeJS environment\");\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineOptions, OperationOptions } from \"@azure/core-http\";\nimport { FormRecognizerRequestBody } from \"./models\";\nimport { SourcePath } from \"./generated/models\";\nimport { getFirstFourBytesFromBlob, streamToBuffer } from \"./utils/utils.node\";\nimport { MAX_INPUT_DOCUMENT_SIZE } from \"./constants\";\n\n/**\n * Content types supported by Form Recognizer service.\n */\nexport type FormContentType =\n  | \"application/pdf\"\n  | \"image/jpeg\"\n  | \"image/png\"\n  | \"image/tiff\"\n  | \"image/bmp\";\n\n/**\n * Client options used to configure Form Recognizer API requests.\n */\nexport interface FormRecognizerClientOptions extends PipelineOptions {}\n\n/**\n * Options common to all form recognizer operations.\n */\nexport interface FormRecognizerOperationOptions extends OperationOptions {}\n\n/**\n * Translate the content to a format that is understood by Form Recognizer service\n * @internal\n */\nexport async function toRequestBody(\n  body: FormRecognizerRequestBody | string\n): Promise<Blob | ArrayBuffer | ArrayBufferView | SourcePath> {\n  if (typeof body === \"string\") {\n    return {\n      source: body\n    };\n  } else {\n    // cache stream to allow retry\n    if (isReadableStream(body)) {\n      return streamToBuffer(body, MAX_INPUT_DOCUMENT_SIZE);\n    }\n\n    return body;\n  }\n}\n\nfunction isReadableStream(data: FormRecognizerRequestBody): data is NodeJS.ReadableStream {\n  return \"read\" in data && typeof data.read === \"function\";\n}\n\nfunction isBlob(data: FormRecognizerRequestBody): data is Blob {\n  return \"size\" in data && \"type\" in data;\n}\n\nfunction isArrayBuffer(data: FormRecognizerRequestBody): data is ArrayBuffer {\n  return \"byteLength\" in data && \"slice\" in data && typeof data.slice === \"function\";\n}\n\nfunction isArrayBufferView(data: FormRecognizerRequestBody): data is ArrayBufferView {\n  return \"buffer\" in data && \"byteLength\" in data && \"byteOffset\" in data;\n}\n\nfunction isSourcePath(data: FormRecognizerRequestBody | SourcePath): data is SourcePath {\n  return \"source\" in data && typeof data.source === \"string\";\n}\n\n/**\n * Detects the content type of binary data.\n * See https://en.wikipedia.org/wiki/List_of_file_signatures\n * @internal\n */\nexport async function getContentType(\n  data: Blob | ArrayBuffer | ArrayBufferView | SourcePath\n): Promise<FormContentType | undefined> {\n  if (isSourcePath(data)) {\n    return undefined;\n  }\n  let bytes: Uint8Array;\n  if (isArrayBuffer(data)) {\n    // ArrayBuffer\n    if (data.byteLength < 4) {\n      throw new RangeError(\"Invalid input. Expect more than 4 bytes of data\");\n    }\n\n    bytes = new Uint8Array(data, 0, 4);\n  } else if (isArrayBufferView(data)) {\n    // ArrayBufferView\n    if (data.byteLength < 4) {\n      throw new RangeError(\"Invalid input. Expect more than 4 bytes of data\");\n    }\n\n    bytes = new Uint8Array(data.buffer, 0, 4);\n  } else if (isBlob(data)) {\n    // Blob\n    bytes = await getFirstFourBytesFromBlob(data);\n  } else {\n    throw new Error(\"unsupported request body type\");\n  }\n\n  if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {\n    return \"application/pdf\";\n  } else if (bytes[0] === 0xff && bytes[1] === 0xd8) {\n    return \"image/jpeg\";\n  } else if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47) {\n    return \"image/png\";\n  } else if (\n    (bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2a && bytes[3] === 0x0) ||\n    (bytes[0] === 0x4d && bytes[1] === 0x4d && bytes[2] === 0x0 && bytes[3] === 0x2a)\n  ) {\n    return \"image/tiff\";\n  } else if (bytes[0] === 0x42 && bytes[1] === 0x4d) {\n    return \"image/bmp\";\n  } else {\n    throw new RangeError(\"content type could not be detected\");\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nexport const TrainRequest: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TrainRequest\",\n    modelProperties: {\n      source: {\n        constraints: {\n          MaxLength: 2048\n        },\n        serializedName: \"source\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      sourceFilter: {\n        serializedName: \"sourceFilter\",\n        type: {\n          name: \"Composite\",\n          className: \"TrainSourceFilter\"\n        }\n      },\n      useLabelFile: {\n        serializedName: \"useLabelFile\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      modelName: {\n        serializedName: \"modelName\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const TrainSourceFilter: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TrainSourceFilter\",\n    modelProperties: {\n      prefix: {\n        constraints: {\n          MaxLength: 1024\n        },\n        serializedName: \"prefix\",\n        type: {\n          name: \"String\"\n        }\n      },\n      includeSubfolders: {\n        serializedName: \"includeSubFolders\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorResponse: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorResponse\",\n    modelProperties: {\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorInformation\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorInformation: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorInformation\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const Model: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Model\",\n    modelProperties: {\n      modelInfo: {\n        serializedName: \"modelInfo\",\n        type: {\n          name: \"Composite\",\n          className: \"ModelInfo\"\n        }\n      },\n      keys: {\n        serializedName: \"keys\",\n        type: {\n          name: \"Composite\",\n          className: \"KeysResult\"\n        }\n      },\n      trainResult: {\n        serializedName: \"trainResult\",\n        type: {\n          name: \"Composite\",\n          className: \"TrainResult\"\n        }\n      },\n      composedTrainResults: {\n        serializedName: \"composedTrainResults\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TrainResult\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const ModelInfo: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ModelInfo\",\n    modelProperties: {\n      modelId: {\n        serializedName: \"modelId\",\n        required: true,\n        type: {\n          name: \"Uuid\"\n        }\n      },\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"creating\", \"ready\", \"invalid\"]\n        }\n      },\n      trainingStartedOn: {\n        serializedName: \"createdDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      trainingCompletedOn: {\n        serializedName: \"lastUpdatedDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      modelName: {\n        serializedName: \"modelName\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"Attributes\"\n        }\n      }\n    }\n  }\n};\n\nexport const Attributes: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      isComposed: {\n        serializedName: \"isComposed\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeysResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeysResult\",\n    modelProperties: {\n      clusters: {\n        serializedName: \"clusters\",\n        required: true,\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: { name: \"Sequence\", element: { type: { name: \"String\" } } },\n            constraints: { UniqueItems: true }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TrainResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TrainResult\",\n    modelProperties: {\n      trainingDocuments: {\n        serializedName: \"trainingDocuments\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TrainingDocumentInfo\"\n            }\n          }\n        }\n      },\n      fields: {\n        serializedName: \"fields\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"FormFieldsReport\"\n            }\n          }\n        }\n      },\n      averageModelAccuracy: {\n        serializedName: \"averageModelAccuracy\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      modelId: {\n        serializedName: \"modelId\",\n        type: {\n          name: \"Uuid\"\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ErrorInformation\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TrainingDocumentInfo: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TrainingDocumentInfo\",\n    modelProperties: {\n      name: {\n        serializedName: \"documentName\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      pageCount: {\n        serializedName: \"pages\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ErrorInformation\"\n            }\n          }\n        }\n      },\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"succeeded\", \"partiallySucceeded\", \"failed\"]\n        }\n      }\n    }\n  }\n};\n\nexport const FormFieldsReport: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"FormFieldsReport\",\n    modelProperties: {\n      fieldName: {\n        serializedName: \"fieldName\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      accuracy: {\n        serializedName: \"accuracy\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const SourcePath: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SourcePath\",\n    modelProperties: {\n      source: {\n        constraints: {\n          MaxLength: 2048\n        },\n        serializedName: \"source\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const AnalyzeOperationResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeOperationResult\",\n    modelProperties: {\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"notStarted\", \"running\", \"succeeded\", \"failed\"]\n        }\n      },\n      createdOn: {\n        serializedName: \"createdDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      lastModified: {\n        serializedName: \"lastUpdatedDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      analyzeResult: {\n        serializedName: \"analyzeResult\",\n        type: {\n          name: \"Composite\",\n          className: \"AnalyzeResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const AnalyzeResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeResult\",\n    modelProperties: {\n      version: {\n        serializedName: \"version\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      readResults: {\n        serializedName: \"readResults\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ReadResult\"\n            }\n          }\n        }\n      },\n      pageResults: {\n        serializedName: \"pageResults\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"PageResult\"\n            }\n          }\n        }\n      },\n      documentResults: {\n        serializedName: \"documentResults\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentResult\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ErrorInformation\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const ReadResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ReadResult\",\n    modelProperties: {\n      pageNumber: {\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"page\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      angle: {\n        constraints: {\n          InclusiveMaximum: 180,\n          ExclusiveMinimum: -180\n        },\n        serializedName: \"angle\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      width: {\n        constraints: {\n          InclusiveMinimum: 0\n        },\n        serializedName: \"width\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      height: {\n        constraints: {\n          InclusiveMinimum: 0\n        },\n        serializedName: \"height\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      unit: {\n        serializedName: \"unit\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"pixel\", \"inch\"]\n        }\n      },\n      lines: {\n        serializedName: \"lines\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextLine\"\n            }\n          }\n        }\n      },\n      selectionMarks: {\n        serializedName: \"selectionMarks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SelectionMark\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TextLine: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextLine\",\n    modelProperties: {\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      words: {\n        serializedName: \"words\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextWord\"\n            }\n          }\n        }\n      },\n      appearance: {\n        serializedName: \"appearance\",\n        type: {\n          name: \"Composite\",\n          className: \"TextAppearance\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextWord: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextWord\",\n    modelProperties: {\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      confidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"confidence\",\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextAppearance: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextAppearance\",\n    modelProperties: {\n      style: {\n        serializedName: \"style\",\n        type: {\n          name: \"Composite\",\n          className: \"TextStyle\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextStyle: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextStyle\",\n    modelProperties: {\n      name: {\n        serializedName: \"name\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"other\", \"handwriting\"]\n        }\n      },\n      confidence: {\n        serializedName: \"confidence\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const SelectionMark: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SelectionMark\",\n    modelProperties: {\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      confidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"confidence\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      state: {\n        serializedName: \"state\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"selected\", \"unselected\"]\n        }\n      }\n    }\n  }\n};\n\nexport const PageResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PageResult\",\n    modelProperties: {\n      pageNumber: {\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"page\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      clusterId: {\n        constraints: {\n          InclusiveMinimum: 0\n        },\n        serializedName: \"clusterId\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      keyValuePairs: {\n        serializedName: \"keyValuePairs\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"KeyValuePair\"\n            }\n          }\n        }\n      },\n      tables: {\n        serializedName: \"tables\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DataTable\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const KeyValuePair: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyValuePair\",\n    modelProperties: {\n      label: {\n        serializedName: \"label\",\n        type: {\n          name: \"String\"\n        }\n      },\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyValueElement\"\n        }\n      },\n      value: {\n        serializedName: \"value\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyValueElement\"\n        }\n      },\n      confidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"confidence\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyValueElement: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyValueElement\",\n    modelProperties: {\n      type: {\n        serializedName: \"type\",\n        type: {\n          name: \"String\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      elements: {\n        serializedName: \"elements\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const DataTable: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DataTable\",\n    modelProperties: {\n      rows: {\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"rows\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      columns: {\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"columns\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      cells: {\n        serializedName: \"cells\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DataTableCell\"\n            }\n          }\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const DataTableCell: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DataTableCell\",\n    modelProperties: {\n      rowIndex: {\n        constraints: {\n          InclusiveMinimum: 0\n        },\n        serializedName: \"rowIndex\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      columnIndex: {\n        constraints: {\n          InclusiveMinimum: 0\n        },\n        serializedName: \"columnIndex\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      rowSpan: {\n        defaultValue: 1,\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"rowSpan\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      columnSpan: {\n        defaultValue: 1,\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"columnSpan\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      confidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"confidence\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      elements: {\n        serializedName: \"elements\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      isHeader: {\n        serializedName: \"isHeader\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      isFooter: {\n        serializedName: \"isFooter\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentResult\",\n    modelProperties: {\n      docType: {\n        serializedName: \"docType\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      modelId: {\n        serializedName: \"modelId\",\n        type: {\n          name: \"Uuid\"\n        }\n      },\n      pageRange: {\n        constraints: {\n          MinItems: 2,\n          MaxItems: 2\n        },\n        serializedName: \"pageRange\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            constraints: {\n              InclusiveMinimum: 1\n            },\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      docTypeConfidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"docTypeConfidence\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      fields: {\n        serializedName: \"fields\",\n        required: true,\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"Composite\", className: \"FieldValue\" } }\n        }\n      }\n    }\n  }\n};\n\nexport const FieldValue: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"FieldValue\",\n    modelProperties: {\n      type: {\n        serializedName: \"type\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\n            \"string\",\n            \"date\",\n            \"time\",\n            \"phoneNumber\",\n            \"number\",\n            \"integer\",\n            \"array\",\n            \"object\",\n            \"selectionMark\",\n            \"countryRegion\"\n          ]\n        }\n      },\n      valueString: {\n        serializedName: \"valueString\",\n        type: {\n          name: \"String\"\n        }\n      },\n      valueDate: {\n        serializedName: \"valueDate\",\n        type: {\n          name: \"Date\"\n        }\n      },\n      valueTime: {\n        serializedName: \"valueTime\",\n        type: {\n          name: \"String\"\n        }\n      },\n      valuePhoneNumber: {\n        serializedName: \"valuePhoneNumber\",\n        type: {\n          name: \"String\"\n        }\n      },\n      valueNumber: {\n        serializedName: \"valueNumber\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      valueInteger: {\n        serializedName: \"valueInteger\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      valueArray: {\n        serializedName: \"valueArray\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"FieldValue\"\n            }\n          }\n        }\n      },\n      valueObject: {\n        serializedName: \"valueObject\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"Composite\", className: \"FieldValue\" } }\n        }\n      },\n      valueSelectionMark: {\n        serializedName: \"valueSelectionMark\",\n        type: {\n          name: \"String\"\n        }\n      },\n      valueCountryRegion: {\n        serializedName: \"valueCountryRegion\",\n        type: {\n          name: \"String\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        type: {\n          name: \"String\"\n        }\n      },\n      boundingBox: {\n        constraints: {\n          MinItems: 8,\n          MaxItems: 8\n        },\n        serializedName: \"boundingBox\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Number\"\n            }\n          }\n        }\n      },\n      confidence: {\n        constraints: {\n          InclusiveMaximum: 1,\n          InclusiveMinimum: 0\n        },\n        serializedName: \"confidence\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      elements: {\n        serializedName: \"elements\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      pageNumber: {\n        constraints: {\n          InclusiveMinimum: 1\n        },\n        serializedName: \"page\",\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const CopyRequest: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"CopyRequest\",\n    modelProperties: {\n      targetResourceId: {\n        constraints: {\n          Pattern: new RegExp(\n            \"^/subscriptions/[^/]*/resourceGroups/[^/]*/providers/Microsoft.CognitiveServices/accounts/[^/]*$\"\n          ),\n          MaxLength: 1024\n        },\n        serializedName: \"targetResourceId\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      targetResourceRegion: {\n        constraints: {\n          Pattern: new RegExp(\"^[a-z0-9]+$\"),\n          MaxLength: 24,\n          MinLength: 1\n        },\n        serializedName: \"targetResourceRegion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      copyAuthorization: {\n        serializedName: \"copyAuthorization\",\n        type: {\n          name: \"Composite\",\n          className: \"CopyAuthorizationResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const CopyAuthorizationResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"CopyAuthorizationResult\",\n    modelProperties: {\n      modelId: {\n        serializedName: \"modelId\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      accessToken: {\n        serializedName: \"accessToken\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      expirationDateTimeTicks: {\n        serializedName: \"expirationDateTimeTicks\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const CopyOperationResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"CopyOperationResult\",\n    modelProperties: {\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"notStarted\", \"running\", \"succeeded\", \"failed\"]\n        }\n      },\n      createdOn: {\n        serializedName: \"createdDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      lastModified: {\n        serializedName: \"lastUpdatedDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      copyResult: {\n        serializedName: \"copyResult\",\n        type: {\n          name: \"Composite\",\n          className: \"CopyResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const CopyResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"CopyResult\",\n    modelProperties: {\n      modelId: {\n        serializedName: \"modelId\",\n        required: true,\n        type: {\n          name: \"Uuid\"\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ErrorInformation\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const ComposeRequest: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ComposeRequest\",\n    modelProperties: {\n      modelIds: {\n        serializedName: \"modelIds\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Uuid\"\n            }\n          }\n        }\n      },\n      modelName: {\n        serializedName: \"modelName\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const Models: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Models\",\n    modelProperties: {\n      summary: {\n        serializedName: \"summary\",\n        type: {\n          name: \"Composite\",\n          className: \"ModelsSummary\"\n        }\n      },\n      modelList: {\n        serializedName: \"modelList\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"ModelInfo\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const ModelsSummary: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ModelsSummary\",\n    modelProperties: {\n      count: {\n        serializedName: \"count\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      limit: {\n        serializedName: \"limit\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      lastModified: {\n        serializedName: \"lastUpdatedDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientTrainCustomModelAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientTrainCustomModelAsyncHeaders\",\n    modelProperties: {\n      location: {\n        serializedName: \"location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeWithCustomModelHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeWithCustomModelHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientCopyCustomModelHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientCopyCustomModelHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientGenerateModelCopyAuthorizationHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientGenerateModelCopyAuthorizationHeaders\",\n    modelProperties: {\n      location: {\n        serializedName: \"location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientComposeCustomModelsAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientComposeCustomModelsAsyncHeaders\",\n    modelProperties: {\n      location: {\n        serializedName: \"location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeBusinessCardAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeBusinessCardAsyncHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeInvoiceAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeInvoiceAsyncHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeIdDocumentAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeIdDocumentAsyncHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeReceiptAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeReceiptAsyncHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeLayoutAsyncHeaders: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeLayoutAsyncHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport {\n  OperationParameter,\n  OperationURLParameter,\n  OperationQueryParameter\n} from \"@azure/core-http\";\nimport {\n  TrainRequest as TrainRequestMapper,\n  SourcePath as SourcePathMapper,\n  CopyRequest as CopyRequestMapper,\n  ComposeRequest as ComposeRequestMapper\n} from \"../models/mappers\";\n\nexport const contentType: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const trainRequest: OperationParameter = {\n  parameterPath: \"trainRequest\",\n  mapper: TrainRequestMapper\n};\n\nexport const accept: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const endpoint: OperationURLParameter = {\n  parameterPath: \"endpoint\",\n  mapper: {\n    serializedName: \"endpoint\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const modelId: OperationURLParameter = {\n  parameterPath: \"modelId\",\n  mapper: {\n    serializedName: \"modelId\",\n    required: true,\n    type: {\n      name: \"Uuid\"\n    }\n  }\n};\n\nexport const includeKeys: OperationQueryParameter = {\n  parameterPath: [\"options\", \"includeKeys\"],\n  mapper: {\n    serializedName: \"includeKeys\",\n    type: {\n      name: \"Boolean\"\n    }\n  }\n};\n\nexport const contentType1: OperationParameter = {\n  parameterPath: \"contentType\",\n  mapper: {\n    serializedName: \"Content-Type\",\n    required: true,\n    type: {\n      name: \"Enum\",\n      allowedValues: [\n        \"application/pdf\",\n        \"image/bmp\",\n        \"image/jpeg\",\n        \"image/png\",\n        \"image/tiff\"\n      ]\n    }\n  }\n};\n\nexport const fileStream: OperationParameter = {\n  parameterPath: \"fileStream\",\n  mapper: {\n    serializedName: \"fileStream\",\n    required: true,\n    type: {\n      name: \"Stream\"\n    }\n  }\n};\n\nexport const accept1: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const contentType2: OperationParameter = {\n  parameterPath: \"contentType\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const fileStream1: OperationParameter = {\n  parameterPath: [\"options\", \"fileStream\"],\n  mapper: SourcePathMapper\n};\n\nexport const includeTextDetails: OperationQueryParameter = {\n  parameterPath: [\"options\", \"includeTextDetails\"],\n  mapper: {\n    serializedName: \"includeTextDetails\",\n    type: {\n      name: \"Boolean\"\n    }\n  }\n};\n\nexport const pages: OperationQueryParameter = {\n  parameterPath: [\"options\", \"pages\"],\n  mapper: {\n    serializedName: \"pages\",\n    type: {\n      name: \"Sequence\",\n      element: {\n        constraints: {\n          Pattern: new RegExp(\"(^[0-9]+-[0-9]+$)|(^[0-9]+$)\")\n        },\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const resultId: OperationURLParameter = {\n  parameterPath: \"resultId\",\n  mapper: {\n    serializedName: \"resultId\",\n    required: true,\n    type: {\n      name: \"Uuid\"\n    }\n  }\n};\n\nexport const copyRequest: OperationParameter = {\n  parameterPath: \"copyRequest\",\n  mapper: CopyRequestMapper\n};\n\nexport const composeRequest: OperationParameter = {\n  parameterPath: \"composeRequest\",\n  mapper: ComposeRequestMapper\n};\n\nexport const accept2: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json, text/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const locale: OperationQueryParameter = {\n  parameterPath: [\"options\", \"locale\"],\n  mapper: {\n    serializedName: \"locale\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const language: OperationQueryParameter = {\n  parameterPath: [\"options\", \"language\"],\n  mapper: {\n    serializedName: \"language\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const readingOrder: OperationQueryParameter = {\n  parameterPath: [\"options\", \"readingOrder\"],\n  mapper: {\n    defaultValue: \"basic\",\n    serializedName: \"readingOrder\",\n    type: {\n      name: \"Enum\",\n      allowedValues: [\"basic\", \"natural\"]\n    }\n  }\n};\n\nexport const op: OperationQueryParameter = {\n  parameterPath: \"op\",\n  mapper: {\n    defaultValue: \"full\",\n    isConstant: true,\n    serializedName: \"op\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const op1: OperationQueryParameter = {\n  parameterPath: \"op\",\n  mapper: {\n    defaultValue: \"summary\",\n    isConstant: true,\n    serializedName: \"op\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const nextLink: OperationURLParameter = {\n  parameterPath: \"nextLink\",\n  mapper: {\n    serializedName: \"nextLink\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { GeneratedClientOptionalParams } from \"./models\";\n\nconst packageName = \"@azure/ai-form-recognizer\";\nconst packageVersion = \"3.1.0\";\n\n/** @hidden */\nexport class GeneratedClientContext extends coreHttp.ServiceClient {\n  endpoint: string;\n\n  /**\n   * Initializes a new instance of the GeneratedClientContext class.\n   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:\n   *                 https://westus2.api.cognitive.microsoft.com).\n   * @param options The parameter options\n   */\n  constructor(endpoint: string, options?: GeneratedClientOptionalParams) {\n    if (endpoint === undefined) {\n      throw new Error(\"'endpoint' cannot be null\");\n    }\n\n    // Initializing default values for options\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.userAgent) {\n      const defaultUserAgent = coreHttp.getDefaultUserAgentValue();\n      options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;\n    }\n\n    super(undefined, options);\n\n    this.requestContentType = \"application/json; charset=utf-8\";\n\n    this.baseUri = options.endpoint || \"{endpoint}/formrecognizer/v2.1\";\n\n    // Parameter assignments\n    this.endpoint = endpoint;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Parameters from \"./models/parameters\";\nimport * as Mappers from \"./models/mappers\";\nimport { GeneratedClientContext } from \"./generatedClientContext\";\nimport {\n  GeneratedClientOptionalParams,\n  TrainRequest,\n  GeneratedClientTrainCustomModelAsyncResponse,\n  GeneratedClientGetCustomModelOptionalParams,\n  GeneratedClientGetCustomModelResponse,\n  ContentType,\n  GeneratedClientAnalyzeWithCustomModel$binaryOptionalParams,\n  GeneratedClientAnalyzeWithCustomModel$jsonOptionalParams,\n  GeneratedClientAnalyzeWithCustomModelResponse,\n  GeneratedClientGetAnalyzeFormResultResponse,\n  CopyRequest,\n  GeneratedClientCopyCustomModelResponse,\n  GeneratedClientGetCustomModelCopyResultResponse,\n  GeneratedClientGenerateModelCopyAuthorizationResponse,\n  ComposeRequest,\n  GeneratedClientComposeCustomModelsAsyncResponse,\n  GeneratedClientAnalyzeBusinessCardAsync$binaryOptionalParams,\n  GeneratedClientAnalyzeBusinessCardAsync$jsonOptionalParams,\n  GeneratedClientAnalyzeBusinessCardAsyncResponse,\n  GeneratedClientGetAnalyzeBusinessCardResultResponse,\n  GeneratedClientAnalyzeInvoiceAsync$binaryOptionalParams,\n  GeneratedClientAnalyzeInvoiceAsync$jsonOptionalParams,\n  GeneratedClientAnalyzeInvoiceAsyncResponse,\n  GeneratedClientGetAnalyzeInvoiceResultResponse,\n  GeneratedClientAnalyzeIdDocumentAsync$binaryOptionalParams,\n  GeneratedClientAnalyzeIdDocumentAsync$jsonOptionalParams,\n  GeneratedClientAnalyzeIdDocumentAsyncResponse,\n  GeneratedClientGetAnalyzeIdDocumentResultResponse,\n  GeneratedClientAnalyzeReceiptAsync$binaryOptionalParams,\n  GeneratedClientAnalyzeReceiptAsync$jsonOptionalParams,\n  GeneratedClientAnalyzeReceiptAsyncResponse,\n  GeneratedClientGetAnalyzeReceiptResultResponse,\n  GeneratedClientAnalyzeLayoutAsync$binaryOptionalParams,\n  GeneratedClientAnalyzeLayoutAsync$jsonOptionalParams,\n  GeneratedClientAnalyzeLayoutAsyncResponse,\n  GeneratedClientGetAnalyzeLayoutResultResponse,\n  GeneratedClientListCustomModelsResponse,\n  GeneratedClientGetCustomModelsResponse,\n  GeneratedClientListCustomModelsNextResponse\n} from \"./models\";\n\n/** @hidden */\nexport class GeneratedClient extends GeneratedClientContext {\n  /**\n   * Initializes a new instance of the GeneratedClient class.\n   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:\n   *                 https://westus2.api.cognitive.microsoft.com).\n   * @param options The parameter options\n   */\n  constructor(endpoint: string, options?: GeneratedClientOptionalParams) {\n    super(endpoint, options);\n  }\n\n  /**\n   * Create and train a custom model. The request must include a source parameter that is either an\n   * externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or\n   * valid path to a data folder in a locally mounted drive. When local paths are specified, they must\n   * follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration\n   * setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source\n   * path would be '/input/contosodataset'. All data to be trained is expected to be under the source\n   * folder or sub folders under it. Models are trained using documents that are of the following content\n   * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Other type of\n   * content is ignored.\n   * @param trainRequest Training request parameters.\n   * @param options The options parameters.\n   */\n  trainCustomModelAsync(\n    trainRequest: TrainRequest,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientTrainCustomModelAsyncResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      trainRequest,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      trainCustomModelAsyncOperationSpec\n    ) as Promise<GeneratedClientTrainCustomModelAsyncResponse>;\n  }\n\n  /**\n   * Get detailed information about a custom model.\n   * @param modelId Model identifier.\n   * @param options The options parameters.\n   */\n  getCustomModel(\n    modelId: string,\n    options?: GeneratedClientGetCustomModelOptionalParams\n  ): Promise<GeneratedClientGetCustomModelResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      modelId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getCustomModelOperationSpec\n    ) as Promise<GeneratedClientGetCustomModelResponse>;\n  }\n\n  /**\n   * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.\n   * @param modelId Model identifier.\n   * @param options The options parameters.\n   */\n  deleteCustomModel(\n    modelId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<coreHttp.RestResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      modelId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      deleteCustomModelOperationSpec\n    ) as Promise<coreHttp.RestResponse>;\n  }\n\n  /**\n   * Extract key-value pairs, tables, and semantic values from a given document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri\n   * or local path) of the document to be analyzed.\n   * @param modelId Model identifier.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeWithCustomModel(\n    modelId: string,\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeWithCustomModel$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeWithCustomModelResponse>;\n  /**\n   * Extract key-value pairs, tables, and semantic values from a given document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri\n   * or local path) of the document to be analyzed.\n   * @param modelId Model identifier.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeWithCustomModel(\n    modelId: string,\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeWithCustomModel$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeWithCustomModelResponse>;\n  /**\n   * Extract key-value pairs, tables, and semantic values from a given document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri\n   * or local path) of the document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeWithCustomModel(\n    ...args:\n      | [\n          string,\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeWithCustomModel$binaryOptionalParams?\n        ]\n      | [\n          string,\n          \"application/json\",\n          GeneratedClientAnalyzeWithCustomModel$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeWithCustomModelResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[1] === \"application/pdf\" ||\n      args[1] === \"image/bmp\" ||\n      args[1] === \"image/jpeg\" ||\n      args[1] === \"image/png\" ||\n      args[1] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeWithCustomModel$binaryOperationSpec;\n      operationArguments = {\n        modelId: args[0],\n        contentType: args[1],\n        fileStream: args[2],\n        options: args[3]\n      };\n    } else if (args[1] === \"application/json\") {\n      operationSpec = analyzeWithCustomModel$jsonOperationSpec;\n      operationArguments = {\n        modelId: args[0],\n        contentType: args[1],\n        options: args[2]\n      };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[1]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeWithCustomModelResponse>;\n  }\n\n  /**\n   * Obtain current status and the result of the analyze form operation.\n   * @param modelId Model identifier.\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeFormResult(\n    modelId: string,\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeFormResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      modelId,\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeFormResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeFormResultResponse>;\n  }\n\n  /**\n   * Copy custom model stored in this resource (the source) to user specified target Form Recognizer\n   * resource.\n   * @param modelId Model identifier.\n   * @param copyRequest Copy request parameters.\n   * @param options The options parameters.\n   */\n  copyCustomModel(\n    modelId: string,\n    copyRequest: CopyRequest,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientCopyCustomModelResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      modelId,\n      copyRequest,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      copyCustomModelOperationSpec\n    ) as Promise<GeneratedClientCopyCustomModelResponse>;\n  }\n\n  /**\n   * Obtain current status and the result of a custom model copy operation.\n   * @param modelId Model identifier.\n   * @param resultId Copy operation result identifier.\n   * @param options The options parameters.\n   */\n  getCustomModelCopyResult(\n    modelId: string,\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetCustomModelCopyResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      modelId,\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getCustomModelCopyResultOperationSpec\n    ) as Promise<GeneratedClientGetCustomModelCopyResultResponse>;\n  }\n\n  /**\n   * Generate authorization to copy a model into the target Form Recognizer resource.\n   * @param options The options parameters.\n   */\n  generateModelCopyAuthorization(\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGenerateModelCopyAuthorizationResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      generateModelCopyAuthorizationOperationSpec\n    ) as Promise<GeneratedClientGenerateModelCopyAuthorizationResponse>;\n  }\n\n  /**\n   * Compose request would include list of models ids.\n   * It would validate what all models either trained with labels model or composed model.\n   * It would validate limit of models put together.\n   * @param composeRequest Compose models\n   * @param options The options parameters.\n   */\n  composeCustomModelsAsync(\n    composeRequest: ComposeRequest,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientComposeCustomModelsAsyncResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      composeRequest,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      composeCustomModelsAsyncOperationSpec\n    ) as Promise<GeneratedClientComposeCustomModelsAsyncResponse>;\n  }\n\n  /**\n   * Extract field text and semantic values from a given business card document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location\n   * (Uri) of the document to be analyzed.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeBusinessCardAsync(\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeBusinessCardAsync$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeBusinessCardAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given business card document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location\n   * (Uri) of the document to be analyzed.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeBusinessCardAsync(\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeBusinessCardAsync$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeBusinessCardAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given business card document. The input document must\n   * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',\n   * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location\n   * (Uri) of the document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeBusinessCardAsync(\n    ...args:\n      | [\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeBusinessCardAsync$binaryOptionalParams?\n        ]\n      | [\n          \"application/json\",\n          GeneratedClientAnalyzeBusinessCardAsync$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeBusinessCardAsyncResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[0] === \"application/pdf\" ||\n      args[0] === \"image/bmp\" ||\n      args[0] === \"image/jpeg\" ||\n      args[0] === \"image/png\" ||\n      args[0] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeBusinessCardAsync$binaryOperationSpec;\n      operationArguments = {\n        contentType: args[0],\n        fileStream: args[1],\n        options: args[2]\n      };\n    } else if (args[0] === \"application/json\") {\n      operationSpec = analyzeBusinessCardAsync$jsonOperationSpec;\n      operationArguments = { contentType: args[0], options: args[1] };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[0]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeBusinessCardAsyncResponse>;\n  }\n\n  /**\n   * Track the progress and obtain the result of the analyze business card operation.\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeBusinessCardResult(\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeBusinessCardResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeBusinessCardResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeBusinessCardResultResponse>;\n  }\n\n  /**\n   * Extract field text and semantic values from a given invoice document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeInvoiceAsync(\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeInvoiceAsync$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeInvoiceAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given invoice document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeInvoiceAsync(\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeInvoiceAsync$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeInvoiceAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given invoice document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeInvoiceAsync(\n    ...args:\n      | [\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeInvoiceAsync$binaryOptionalParams?\n        ]\n      | [\n          \"application/json\",\n          GeneratedClientAnalyzeInvoiceAsync$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeInvoiceAsyncResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[0] === \"application/pdf\" ||\n      args[0] === \"image/bmp\" ||\n      args[0] === \"image/jpeg\" ||\n      args[0] === \"image/png\" ||\n      args[0] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeInvoiceAsync$binaryOperationSpec;\n      operationArguments = {\n        contentType: args[0],\n        fileStream: args[1],\n        options: args[2]\n      };\n    } else if (args[0] === \"application/json\") {\n      operationSpec = analyzeInvoiceAsync$jsonOperationSpec;\n      operationArguments = { contentType: args[0], options: args[1] };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[0]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeInvoiceAsyncResponse>;\n  }\n\n  /**\n   * Track the progress and obtain the result of the analyze invoice operation.\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeInvoiceResult(\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeInvoiceResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeInvoiceResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeInvoiceResultResponse>;\n  }\n\n  /**\n   * Extract field text and semantic values from a given ID document. The input document must be of one\n   * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeIdDocumentAsync(\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeIdDocumentAsync$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeIdDocumentAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given ID document. The input document must be of one\n   * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeIdDocumentAsync(\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeIdDocumentAsync$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeIdDocumentAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given ID document. The input document must be of one\n   * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeIdDocumentAsync(\n    ...args:\n      | [\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeIdDocumentAsync$binaryOptionalParams?\n        ]\n      | [\n          \"application/json\",\n          GeneratedClientAnalyzeIdDocumentAsync$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeIdDocumentAsyncResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[0] === \"application/pdf\" ||\n      args[0] === \"image/bmp\" ||\n      args[0] === \"image/jpeg\" ||\n      args[0] === \"image/png\" ||\n      args[0] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeIdDocumentAsync$binaryOperationSpec;\n      operationArguments = {\n        contentType: args[0],\n        fileStream: args[1],\n        options: args[2]\n      };\n    } else if (args[0] === \"application/json\") {\n      operationSpec = analyzeIdDocumentAsync$jsonOperationSpec;\n      operationArguments = { contentType: args[0], options: args[1] };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[0]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeIdDocumentAsyncResponse>;\n  }\n\n  /**\n   * Track the progress and obtain the result of the analyze ID operation.\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeIdDocumentResult(\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeIdDocumentResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeIdDocumentResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeIdDocumentResultResponse>;\n  }\n\n  /**\n   * Extract field text and semantic values from a given receipt document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeReceiptAsync(\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeReceiptAsync$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeReceiptAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given receipt document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeReceiptAsync(\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeReceiptAsync$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeReceiptAsyncResponse>;\n  /**\n   * Extract field text and semantic values from a given receipt document. The input document must be of\n   * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or\n   * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the\n   * document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeReceiptAsync(\n    ...args:\n      | [\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeReceiptAsync$binaryOptionalParams?\n        ]\n      | [\n          \"application/json\",\n          GeneratedClientAnalyzeReceiptAsync$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeReceiptAsyncResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[0] === \"application/pdf\" ||\n      args[0] === \"image/bmp\" ||\n      args[0] === \"image/jpeg\" ||\n      args[0] === \"image/png\" ||\n      args[0] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeReceiptAsync$binaryOperationSpec;\n      operationArguments = {\n        contentType: args[0],\n        fileStream: args[1],\n        options: args[2]\n      };\n    } else if (args[0] === \"application/json\") {\n      operationSpec = analyzeReceiptAsync$jsonOperationSpec;\n      operationArguments = { contentType: args[0], options: args[1] };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[0]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeReceiptAsyncResponse>;\n  }\n\n  /**\n   * Track the progress and obtain the result of the analyze receipt operation.\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeReceiptResult(\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeReceiptResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeReceiptResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeReceiptResultResponse>;\n  }\n\n  /**\n   * Extract text and layout information from a given document. The input document must be of one of the\n   * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.\n   * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the\n   * document to be analyzed.\n   * @param contentType Upload file type\n   * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.\n   * @param options The options parameters.\n   */\n  analyzeLayoutAsync(\n    contentType: ContentType,\n    fileStream: coreHttp.HttpRequestBody,\n    options?: GeneratedClientAnalyzeLayoutAsync$binaryOptionalParams\n  ): Promise<GeneratedClientAnalyzeLayoutAsyncResponse>;\n  /**\n   * Extract text and layout information from a given document. The input document must be of one of the\n   * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.\n   * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the\n   * document to be analyzed.\n   * @param contentType Body Parameter content-type\n   * @param options The options parameters.\n   */\n  analyzeLayoutAsync(\n    contentType: \"application/json\",\n    options?: GeneratedClientAnalyzeLayoutAsync$jsonOptionalParams\n  ): Promise<GeneratedClientAnalyzeLayoutAsyncResponse>;\n  /**\n   * Extract text and layout information from a given document. The input document must be of one of the\n   * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.\n   * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the\n   * document to be analyzed.\n   * @param args Includes all the parameters for this operation.\n   */\n  analyzeLayoutAsync(\n    ...args:\n      | [\n          ContentType,\n          coreHttp.HttpRequestBody,\n          GeneratedClientAnalyzeLayoutAsync$binaryOptionalParams?\n        ]\n      | [\n          \"application/json\",\n          GeneratedClientAnalyzeLayoutAsync$jsonOptionalParams?\n        ]\n  ): Promise<GeneratedClientAnalyzeLayoutAsyncResponse> {\n    let operationSpec: coreHttp.OperationSpec;\n    let operationArguments: coreHttp.OperationArguments;\n    if (\n      args[0] === \"application/pdf\" ||\n      args[0] === \"image/bmp\" ||\n      args[0] === \"image/jpeg\" ||\n      args[0] === \"image/png\" ||\n      args[0] === \"image/tiff\"\n    ) {\n      operationSpec = analyzeLayoutAsync$binaryOperationSpec;\n      operationArguments = {\n        contentType: args[0],\n        fileStream: args[1],\n        options: args[2]\n      };\n    } else if (args[0] === \"application/json\") {\n      operationSpec = analyzeLayoutAsync$jsonOperationSpec;\n      operationArguments = { contentType: args[0], options: args[1] };\n    } else {\n      throw new TypeError(\n        `\"contentType\" must be a valid value but instead was \"${args[0]}\".`\n      );\n    }\n    operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(\n      operationArguments.options || {}\n    );\n    return this.sendOperationRequest(\n      operationArguments,\n      operationSpec\n    ) as Promise<GeneratedClientAnalyzeLayoutAsyncResponse>;\n  }\n\n  /**\n   * Track the progress and obtain the result of the analyze layout operation\n   * @param resultId Analyze operation result identifier.\n   * @param options The options parameters.\n   */\n  getAnalyzeLayoutResult(\n    resultId: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetAnalyzeLayoutResultResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      resultId,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getAnalyzeLayoutResultOperationSpec\n    ) as Promise<GeneratedClientGetAnalyzeLayoutResultResponse>;\n  }\n\n  /**\n   * Get information about all custom models\n   * @param options The options parameters.\n   */\n  listCustomModels(\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientListCustomModelsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      listCustomModelsOperationSpec\n    ) as Promise<GeneratedClientListCustomModelsResponse>;\n  }\n\n  /**\n   * Get information about all custom models\n   * @param options The options parameters.\n   */\n  getCustomModels(\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientGetCustomModelsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getCustomModelsOperationSpec\n    ) as Promise<GeneratedClientGetCustomModelsResponse>;\n  }\n\n  /**\n   * ListCustomModelsNext\n   * @param nextLink The nextLink from the previous successful call to the ListCustomModels method.\n   * @param options The options parameters.\n   */\n  listCustomModelsNext(\n    nextLink: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<GeneratedClientListCustomModelsNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      listCustomModelsNextOperationSpec\n    ) as Promise<GeneratedClientListCustomModelsNextResponse>;\n  }\n}\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);\n\nconst trainCustomModelAsyncOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models\",\n  httpMethod: \"POST\",\n  responses: {\n    201: {\n      headersMapper: Mappers.GeneratedClientTrainCustomModelAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.trainRequest,\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getCustomModelOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.Model\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [Parameters.includeKeys],\n  urlParameters: [Parameters.endpoint, Parameters.modelId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteCustomModelOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.modelId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst analyzeWithCustomModel$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [Parameters.includeTextDetails, Parameters.pages],\n  urlParameters: [Parameters.endpoint, Parameters.modelId],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeWithCustomModel$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [Parameters.includeTextDetails, Parameters.pages],\n  urlParameters: [Parameters.endpoint, Parameters.modelId],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeFormResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst copyCustomModelOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}/copy\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientCopyCustomModelHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.copyRequest,\n  urlParameters: [Parameters.endpoint, Parameters.modelId],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getCustomModelCopyResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/{modelId}/copyResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.CopyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst generateModelCopyAuthorizationOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/copyAuthorization\",\n  httpMethod: \"POST\",\n  responses: {\n    201: {\n      bodyMapper: Mappers.CopyAuthorizationResult,\n      headersMapper:\n        Mappers.GeneratedClientGenerateModelCopyAuthorizationHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst composeCustomModelsAsyncOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models/compose\",\n  httpMethod: \"POST\",\n  responses: {\n    201: {\n      headersMapper: Mappers.GeneratedClientComposeCustomModelsAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.composeRequest,\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType, Parameters.accept2],\n  mediaType: \"json\",\n  serializer\n};\nconst analyzeBusinessCardAsync$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/businessCard/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeBusinessCardAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeBusinessCardAsync$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/businessCard/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeBusinessCardAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeBusinessCardResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/businessCard/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst analyzeInvoiceAsync$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/invoice/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeInvoiceAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeInvoiceAsync$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/invoice/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeInvoiceAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeInvoiceResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/invoice/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst analyzeIdDocumentAsync$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/idDocument/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeIdDocumentAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [Parameters.includeTextDetails, Parameters.pages],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeIdDocumentAsync$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/idDocument/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeIdDocumentAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [Parameters.includeTextDetails, Parameters.pages],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeIdDocumentResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/idDocument/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst analyzeReceiptAsync$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/receipt/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeReceiptAsync$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/receipt/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [\n    Parameters.includeTextDetails,\n    Parameters.pages,\n    Parameters.locale\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeReceiptResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/prebuilt/receipt/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst analyzeLayoutAsync$binaryOperationSpec: coreHttp.OperationSpec = {\n  path: \"/layout/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream,\n  queryParameters: [\n    Parameters.pages,\n    Parameters.language,\n    Parameters.readingOrder\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.contentType1, Parameters.accept1],\n  mediaType: \"binary\",\n  serializer\n};\nconst analyzeLayoutAsync$jsonOperationSpec: coreHttp.OperationSpec = {\n  path: \"/layout/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.fileStream1,\n  queryParameters: [\n    Parameters.pages,\n    Parameters.language,\n    Parameters.readingOrder\n  ],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept, Parameters.contentType2],\n  mediaType: \"json\",\n  serializer\n};\nconst getAnalyzeLayoutResultOperationSpec: coreHttp.OperationSpec = {\n  path: \"/layout/analyzeResults/{resultId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [Parameters.endpoint, Parameters.resultId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listCustomModelsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.Models\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [Parameters.op],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getCustomModelsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/custom/models\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.Models\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [Parameters.op1],\n  urlParameters: [Parameters.endpoint],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listCustomModelsNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.Models\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [Parameters.op],\n  urlParameters: [Parameters.endpoint, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, AbortSignalLike } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { BeginRecognizeContentOptions } from \"../../formRecognizerClient\";\nimport { FormContentType } from \"../../common\";\n\nimport {\n  GeneratedClientAnalyzeLayoutAsyncResponse as AnalyzeLayoutAsyncResponseModel,\n  OperationStatus\n} from \"../../generated/models\";\nimport { FormRecognizerRequestBody, FormPageArray } from \"../../models\";\nimport { RecognizeContentResultResponse } from \"../../internalModels\";\nexport { OperationStatus };\n\nexport interface ContentPollerOperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  updateIntervalInMs?: number;\n  /**\n   * callback to receive events on the progress of download operation.\n   */\n  onProgress?: (state: BeginRecognizeContentPollState) => void;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Defines the operations from a analyze client that are needed for the poller\n * to work\n */\nexport type RecognizeContentPollerClient = {\n  // returns a result id to retrieve results\n  beginRecognize: (\n    source: FormRecognizerRequestBody | string,\n    contentType?: FormContentType,\n    analyzeOptions?: BeginRecognizeContentOptions\n  ) => Promise<AnalyzeLayoutAsyncResponseModel>;\n  // retrieves analyze result\n  getRecognizeResult: (\n    resultId: string,\n    options: { abortSignal?: AbortSignalLike }\n  ) => Promise<RecognizeContentResultResponse>;\n};\n\nexport interface BeginRecognizeContentPollState extends PollOperationState<FormPageArray> {\n  readonly client: RecognizeContentPollerClient;\n  source?: FormRecognizerRequestBody | string;\n  contentType?: FormContentType;\n  resultId?: string;\n  status: OperationStatus;\n  readonly analyzeOptions?: BeginRecognizeContentOptions;\n}\n\nexport interface BeginRecognizeContentPollerOperation\n  extends PollOperation<BeginRecognizeContentPollState, FormPageArray> {}\n\n/**\n * @internal\n */\nexport type BeginRecognizeContentPollerOptions = {\n  client: RecognizeContentPollerClient;\n  source: FormRecognizerRequestBody | string;\n  contentType?: FormContentType;\n  updateIntervalInMs?: number;\n  resultId?: string;\n  onProgress?: (state: BeginRecognizeContentPollState) => void;\n  resumeFrom?: string;\n} & BeginRecognizeContentOptions;\n\n/**\n * Class that represents a poller that waits until a model has been trained.\n */\nexport class BeginRecognizeContentPoller extends Poller<\n  BeginRecognizeContentPollState,\n  FormPageArray\n> {\n  public updateIntervalInMs: number;\n\n  constructor(options: BeginRecognizeContentPollerOptions) {\n    const {\n      client,\n      source,\n      contentType,\n      updateIntervalInMs = 5000,\n      resultId,\n      onProgress,\n      resumeFrom\n    } = options;\n\n    let state: BeginRecognizeContentPollState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeBeginRecognizePollOperation({\n      ...state,\n      client,\n      source,\n      contentType,\n      resultId,\n      status: \"notStarted\",\n      analyzeOptions: options\n    });\n\n    super(operation);\n\n    if (typeof onProgress === \"function\") {\n      this.onProgress(onProgress);\n    }\n\n    this.updateIntervalInMs = updateIntervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n/**\n * Creates a poll operation given the provided state.\n * @internal\n */\nfunction makeBeginRecognizePollOperation(\n  state: BeginRecognizeContentPollState\n): BeginRecognizeContentPollerOperation {\n  return {\n    state: { ...state },\n\n    async cancel(_options = {}): Promise<BeginRecognizeContentPollerOperation> {\n      throw new Error(\"Cancel operation is not supported.\");\n    },\n\n    async update(options = {}): Promise<BeginRecognizeContentPollerOperation> {\n      const pollerState = this.state;\n      const { client, source, contentType, analyzeOptions } = pollerState;\n\n      if (!pollerState.isStarted) {\n        if (!source) {\n          throw new Error(\"Expect a valid 'source'\");\n        }\n\n        pollerState.isStarted = true;\n        const result = await client.beginRecognize(source, contentType, analyzeOptions || {});\n        if (!result.operationLocation) {\n          throw new Error(\"Expect a valid 'operationLocation' to retrieve analyze results\");\n        }\n        const lastSlashIndex = result.operationLocation.lastIndexOf(\"/\");\n        pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);\n        // source is no longer needed\n        pollerState.source = undefined;\n      }\n\n      const response = await client.getRecognizeResult(pollerState.resultId!, {\n        abortSignal: analyzeOptions?.abortSignal\n      });\n\n      pollerState.status = response.status;\n      if (!pollerState.isCompleted) {\n        if (typeof options.fireProgress === \"function\") {\n          options.fireProgress(pollerState);\n        }\n\n        if (response.status === \"succeeded\") {\n          pollerState.result = response.pages;\n          pollerState.isCompleted = true;\n        } else if (response.status === \"failed\") {\n          const errors = response.errors\n            ?.map((e) => `  code ${e.code}, message: '${e.message}'`)\n            .join(\"\\n\");\n          const message = `Content recognition failed.\nError(s):\n${errors || \"\"}\n`;\n          throw new Error(message);\n        }\n      }\n\n      return makeBeginRecognizePollOperation(pollerState);\n    },\n\n    toString() {\n      return JSON.stringify({ state: this.state }, (key, value) => {\n        if (key === \"client\" || key === \"source\") {\n          return undefined;\n        }\n        return value;\n      });\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AnalyzeResult as AnalyzeResultModel,\n  DataTable as DataTableModel,\n  DocumentResult as DocumentResultModel,\n  FieldValue as FieldValueModel,\n  KeyValueElement as KeyValueElementModel,\n  KeyValuePair as KeyValuePairModel,\n  PageResult as PageResultModel,\n  ReadResult as ReadResultModel,\n  TextLine as TextLineModel,\n  GeneratedClientGetAnalyzeFormResultResponse as GetAnalyzeFormResultResponse,\n  GeneratedClientGetAnalyzeLayoutResultResponse as GetAnalyzeLayoutResultResponse,\n  GeneratedClientGetCustomModelResponse as GetCustomModelResponse,\n  SelectionMark,\n  TrainResult,\n  KeysResult,\n  Attributes\n} from \"./generated/models\";\n\nimport {\n  FormPage,\n  FormLine,\n  FormElement,\n  FormTable,\n  RecognizedForm,\n  FieldData,\n  FormField,\n  Point2D,\n  FormModelResponse,\n  CustomFormModelField,\n  CustomFormSubmodel,\n  RecognizedFormArray,\n  FormSelectionMark,\n  TrainingDocumentInfo,\n  CustomFormModelProperties\n} from \"./models\";\nimport { RecognizeContentResultResponse } from \"./internalModels\";\n\nfunction toBoundingBox(original: number[]): Point2D[] {\n  return [\n    { x: original[0], y: original[1] },\n    { x: original[2], y: original[3] },\n    { x: original[4], y: original[5] },\n    { x: original[6], y: original[7] }\n  ];\n}\n\nexport function toTextLine(original: TextLineModel, pageNumber: number): FormLine {\n  const appearance =\n    original.appearance !== undefined\n      ? {\n          styleName: original.appearance.style.name,\n          styleConfidence: original.appearance.style.confidence\n        }\n      : undefined;\n\n  const line: FormLine = {\n    kind: \"line\",\n    pageNumber,\n    text: original.text,\n    boundingBox: toBoundingBox(original.boundingBox),\n    appearance,\n    words: original.words.map((w) => {\n      return {\n        kind: \"word\",\n        text: w.text,\n        boundingBox: toBoundingBox(w.boundingBox),\n        confidence: w.confidence || 1,\n        pageNumber\n      };\n    })\n  };\n\n  return line;\n}\n\nexport function toSelectionMark(original: SelectionMark, pageNumber: number): FormSelectionMark {\n  return {\n    kind: \"selectionMark\",\n    pageNumber,\n    boundingBox: toBoundingBox(original.boundingBox),\n    confidence: original.confidence,\n    state: original.state\n  };\n}\n\nexport function toFormPage(original: ReadResultModel): FormPage {\n  return {\n    pageNumber: original.pageNumber,\n    textAngle: original.angle,\n    width: original.width,\n    height: original.height,\n    unit: original.unit,\n    lines: original.lines?.map((l) => toTextLine(l, original.pageNumber)),\n    selectionMarks: original.selectionMarks?.map((m) => toSelectionMark(m, original.pageNumber))\n  };\n}\n\n// Note: might need to support other element types in future, e.g., checkbox\nconst textPattern = /\\/readResults\\/(\\d+)\\/lines\\/(\\d+)(?:\\/words\\/(\\d+))?/;\n\nexport function toFormContent(element: string, readResults: FormPage[]): FormElement {\n  const result = textPattern.exec(element);\n  if (!result || !result[0] || !result[1] || !result[2]) {\n    throw new Error(`Unexpected element reference encountered: ${element}`);\n  }\n\n  const readIndex = Number.parseInt(result[1]);\n  const lineIndex = Number.parseInt(result[2]);\n  if (result[3]) {\n    const wordIndex = Number.parseInt(result[3]);\n    return readResults[readIndex].lines![lineIndex].words[wordIndex];\n  } else {\n    return readResults[readIndex].lines![lineIndex];\n  }\n}\n\nexport function toFieldData(\n  pageNumber: number,\n  original: KeyValueElementModel,\n  readResults?: FormPage[]\n): FieldData {\n  return {\n    pageNumber,\n    text: original.text,\n    boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,\n    fieldElements: original.elements?.map((element) => toFormContent(element, readResults!))\n  };\n}\n\nexport function toFormFieldFromKeyValuePairModel(\n  pageNumber: number,\n  original: KeyValuePairModel,\n  readResults?: FormPage[]\n): FormField {\n  return {\n    name: original.label,\n    confidence: original.confidence || 1,\n    labelData: toFieldData(pageNumber, original.key, readResults),\n    valueData: toFieldData(pageNumber, original.value, readResults),\n    value: original.value.text,\n    valueType: \"string\"\n  };\n}\n\nexport function toFormTable(\n  original: DataTableModel,\n  readResults: FormPage[],\n  pageNumber: number\n): FormTable {\n  return {\n    rowCount: original.rows,\n    columnCount: original.columns,\n    boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,\n    cells: original.cells.map((cell) => ({\n      boundingBox: toBoundingBox(cell.boundingBox),\n      columnIndex: cell.columnIndex,\n      fieldElements: cell.elements?.map((element) => toFormContent(element, readResults)),\n      rowIndex: cell.rowIndex,\n      columnSpan: cell.columnSpan ?? 1,\n      rowSpan: cell.rowSpan ?? 1,\n      isHeader: cell.isHeader ?? false,\n      isFooter: cell.isFooter ?? false,\n      confidence: cell.confidence ?? 1,\n      text: cell.text,\n      pageNumber\n    })),\n    pageNumber\n  };\n}\n\nexport function toFormPages(\n  readResults?: ReadResultModel[],\n  pageResults?: PageResultModel[]\n): FormPage[] {\n  const transformed = readResults?.map(toFormPage);\n  // maps from page numbers to the objects\n  const pageMap = new Map<number, PageResultModel>(pageResults?.map((r) => [r.pageNumber, r]));\n  return (\n    transformed?.map((page) => {\n      const { pageNumber } = page;\n      const pageResult = pageMap.get(pageNumber);\n      return {\n        ...page,\n        tables:\n          pageResult?.tables?.map((table) => toFormTable(table, transformed, pageNumber)) ?? []\n      };\n    }) ?? []\n  );\n}\n\nexport function toRecognizedFormArray(\n  original: GetAnalyzeFormResultResponse,\n  expectedDocTypePrefix?: string\n): RecognizedFormArray {\n  const pages = toFormPages(\n    original.analyzeResult?.readResults,\n    original.analyzeResult?.pageResults\n  );\n\n  if (original.analyzeResult?.documentResults?.length) {\n    // supervised/prebuilt results come from documentResults\n    return (\n      original.analyzeResult?.documentResults\n        ?.filter((d) => !!d.fields)\n        ?.map((d) => {\n          if (expectedDocTypePrefix !== undefined && !d.docType.startsWith(expectedDocTypePrefix)) {\n            throw new RangeError(\n              `Expected document type to start with '${expectedDocTypePrefix}', but found '${d.docType}'.`\n            );\n          }\n          return toRecognizedForm(d, pages);\n        }) ?? []\n    );\n  } else {\n    // unsupervised results from from pageResults;\n    return original.analyzeResult?.pageResults?.map((p) => toFormFromPageResult(p, pages)) ?? [];\n  }\n}\n\nexport function toFormFieldFromFieldValueModel(\n  original: FieldValueModel,\n  key: string,\n  readResults: FormPage[]\n): FormField {\n  let value:\n    | string\n    | Date\n    | number\n    | FormField[]\n    | { [propertyName: string]: FormField }\n    | undefined;\n\n  function unreachable(v: never): never {\n    throw new Error(`Encountered unknown field value type: ${v}`);\n  }\n\n  switch (original.type) {\n    case \"string\":\n      value = original.valueString;\n      break;\n    case \"date\":\n      value = original.valueDate;\n      break;\n    case \"time\":\n      value = original.valueTime;\n      break;\n    case \"integer\":\n      value = original.valueInteger;\n      break;\n    case \"number\":\n      value = original.valueNumber;\n      break;\n    case \"phoneNumber\":\n      value = original.valuePhoneNumber;\n      break;\n    case \"selectionMark\":\n      value = original.valueSelectionMark;\n      break;\n    case \"array\":\n      value = original.valueArray?.map((fieldValueModel) =>\n        toFormFieldFromFieldValueModel(fieldValueModel, key, readResults)\n      );\n      break;\n    case \"object\":\n      value = original.valueObject\n        ? toFieldsFromFieldValue(original.valueObject, readResults)\n        : undefined;\n      break;\n    case \"countryRegion\":\n      value = original.valueCountryRegion;\n      break;\n    default:\n      return unreachable(original.type);\n  }\n  return {\n    confidence: original.confidence || 1,\n    name: key,\n    valueData: {\n      pageNumber: original.pageNumber ?? 0,\n      text: original.text,\n      boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,\n      fieldElements: original.elements?.map((element) => toFormContent(element, readResults))\n    },\n    valueType: original.type,\n    value\n  } as FormField;\n}\n\nexport function toFieldsFromFieldValue(\n  original: { [propertyName: string]: FieldValueModel | null },\n  readResults: FormPage[]\n): { [propertyName: string]: FormField } {\n  const result: { [propertyName: string]: FormField } = {};\n  for (const key in original) {\n    if (Object.prototype.hasOwnProperty.call(original, key)) {\n      if (!original[key]) {\n        result[key] = { name: key };\n        continue;\n      }\n      const formField = toFormFieldFromFieldValueModel(original[key]!, key, readResults);\n      result[key] = formField;\n    }\n  }\n\n  return result;\n}\n\nexport function toFieldsFromKeyValuePairs(\n  pageNumber: number,\n  original: KeyValuePairModel[],\n  pages: FormPage[]\n): { [propertyName: string]: FormField } {\n  const result: { [propertyName: string]: FormField } = {};\n  for (let i = 0; i < original.length; i++) {\n    const pair = original[i];\n    const stringField = toFormFieldFromKeyValuePairModel(pageNumber, pair, pages);\n    stringField.name = stringField.name || `field-${i}`;\n\n    result[`field-${i}`] = stringField;\n  }\n\n  return result;\n}\n\nexport function toFormFromPageResult(original: PageResultModel, pages: FormPage[]): RecognizedForm {\n  return {\n    formType: `form-${original.clusterId}`,\n    pageRange: { firstPageNumber: original.pageNumber, lastPageNumber: original.pageNumber },\n    pages: pages.filter((p) => p.pageNumber === original.pageNumber),\n    fields: original.keyValuePairs\n      ? toFieldsFromKeyValuePairs(original.pageNumber, original.keyValuePairs, pages)\n      : {}\n  };\n}\n\nexport function toRecognizedForm(original: DocumentResultModel, pages: FormPage[]): RecognizedForm {\n  return {\n    formType: original.docType,\n    formTypeConfidence: original.docTypeConfidence,\n    modelId: original.modelId,\n    pageRange: { firstPageNumber: original.pageRange[0], lastPageNumber: original.pageRange[1] },\n    fields: toFieldsFromFieldValue(original.fields, pages),\n    pages: pages.filter(\n      (p) => original.pageRange[0] <= p.pageNumber && p.pageNumber <= original.pageRange[1]\n    )\n  };\n}\n\nexport function toRecognizeContentResultResponse(\n  original: GetAnalyzeLayoutResultResponse\n): RecognizeContentResultResponse {\n  function toRecognizeContentResult(\n    model?: AnalyzeResultModel\n  ): { version?: string; pages?: FormPage[] } | undefined {\n    if (!model) {\n      return undefined;\n    }\n    const pages = toFormPages(model.readResults, model.pageResults);\n    return {\n      version: model.version,\n      pages: pages\n    };\n  }\n\n  const common = {\n    status: original.status,\n    createdOn: original.createdOn,\n    errors: original.analyzeResult?.errors,\n    lastModified: original.lastModified,\n    _response: original._response\n  };\n  if (original.status === \"succeeded\") {\n    return {\n      ...common,\n      ...toRecognizeContentResult(original.analyzeResult)\n    };\n  } else {\n    return common;\n  }\n}\n\nfunction flattenTrainingDocuments(\n  original: GetCustomModelResponse\n): TrainingDocumentInfo[] | undefined {\n  if (original.composedTrainResults) {\n    // Composed model, need to zip the training documents into a flat array and add modelID correlation.\n    const mappedResultDocuments = original.composedTrainResults.map((innerResult) =>\n      innerResult.trainingDocuments.map((info) => ({\n        ...info,\n        modelId: innerResult.modelId,\n        errors: info.errors ?? []\n      }))\n    );\n\n    return ([] as TrainingDocumentInfo[]).concat(...mappedResultDocuments);\n  } else if (original.trainResult) {\n    // Normal training scenario with only one trainResult\n    return original.trainResult.trainingDocuments.map((info) => ({\n      ...info,\n      modelId: original.modelInfo.modelId,\n      errors: info.errors ?? []\n    }));\n  }\n\n  return undefined;\n}\n\nfunction toSubmodelsFromComposedTrainResults(results: TrainResult[]): CustomFormSubmodel[] {\n  const mappedSubmodels = results.map((r) => toSubmodelsFromTrainResultLabeled(r));\n\n  // Flatten the array\n  return ([] as CustomFormSubmodel[]).concat(...mappedSubmodels);\n}\n\nfunction toSubmodelsFromTrainResultLabeled(\n  result: TrainResult,\n  modelName?: string\n): CustomFormSubmodel[] {\n  return [\n    {\n      modelId: result.modelId,\n      accuracy: result.averageModelAccuracy,\n      formType: `custom:${modelName ?? result.modelId}`,\n      fields:\n        result.fields?.reduce((fields, field) => {\n          fields[field.fieldName] = {\n            name: field.fieldName,\n            accuracy: field.accuracy,\n            label: null\n          };\n          return fields;\n        }, {} as Record<string, CustomFormModelField>) ?? {}\n    }\n  ];\n}\n\nfunction toSubmodelsFromTrainResultUnlabeled(\n  keys: KeysResult,\n  modelId: string\n): CustomFormSubmodel[] {\n  // Each cluster becomes a submodel\n  return Object.entries(keys.clusters).map(\n    ([clusterKey, cluster]): CustomFormSubmodel => ({\n      modelId,\n      // Create formType from the key of the cluster\n      formType: `form-${clusterKey}`,\n      // Roll the fields up into the correct shape\n      fields: cluster.reduce((fields, label, idx) => {\n        fields[`field-${idx}`] = {\n          name: `field-${idx}`,\n          label\n        };\n        return fields;\n      }, {} as Record<string, CustomFormModelField>)\n    })\n  );\n}\n\nfunction flattenCustomFormSubmodels(\n  original: GetCustomModelResponse\n): CustomFormSubmodel[] | undefined {\n  if (original.modelInfo.status === \"ready\") {\n    if (original.composedTrainResults !== undefined) {\n      return toSubmodelsFromComposedTrainResults(original.composedTrainResults);\n    } else if (original.trainResult?.fields || original.trainResult?.averageModelAccuracy) {\n      return toSubmodelsFromTrainResultLabeled(original.trainResult, original.modelInfo.modelName);\n    } else if (original.keys) {\n      return toSubmodelsFromTrainResultUnlabeled(original.keys, original.modelInfo.modelId);\n    } else {\n      throw new Error(\"No submodel information was found in the training response.\");\n    }\n  }\n  return undefined;\n}\n\nexport function toCustomFormModelProperties(\n  original: Attributes | undefined\n): CustomFormModelProperties | undefined {\n  if (original) {\n    return {\n      isComposedModel: original.isComposed\n    };\n  } else {\n    return undefined;\n  }\n}\n\nexport function toFormModelResponse(response: GetCustomModelResponse): FormModelResponse {\n  return {\n    status: response.modelInfo.status,\n    modelId: response.modelInfo.modelId,\n    modelName: response.modelInfo.modelName,\n    trainingStartedOn: response.modelInfo.trainingStartedOn,\n    trainingCompletedOn: response.modelInfo.trainingCompletedOn,\n    trainingDocuments: flattenTrainingDocuments(response),\n    properties: toCustomFormModelProperties(response.modelInfo.attributes),\n    errors: response.trainResult?.errors,\n    submodels: flattenCustomFormSubmodels(response),\n    _response: response._response\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  GeneratedClientGetAnalyzeFormResultResponse,\n  OperationStatus\n} from \"../../generated/models\";\nimport { RecognizedFormArray } from \"../../models\";\nimport { toRecognizedFormArray } from \"../../transforms\";\n\n/**\n * Options for Form Recognition shared between prebuilt and custom models.\n */\nexport interface FormPollerOperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  updateIntervalInMs?: number;\n\n  /**\n   * Callback that will receive events related to the progress of the\n   * form recognition operation.\n   */\n  onProgress?: (state: RecognizeFormsOperationState) => void;\n\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Encapsulates the steps to start and query the status of\n * a form recognition operation\n */\nexport interface FormRecognitionOperationClient {\n  /**\n   * Creates the analysis operation on the service\n   */\n  createOperation(): Promise<string>;\n  /**\n   * Returns the results of the operation\n   */\n  getResult(\n    operationId: string,\n    modelId?: string\n  ): Promise<GeneratedClientGetAnalyzeFormResultResponse>;\n}\n\n/**\n * The status of a form recognition operation\n */\nexport interface RecognizeFormsOperationState extends PollOperationState<RecognizedFormArray> {\n  /**\n   * Identifier for the recognition operation.\n   */\n  modelId?: string;\n  /**\n   * Expected document type from recognition.\n   */\n  expectedDocType?: string;\n  /**\n   * Identifier for the recognition operation\n   */\n  resultId?: string;\n  /**\n   * Last-known status of the recognition operation\n   */\n  status: OperationStatus;\n}\n\n/**\n * Create a form recognition poll operation.\n *\n * This operation handles the creation, polling, and transformation of results.\n *\n * @internal\n */\nfunction makeFormRecognitionOperation(\n  description: FormPollerOperationDescription,\n  initialState: RecognizeFormsOperationState\n): PollOperation<typeof initialState, RecognizedFormArray> {\n  const self: PollOperation<typeof initialState, RecognizedFormArray> = {\n    state: { ...initialState },\n    async cancel() {\n      throw new Error(\"The cancel operation is not supported on this poller.\");\n    },\n    async update(options) {\n      const { isStarted, isCompleted, modelId, expectedDocType } = self.state;\n\n      if (!isStarted || !self.state.resultId) {\n        self.state.resultId = await description.createOperation();\n        self.state.isStarted = true;\n      }\n\n      const response = await description.getResult(self.state.resultId, modelId);\n      self.state.status = response.status;\n\n      if (!isCompleted) {\n        // eslint-disable-next-line no-unused-expressions\n        options?.fireProgress?.({ ...self.state });\n\n        if (response.status === \"succeeded\") {\n          self.state.result = toRecognizedFormArray(\n            response,\n            expectedDocType?.startsWith(\"prebuilt:\") ? expectedDocType : undefined\n          );\n          self.state.isCompleted = true;\n        } else if (response.status === \"failed\") {\n          throw new Error(\n            [\n              `Failed to recognize forms using the model \"${description.modelId}\"`,\n              \"Error(s):\",\n              ...(response.analyzeResult?.errors?.map(\n                (e) => `  Code ${e.code}, message: '${e.message}'`\n              ) ?? [\"  <empty>\"])\n            ].join(\"\\n\")\n          );\n        }\n      }\n      return self;\n    },\n    // Maintaining the depth of \"state\" in the serialized poller is\n    // important for maintaining compatibility with previous versions\n    toString: () => JSON.stringify({ state: self.state })\n  };\n\n  return self;\n}\n\n/**\n * Set of intrinsic properties that describe a form recognition polling operation.\n */\nexport type FormPollerOperationDescription = FormPollerOperationOptions &\n  FormRecognitionOperationClient & {\n    /**\n     * The expected document type that should be used to validate recognition\n     * results.\n     */\n    expectedDocType?: string;\n    /**\n     * The model ID that should be used for this poller, if one is required.\n     */\n    modelId?: string;\n  };\n\nconst DEFAULT_POLLING_INTERVAL = 5000;\n\n/**\n * A poller for Form Recognition that works for all analysis endpoints\n * that return the basic, weakly-typed `RecognizedFormArray` type.\n */\nexport class FormRecognitionPoller extends Poller<\n  RecognizeFormsOperationState,\n  RecognizedFormArray\n> {\n  private options: FormPollerOperationOptions;\n\n  constructor(description: FormPollerOperationDescription) {\n    const state: RecognizeFormsOperationState = description.resumeFrom\n      ? JSON.parse(description.resumeFrom).state\n      : {\n          modelId: description.modelId,\n          status: \"notStarted\",\n          expectedDocType: description.expectedDocType\n        };\n\n    super(makeFormRecognitionOperation(description, state));\n\n    if (typeof description.onProgress === \"function\") {\n      this.onProgress(description.onProgress);\n    }\n\n    this.options = description;\n  }\n\n  /**\n   * Delay the poller\n   */\n  public delay(): Promise<void> {\n    return delay(this.options.updateIntervalInMs ?? DEFAULT_POLLING_INTERVAL);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n  BaseRequestPolicy,\n  HttpOperationResponse,\n  RequestPolicyOptionsLike,\n  WebResourceLike\n} from \"@azure/core-http\";\n\nconst API_KEY_HEADER_NAME = \"Ocp-Apim-Subscription-Key\";\n\n/**\n * Create an HTTP pipeline policy to authenticate a request\n * using an `AzureKeyCredential` for Azure Form Recognizer\n */\nexport function createFormRecognizerAzureKeyCredentialPolicy(\n  credential: KeyCredential\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new FormRecognizerAzureKeyCredentialPolicy(nextPolicy, options, credential);\n    }\n  };\n}\n\n/**\n * A concrete implementation of an AzureKeyCredential policy\n * using the appropriate header for Azure Form Recognizer\n */\nclass FormRecognizerAzureKeyCredentialPolicy extends BaseRequestPolicy {\n  private credential: KeyCredential;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike,\n    credential: KeyCredential\n  ) {\n    super(nextPolicy, options);\n    this.credential = credential;\n  }\n\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createPipelineFromOptions,\n  InternalPipelineOptions,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  operationOptionsToRequestOptionsBase,\n  OperationOptions\n} from \"@azure/core-http\";\nimport { TokenCredential, KeyCredential } from \"@azure/core-auth\";\nimport {\n  SDK_VERSION,\n  DEFAULT_COGNITIVE_SCOPE,\n  FormRecognizerLoggingAllowedHeaderNames,\n  FormRecognizerLoggingAllowedQueryParameters\n} from \"./constants\";\nimport { logger } from \"./logger\";\nimport { createSpan } from \"./tracing\";\nimport {\n  FormContentType,\n  FormRecognizerClientOptions,\n  FormRecognizerOperationOptions,\n  toRequestBody,\n  getContentType\n} from \"./common\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\n\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport {\n  GeneratedClientAnalyzeLayoutAsyncResponse as AnalyzeLayoutAsyncResponseModel,\n  SourcePath,\n  OperationStatus,\n  FormReadingOrder\n} from \"./generated/models\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport {\n  RecognizeContentPollerClient,\n  BeginRecognizeContentPoller\n} from \"./lro/analyze/contentPoller\";\nimport {\n  RecognizeFormsOperationState,\n  FormRecognitionPoller\n} from \"./lro/analyze/recognitionPoller\";\nimport { FormRecognizerRequestBody, RecognizedFormArray, FormPageArray } from \"./models\";\nimport { RecognizeContentResultResponse } from \"./internalModels\";\nimport { toRecognizeContentResultResponse } from \"./transforms\";\nimport { createFormRecognizerAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\n\n// #region types\n\n/**\n * Options for content/layout recognition.\n */\nexport type RecognizeContentOptions = FormRecognizerOperationOptions;\n\n/**\n * The state of a recognize content operation\n */\nexport type RecognizeContentOperationState = PollOperationState<FormPageArray> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: OperationStatus;\n};\n\n/**\n * Options for the start content/layout recognition operation\n */\nexport type BeginRecognizeContentOptions = RecognizeContentOptions & {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the content recognition Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeContentOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Content type of the input. Supported types are \"application/pdf\",\n   * \"image/jpeg\", \"image/png\", \"image/tiff\", and \"image/bmp\".\n   */\n  contentType?: FormContentType;\n  /**\n   * The BCP-47 language code of the text in the document.\n   *\n   * See the `KnownFormLanguage` type for a list of known languages that the\n   * service supports.\n   *\n   * Handwritten text is only supported in English ('en').\n   *\n   * Content recognition supports auto language identification and multi\n   * language documents, so only provide a language code if you would like to\n   * override the service's default behavior and force the document to be\n   * processed using a specific language.\n   *\n   * @see KnownFormLanguage\n   */\n  language?: string;\n  /**\n   * The reading order algorithm to use when analyzing the page and sorting\n   * the output text lines. Possible values include \"basic\" (default) and\n   * \"natural\".\n   *\n   * The \"basic\" reading order uses a strict top-to-bottom, left-to-right\n   * reading order.\n   *\n   * The \"natural\" reading order uses positional information and heuristics to\n   * keep nearby lines together.\n   */\n  readingOrder?: FormReadingOrder;\n  /**\n   * Custom page numbers for multi-page documents(PDF/TIFF). If a value is\n   * provided, content information will only be provided for the selected\n   * pages. A range of pages may be denoted using a hyphen.\n   *\n   * For example, to select pages 1, 3 and 5 through 9, set this property to\n   * `[\"1\", \"3\", \"5-9\"]`.\n   */\n  pages?: string[];\n};\n\n/**\n * The Long-Running-Operation (LRO) poller that allows you to wait until form content is recognized.\n */\nexport type ContentPollerLike = PollerLike<PollOperationState<FormPageArray>, FormPageArray>;\n\n/**\n * Options for retrieving recognized content data\n */\ntype GetRecognizedContentResultOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for recognition of forms\n */\nexport interface RecognizeFormsOptions extends FormRecognizerOperationOptions {\n  /**\n   * Specifies whether to include text lines and element references in the result\n   */\n  includeFieldElements?: boolean;\n}\n\n/**\n * Shared options for starting form recognition operations.\n */\nexport interface BeginRecognizeFormsOptions extends RecognizeFormsOptions {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the Recognize Form Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeFormsOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Custom page numbers for multi-page documents(PDF/TIFF). If a value is\n   * provided, content information will only be provided for the selected\n   * pages. A range of pages may be denoted using a hyphen.\n   *\n   * For example, to select pages 1, 3 and 5 through 9, set this property to\n   * `[\"1\", \"3\", \"5-9\"]`.\n   */\n  pages?: string[];\n  /**\n   * Content type of the input. Supported types are \"application/pdf\",\n   * \"image/jpeg\", \"image/png\", \"image/tiff\", and \"image/bmp\".\n   */\n  contentType?: FormContentType;\n}\n\n/**\n * Options for starting the custom form recognition operation.\n */\nexport interface BeginRecognizeCustomFormsOptions extends BeginRecognizeFormsOptions {}\n\n/**\n * Result type of the Recognize Form Long-Running-Operation (LRO)\n */\nexport type FormPollerLike = PollerLike<RecognizeFormsOperationState, RecognizedFormArray>;\n\n/**\n * Options for starting a recognition operation using a prebuilt model.\n */\nexport interface BeginRecognizePrebuiltOptions extends BeginRecognizeFormsOptions {\n  /**\n   * Locale of the document.\n   *\n   * Supported locales include:\n   * - \"en-AU\"\n   * - \"en-CA\"\n   * - \"en-GB\"\n   * - \"en-IN\"\n   * - \"en-US\" (default if none provided)\n   *\n   * @see KnownFormLocale\n   */\n  locale?: string;\n}\n\n/**\n * Options for starting the receipt recognition operation\n */\nexport type BeginRecognizeReceiptsOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the Business Card recognition operation\n */\nexport type BeginRecognizeBusinessCardsOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the Invoice recognition operation\n */\nexport type BeginRecognizeInvoicesOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the ID document recognition operation\n */\nexport type BeginRecognizeIdentityDocumentsOptions = BeginRecognizePrebuiltOptions;\n\n// #endregion\n\n/**\n * Client class for interacting with the Azure Form Recognizer service.\n */\nexport class FormRecognizerClient {\n  /**\n   * URL to an Azure Form Recognizer service endpoint\n   */\n  public readonly endpointUrl: string;\n\n  /**\n   * @internal\n   * A reference to the auto-generated FormRecognizer HTTP client.\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of FormRecognizerClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { FormRecognizerClient, AzureKeyCredential } from \"@azure/ai-form-recognizer\";\n   *\n   * const client = new FormRecognizerClient(\n   *    \"<service endpoint>\",\n   *    new AzureKeyCredential(\"<api key>\")\n   * );\n   * ```\n   *\n   * @param endpointUrl - Url to an Azure Form Recognizer service endpoint\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Form Recognizer client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: FormRecognizerClientOptions = {}\n  ) {\n    this.endpointUrl = endpointUrl;\n    const { ...pipelineOptions } = options;\n\n    const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;\n    if (!pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions = {};\n    }\n    if (pipelineOptions.userAgentOptions.userAgentPrefix) {\n      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;\n    } else {\n      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;\n    }\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)\n      : createFormRecognizerAzureKeyCredentialPolicy(credential);\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,\n          allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n\n    this.client = new GeneratedClient(this.endpointUrl, pipeline);\n  }\n\n  // #region content\n\n  /**\n   * Recognizes content, including text and table structure from a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_7.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContent(readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   * Recognizes content/layout information from a given document\n   * @param form - Input document\n   * @param options - Options to start content recognition operation\n   */\n  public async beginRecognizeContent(\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const client: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    const poller = new BeginRecognizeContentPoller({\n      client,\n      source: form,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes content, including text and table structure from a url to a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContentFromUrl(url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes content/layout information from a url to a form document\n   * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the content recognition operation\n   */\n  public async beginRecognizeContentFromUrl(\n    formUrl: string,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const client: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const poller = new BeginRecognizeContentPoller({\n      client,\n      source: formUrl,\n      ...options,\n      contentType: undefined\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Retrieves result of content recognition operation.\n   * @internal\n   */\n  private async getRecognizedContent(\n    resultId: string,\n    options?: GetRecognizedContentResultOptions\n  ): Promise<RecognizeContentResultResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormRecognizerClient-getRecognizedLayoutResult\",\n      realOptions\n    );\n\n    try {\n      const requestOptions = operationOptionsToRequestOptionsBase(finalOptions);\n      const analyzeResult = await this.client.getAnalyzeLayoutResult(resultId, requestOptions);\n      return toRecognizeContentResultResponse(analyzeResult);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // #endregion\n\n  // #region customforms\n\n  /**\n   * Recognizes forms from a given document using a custom form model from training.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_6.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomForms(modelId, readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   * Recognizes form information from a given document using a custom form model.\n   * @param modelId - Id of the custom form model to use\n   * @param form - Input form document\n   * @param options - Options to start the form recognition operation\n   */\n  public async beginRecognizeCustomForms(\n    modelId: string,\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeCustomFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid model id\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeCustomForms\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      modelId,\n      createOperation: span(\"customFormsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(form);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeWithCustomModel(\n            modelId,\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getCustomForms\", async (finalOptions, resultId, modelIdParam) =>\n        // using the modelId from the parameter here is important, as we could be restoring from\n        // a suspended LRO\n        this.client.getAnalyzeFormResult(\n          // Must be defined to have reached this point, but only for custom form recognition\n          modelIdParam!,\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes forms from a URL to a document using a custom form model from training.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes form information from a url to a document using a custom form model.\n   * @param modelId - Id of the custom form model to use\n   * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeCustomFormsFromUrl(\n    modelId: string,\n    formUrl: string,\n    options: BeginRecognizeCustomFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid model id\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeCustomForms\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      modelId,\n      createOperation: span(\"customFormsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeWithCustomModel(modelId, \"application/json\", {\n            fileStream: {\n              source: formUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getCustomForms\", async (finalOptions, resultId, modelIdParam) =>\n        // using the modelId from the parameter here is important, as we could be restoring from\n        // a suspended LRO\n        this.client.getAnalyzeFormResult(\n          // Must be defined to have reached this point, but only for custom form recognition\n          modelIdParam!,\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::businesscard\n\n  /**\n   * Recognizes data from business cards using a pre-built business card model, enabling you to extract structured data\n   * from business cards such as name, job title, phone numbers, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the\n   * following link: https://aka.ms/formrecognizer/businesscardfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./business-card-english.png\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeBusinessCards(readStream, {\n   *   contentType: \"image/png\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [businessCard] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes business card information from a given document\n   * @param businessCard - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeBusinessCards(\n    businessCard: FormRecognizerRequestBody,\n    options: BeginRecognizeBusinessCardsOptions = { includeFieldElements: false }\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeBusinessCards\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:businesscard\",\n      createOperation: span(\"businessCardsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(businessCard);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeBusinessCardAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getBusinessCards\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeBusinessCardResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes business card information from a url using a pre-built business card model, enabling you to extract structured data\n   * from business cards such as name, job title, phone numbers, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/businesscardfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the business card document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeBusinessCardsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [businessCard] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes business card information from a given accessible url to a document\n   * @param businessCardUrl - Url to a business card document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeBusinessCardsFromUrl(\n    businessCardUrl: string,\n    options: BeginRecognizeBusinessCardsOptions = { includeFieldElements: false }\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeBusinessCardsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:businesscard\",\n      createOperation: span(\"businessCardsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeBusinessCardAsync(\"application/json\", {\n            fileStream: {\n              source: businessCardUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getBusinessCards\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeBusinessCardResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::invoice\n\n  /**\n   * Recognizes data from invoices using a pre-built invoice model, enabling you to extract structured data\n   * from invoices such as customer address, vendor address, purchase order ID, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_1.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeInvoices(readStream, {\n   *   contentType: \"application/pdf\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [invoice] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes invoice information from a given document\n   * @param invoice - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeInvoices(\n    invoice: FormRecognizerRequestBody,\n    options: BeginRecognizeInvoicesOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeInvoices\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:invoice\",\n      createOperation: span(\"invoicesInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(invoice);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeInvoiceAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getInvoices\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeInvoiceResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes invoice information from a URL using a pre-built invoice model, enabling you to extract structured data\n   * from invoices such as customer address, vendor address, purchase order ID, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the invoice document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeInvoicesFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [invoice] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes invoice information from a given accessible url to a document\n   * @param invoiceUrl - Url to an invoice document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeInvoicesFromUrl(\n    invoiceUrl: string,\n    options: BeginRecognizeInvoicesOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeInvoicesFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:invoice\",\n      createOperation: span(\"invoicesInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeInvoiceAsync(\"application/json\", {\n            fileStream: {\n              source: invoiceUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getInvoices\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeInvoiceResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::identityDocument\n\n  /**\n   * Recognizes data from identification documents using a pre-built ID\n   * document model, enabling you to extract structured data from ID documents\n   * such as first/last name, document number, expiration date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to\n   * the documentation at the following link:\n   * https://aka.ms/formrecognizer/iddocumentfields\n   *\n   * This method returns a long running operation poller that allows you to\n   * wait indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation\n   * completes in the first request, and attempting to cancel a completed copy\n   * will result in an error being thrown.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * const path = \"./license.jpg\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeIdentityDocuments(readStream, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [identityDocument] = await poller.pollUntilDone();\n   * ```\n   *\n   * @param identityDocument - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeIdentityDocuments(\n    identityDocument: FormRecognizerRequestBody,\n    options: BeginRecognizeIdentityDocumentsOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeIdentityDocuments\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:idDocument\",\n      createOperation: span(\"identityDocumentsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(identityDocument);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeIdDocumentAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getIdentityDocuments\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeIdDocumentResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes identity document information from a url using pre-built ID\n   * document model, enabling you to extract structured data from ID documents\n   * such as first/last name, document number, expiration date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to\n   * the documentation at the following link:\n   * https://aka.ms/formrecognizer/iddocumentfields\n   *\n   * This method returns a long running operation poller that allows you to\n   * wait indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation\n   * completes in the first request, and attempting to cancel a completed copy\n   * will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the identity document>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeIdentityDocumentsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   *\n   * const [identityDocument] = await poller.pollUntilDone();\n   * ```\n   *\n   * @param identityDocumentUrl - Url to an identity document that is accessible from\n   * the service. Must be a valid, encoded URL to a document of a supported\n   * content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeIdentityDocumentsFromUrl(\n    identityDocumentUrl: string,\n    options: BeginRecognizeIdentityDocumentsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeIdentityDocumentsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:idDocument\",\n      createOperation: span(\"identityDocumentsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeIdDocumentAsync(\"application/json\", {\n            fileStream: {\n              source: identityDocumentUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getIdDocuments\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeIdDocumentResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::receipt\n\n  /**\n   * Recognizes data from receipts using a pre-built receipt model, enabling you to extract structured data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./contoso-allinone.jpg\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceipts(readStream, {\n   *   contentType: \"image/jpeg\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [receipt] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes receipt information from a given document\n   * @param receipt - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeReceipts(\n    receipt: FormRecognizerRequestBody,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeReceipts\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:receipt\",\n      createOperation: span(\"receiptsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(receipt);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeReceiptAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getReceipts\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeReceiptResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the\n   * following link: https://aka.ms/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the receipt document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceiptsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [receipt] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes receipt information from a given accessible url to a document\n   * @param receiptUrl - Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeReceiptsFromUrl(\n    receiptUrl: string,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeReceiptsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:receipt\",\n      createOperation: span(\"receiptsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeReceiptAsync(\"application/json\", {\n            fileStream: {\n              source: receiptUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getReceipts\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeReceiptResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n}\n\n/**\n * An operation that can be queried.\n *\n * @internal\n */\ninterface RemoteOperation {\n  operationLocation?: string;\n}\n\n/**\n * Validates a remote operation's location is defined and extracts the\n * result ID from it.\n *\n * @param remoteOperation - The operation to process\n * @returns The remote operation ID\n *\n * @internal\n */\nfunction processOperationLocation({ operationLocation }: RemoteOperation): string {\n  if (!operationLocation) {\n    throw new Error(\"The service did not respond with an 'operationLocation' to retrieve results.\");\n  } else {\n    const lastSlashIndex = operationLocation.lastIndexOf(\"/\");\n    return operationLocation.substring(lastSlashIndex + 1);\n  }\n}\n\n/**\n * Type of the auto-spanner returned by `makeSpanner`\n *\n * @internal\n */\ninterface Spanner<Options> {\n  /**\n   * Invokes a handler in the context of a span. When the handler is called,\n   * an argument will be inserted at the beginning of the arguments list\n   * containing the `options` that may have been updated by the tracer.\n   *\n   * @param name - The name of this span, which will appear in the trace.\n   * @param handler - The handler to run. Its first parameter will have the\n   *   type of `options` that were passed to `makeSpanner`\n   *\n   * @returns A function that will wrap a call to the `handler` in tracing code, forwarding its parameters\n   */\n  span<Args extends unknown[], Result>(\n    name: string,\n    handler: (updatedOptions: Options, ...rest: Args) => Result\n  ): (...args: Args) => Result;\n}\n\n/**\n * Helper function to create spans for internal polling handlers\n *\n * The argument is a handler function that will be wrapped in a tracing\n * span, where tracing-updated options will be inserted as its first parameter.\n *\n * @example\n * ```typescript\n * const spanned = makeSpanner(\"FormRecognizerClient-beginRecognizeReceipts\", {\n *   ...options,\n *   // Override any options you need here\n * });\n *\n * const autoSpannedFunction = spanner(\"autoSpannedFunction\", (updatedOptions) => {\n *  // ...\n * });\n * ```\n *\n * @internal\n */\nfunction makeSpanner<Options extends OperationOptions>(\n  prefix: string,\n  options: Options\n): Spanner<Options> {\n  return {\n    span: (name, handler) => (...args) => {\n      const { span, updatedOptions } = createSpan(`${prefix}-${name}`, options);\n\n      try {\n        return handler(updatedOptions, ...args);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    }\n  };\n}\n\n/**\n * The worker function of layout analysis.\n *\n * @internal\n */\nasync function recognizeLayoutInternal(\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  client: GeneratedClient,\n  body: FormRecognizerRequestBody | string,\n  contentType?: FormContentType,\n  options?: RecognizeContentOptions,\n  _modelId?: string\n): Promise<AnalyzeLayoutAsyncResponseModel> {\n  const realOptions = options || {};\n  const { span, updatedOptions: finalOptions } = createSpan(\"analyzeLayoutInternal\", realOptions);\n  const requestBody = await toRequestBody(body);\n  const requestContentType = contentType ? contentType : await getContentType(requestBody);\n\n  try {\n    if (requestContentType) {\n      return await client.analyzeLayoutAsync(\n        requestContentType,\n        requestBody as Blob | ArrayBuffer | ArrayBufferView,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    }\n    return await client.analyzeLayoutAsync(\"application/json\", {\n      fileStream: requestBody as SourcePath,\n      ...operationOptionsToRequestOptionsBase(finalOptions)\n    });\n  } catch (e) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { TrainingFileFilter, GetModelOptions } from \"../../formTrainingClient\";\n\nimport {\n  ModelStatus,\n  GeneratedClientTrainCustomModelAsyncResponse as TrainCustomModelAsyncResponse\n} from \"../../generated/models\";\nimport { CustomFormModel, FormModelResponse } from \"../../models\";\nexport { ModelStatus, TrainCustomModelAsyncResponse };\n\n/**\n * Defines the operations from a {@link FormRecognizerClient} that are needed for the poller\n * returned by {@link FormRecognizerClient.beginTraining} to work.\n */\nexport type TrainPollerClient = {\n  getCustomModel: (modelId: string, options: GetModelOptions) => Promise<FormModelResponse>;\n  trainCustomModelInternal: (\n    source: string | string[],\n    useLabelFile?: boolean,\n    options?: TrainingFileFilter\n  ) => Promise<TrainCustomModelAsyncResponse>;\n};\n\n/**\n * The state used by the poller returned from {@link FormTrainingClient.beginTraining}.\n *\n * This state is passed into the user-specified `onProgress` callback\n * whenever copy progress is detected.\n */\nexport interface BeginTrainingPollState extends PollOperationState<CustomFormModel> {\n  /**\n   * The accessible url to an Azure Blob Storage container holding the training documents.\n   */\n  trainingInputs: string | string[];\n  /**\n   * The id of the custom form model being created from the training operation.\n   */\n  modelId?: string;\n  /**\n   * the status of the created model.\n   */\n  status: ModelStatus;\n  /**\n   * Option to filter training files.\n   */\n  readonly trainModelOptions?: TrainingFileFilter;\n}\n\nexport interface BeginTrainingPollerOperation\n  extends PollOperation<BeginTrainingPollState, CustomFormModel> {}\n\n/**\n * @internal\n */\nexport interface BeginTrainingPollerOptions {\n  client: TrainPollerClient;\n  trainingInputs: string | string[];\n  updateIntervalInMs?: number;\n  onProgress?: (state: BeginTrainingPollState) => void;\n  resumeFrom?: string;\n  trainModelOptions?: TrainingFileFilter;\n}\n\n/**\n * Class that represents a poller that waits until a model has been trained.\n */\nexport class BeginTrainingPoller extends Poller<BeginTrainingPollState, CustomFormModel> {\n  public updateIntervalInMs: number;\n\n  constructor(options: BeginTrainingPollerOptions) {\n    const {\n      client,\n      trainingInputs,\n      updateIntervalInMs = 5000,\n      onProgress,\n      resumeFrom,\n      trainModelOptions\n    } = options;\n\n    let state: BeginTrainingPollState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeBeginTrainingPollOperation(client, {\n      ...state,\n      trainingInputs,\n      status: \"creating\",\n      trainModelOptions\n    });\n\n    super(operation);\n\n    if (typeof onProgress === \"function\") {\n      this.onProgress(onProgress);\n    }\n\n    this.updateIntervalInMs = updateIntervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n\n/**\n * Creates a poll operation given the provided state.\n * @internal\n */\nfunction makeBeginTrainingPollOperation(\n  client: TrainPollerClient,\n  state: BeginTrainingPollState\n): BeginTrainingPollerOperation {\n  return {\n    state: { ...state },\n\n    async cancel(_options = {}): Promise<BeginTrainingPollerOperation> {\n      throw new Error(\"Cancel operation is not supported.\");\n    },\n\n    async update(options = {}): Promise<BeginTrainingPollerOperation> {\n      const pollerState = this.state;\n      const { trainingInputs, trainModelOptions } = state;\n\n      if (!pollerState.isStarted) {\n        pollerState.isStarted = true;\n        const result = await client.trainCustomModelInternal(\n          trainingInputs,\n          false,\n          trainModelOptions || {}\n        );\n        if (!result.location) {\n          throw new Error(\"Expect a valid 'operationLocation' to retrieve analyze results\");\n        }\n        const lastSlashIndex = result.location.lastIndexOf(\"/\");\n        pollerState.modelId = result.location.substring(lastSlashIndex + 1);\n      }\n\n      const model = await client.getCustomModel(pollerState.modelId!, {\n        abortSignal: trainModelOptions?.abortSignal\n      });\n\n      pollerState.status = model.status;\n\n      if (!pollerState.isCompleted) {\n        if (typeof options.fireProgress === \"function\") {\n          options.fireProgress(pollerState);\n        }\n\n        if (model.status === \"ready\") {\n          pollerState.result = model;\n          pollerState.isCompleted = true;\n        } else if (model.status === \"invalid\") {\n          const errors = model.errors\n            ?.map((e) => `  code ${e.code}, message: '${e.message}'`)\n            .join(\"\\n\");\n          const additionalInfo = model.trainingDocuments\n            ?.map(\n              (d) =>\n                `  document: ${d.name}, status: ${d.status}, errors: ${d.errors\n                  ?.map((e) => `code ${e.code}, message: '${e.message}'`)\n                  .join(\"\\n\")}`\n            )\n            .join(\"\\n\");\n          const message = `Model training failed. Invalid model was created with id '${\n            pollerState.modelId\n          }'.\nError(s):\n${errors || \"\"}\nAdditional information:\n${additionalInfo || \"\"}\n`;\n          throw new Error(message);\n        }\n      }\n\n      return makeBeginTrainingPollOperation(client, pollerState);\n    },\n\n    toString() {\n      return JSON.stringify({ state: this.state }, (key, value) => {\n        if (key === \"client\") {\n          return undefined;\n        }\n        return value;\n      });\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { CopyModelOptions, GetCopyModelResultOptions } from \"../../formTrainingClient\";\n\nimport {\n  GeneratedClientGetCustomModelCopyResultResponse as GetCustomModelCopyResultResponse,\n  GeneratedClientCopyCustomModelResponse as CopyCustomModelResponseModel,\n  OperationStatus\n} from \"../../generated/models\";\nimport { CopyAuthorization, CustomFormModelInfo } from \"../../models\";\nexport { OperationStatus };\n\nexport interface CopyPollerOperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  updateIntervalInMs?: number;\n  /**\n   * callback to receive events on the progress of download operation.\n   */\n  onProgress?: (state: BeginCopyModelPollState) => void;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Defines the operations from a training client that are needed for the poller\n * to work\n */\nexport type CopyModelPollerClient = {\n  // returns a result id to retrieve results\n  beginCopyModel: (\n    modelId: string,\n    copyAuthorization: CopyAuthorization,\n    copyModelOptions?: CopyModelOptions\n  ) => Promise<CopyCustomModelResponseModel>;\n  // retrieves copy model result\n  getCopyModelResult: (\n    modelId: string,\n    resultId: string,\n    options: GetCopyModelResultOptions\n  ) => Promise<GetCustomModelCopyResultResponse>;\n};\n\n/**\n * The state used by the poller returned from {@link FormTrainingClient.beginCopyModel}.\n *\n * This state is passed into the user-specified `onProgress` callback\n * whenever copy progress is detected.\n */\nexport interface BeginCopyModelPollState extends PollOperationState<CustomFormModelInfo> {\n  /**\n   * The instance of {@link CopyModelPollerClient} that is used when calling {@link FormTrainingClient.beginCopyModel}.\n   */\n  readonly client: CopyModelPollerClient;\n  /**\n   * Id of the model being copied\n   */\n  modelId: string;\n  /**\n   * Id of the target Form Recognizer resource\n   */\n  targetResourceId: string;\n  /**\n   * Region of the target Form Recognizer resource\n   */\n  targetResourceRegion: string;\n  /**\n   * The copy authorization generated by the target Form Recognizer resource.\n   */\n  copyAuthorization: CopyAuthorization;\n  /**\n   * Id of the copy model operation result.\n   */\n  resultId?: string;\n  /**\n   * Status of the copy model operation.\n   */\n  status: OperationStatus;\n  /**\n   * Option to the copy model operation.\n   */\n  readonly copyModelOptions?: CopyModelOptions;\n}\n\nexport interface BeginCopyModelPollerOperation\n  extends PollOperation<BeginCopyModelPollState, CustomFormModelInfo> {}\n\n/**\n * @internal\n */\nexport type BeginCopyModelPollerOptions = {\n  client: CopyModelPollerClient;\n  modelId: string;\n  targetResourceId: string;\n  targetResourceRegion: string;\n  copyAuthorization: CopyAuthorization;\n  updateIntervalInMs?: number;\n  resultId?: string;\n  onProgress?: (state: BeginCopyModelPollState) => void;\n  resumeFrom?: string;\n} & CopyModelOptions;\n\n/**\n * Class that represents a poller that waits until a model has been trained.\n */\nexport class BeginCopyModelPoller extends Poller<BeginCopyModelPollState, CustomFormModelInfo> {\n  public updateIntervalInMs: number;\n\n  constructor(options: BeginCopyModelPollerOptions) {\n    const {\n      client,\n      updateIntervalInMs = 5000,\n      modelId,\n      resultId,\n      targetResourceId,\n      targetResourceRegion,\n      copyAuthorization,\n      onProgress,\n      resumeFrom\n    } = options;\n\n    let state: BeginCopyModelPollState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeBeginCopyModelPollOperation({\n      ...state,\n      client,\n      modelId,\n      targetResourceId,\n      targetResourceRegion,\n      copyAuthorization,\n      resultId,\n      status: \"notStarted\",\n      copyModelOptions: options\n    });\n\n    super(operation);\n\n    if (typeof onProgress === \"function\") {\n      this.onProgress(onProgress);\n    }\n\n    this.updateIntervalInMs = updateIntervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n/**\n * Creates a poll operation given the provided state.\n * @internal\n */\nfunction makeBeginCopyModelPollOperation(\n  state: BeginCopyModelPollState\n): BeginCopyModelPollerOperation {\n  return {\n    state: { ...state },\n\n    async cancel(_options = {}): Promise<BeginCopyModelPollerOperation> {\n      throw new Error(\"Cancel operation is not supported.\");\n    },\n\n    async update(options = {}): Promise<BeginCopyModelPollerOperation> {\n      const pollerState = this.state;\n      const { client, modelId, copyAuthorization, copyModelOptions } = pollerState;\n\n      if (!pollerState.isStarted) {\n        pollerState.isStarted = true;\n        const result = await client.beginCopyModel(\n          modelId,\n          copyAuthorization,\n          copyModelOptions || {}\n        );\n        if (!result.operationLocation) {\n          throw new Error(\"Expect a valid 'operationLocation' to retrieve analyze results\");\n        }\n        const lastSlashIndex = result.operationLocation.lastIndexOf(\"/\");\n        pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);\n      }\n\n      const response = await client.getCopyModelResult(modelId, pollerState.resultId!, {\n        abortSignal: copyModelOptions?.abortSignal\n      });\n\n      pollerState.status = response.status;\n      if (!pollerState.isCompleted) {\n        if (\n          (response.status === \"running\" || response.status === \"notStarted\") &&\n          typeof options.fireProgress === \"function\"\n        ) {\n          options.fireProgress(pollerState);\n        } else if (response.status === \"succeeded\") {\n          pollerState.result = {\n            status: \"ready\",\n            trainingStartedOn: response.createdOn,\n            trainingCompletedOn: response.lastModified,\n            modelId: copyAuthorization.modelId\n          };\n          pollerState.isCompleted = true;\n        } else if (response.status === \"failed\") {\n          throw new Error(`Copy model operation failed: ${response._response.bodyAsText}`);\n        }\n      }\n\n      return makeBeginCopyModelPollOperation(pollerState);\n    },\n\n    toString() {\n      return JSON.stringify({ state: this.state }, (key, value) => {\n        if (key === \"client\" || key === \"source\") {\n          return undefined;\n        }\n        return value;\n      });\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  createPipelineFromOptions,\n  InternalPipelineOptions,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  operationOptionsToRequestOptionsBase,\n  RestResponse\n} from \"@azure/core-http\";\nimport { TokenCredential, KeyCredential } from \"@azure/core-auth\";\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport \"@azure/core-paging\";\nimport {\n  SDK_VERSION,\n  DEFAULT_COGNITIVE_SCOPE,\n  FormRecognizerLoggingAllowedHeaderNames,\n  FormRecognizerLoggingAllowedQueryParameters\n} from \"./constants\";\nimport { logger } from \"./logger\";\nimport { createSpan } from \"./tracing\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport {\n  GeneratedClientGetCustomModelCopyResultResponse as GetCustomModelCopyResultResponseModel,\n  GeneratedClientCopyCustomModelResponse as CopyCustomModelResponseModel,\n  GeneratedClientTrainCustomModelAsyncResponse,\n  CopyAuthorizationResult,\n  GeneratedClientComposeCustomModelsAsyncResponse\n} from \"./generated/models\";\nimport { TrainPollerClient, BeginTrainingPoller } from \"./lro/train/poller\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport { FormRecognizerClientOptions, FormRecognizerOperationOptions } from \"./common\";\nimport {\n  FormModelResponse,\n  AccountProperties,\n  CustomFormModel,\n  CustomFormModelInfo,\n  CopyAuthorization,\n  ListCustomModelsResponse,\n  OperationStatus,\n  ModelStatus\n} from \"./models\";\nimport { createFormRecognizerAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\nimport { toFormModelResponse } from \"./transforms\";\nimport { CopyModelPollerClient, BeginCopyModelPoller } from \"./lro/copy/poller\";\nimport { FormRecognizerClient } from \"./formRecognizerClient\";\n\nexport { RestResponse };\n\n/**\n * Options for model listing operation.\n */\nexport type ListModelsOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the get account properties operation.\n */\nexport type GetAccountPropertiesOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the delete model operation.\n */\nexport type DeleteModelOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the get model operation.\n */\nexport type GetModelOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the generate copy model authorization operation.\n */\nexport type GetCopyAuthorizationOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the copy custom model operation.\n */\nexport type CopyModelOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for the get copy model result operation.\n */\nexport type GetCopyModelResultOptions = FormRecognizerOperationOptions;\n\n/**\n * The status of a copy model operation\n */\nexport type CopyModelOperationState = PollOperationState<CustomFormModel> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: OperationStatus;\n};\n\n/**\n * Options for configuring long-running operations.\n */\nexport interface FormTrainingPollOperationOptions<TState extends PollOperationState<unknown>> {\n  /**\n   * Interval (in milliseconds) between requests for status updates on the operation.\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Progress handler. The Poller will call this handler with the operation state\n   * after polling.\n   */\n  onProgress?: (state: TState) => void;\n  /**\n   * State of a previously-serialized poller to resume an operation.\n   *\n   * The state can be obtained from a poller using `poller.toString()`.\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Options for begin copy model operation\n */\nexport type BeginCopyModelOptions = FormRecognizerOperationOptions &\n  FormTrainingPollOperationOptions<CopyModelOperationState>;\n\n/**\n * Options for training models\n */\nexport type TrainingFileFilter = FormRecognizerOperationOptions & {\n  prefix?: string;\n  includeSubfolders?: boolean;\n};\n\n/**\n * The status of a form training operation\n */\nexport type TrainingOperationState = PollOperationState<CustomFormModelInfo> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: ModelStatus;\n};\n\n/**\n * Options for starting model training operation.\n */\nexport type BeginTrainingOptions = TrainingFileFilter &\n  FormTrainingPollOperationOptions<TrainingOperationState> & {\n    /**\n     * An optional name to associate with the model\n     */\n    modelName?: string;\n  };\n\n/**\n * Options for creating a composed model from submodels.\n */\nexport type BeginCreateComposedModelOptions = FormRecognizerOperationOptions &\n  FormTrainingPollOperationOptions<TrainingOperationState> & {\n    /**\n     * An optional name to associate with the composed model.\n     *\n     * Individual models that are part of the composition will retain their original names.\n     */\n    modelName?: string;\n  };\n\n/**\n * Client class for training and managing custom form models.\n */\nexport class FormTrainingClient {\n  /**\n   * Url to an Azure Form Recognizer service endpoint\n   */\n  public readonly endpointUrl: string;\n\n  /**\n   * @internal\n   */\n  private readonly credential: TokenCredential | KeyCredential;\n\n  /**\n   * @internal\n   */\n  private readonly clientOptions: FormRecognizerClientOptions;\n\n  /**\n   * @internal\n   * A reference to the auto-generated FormRecognizer HTTP client.\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of FormTrainingClient.\n   *\n   * Example usage:\n   * ```ts\n   * import {FormTrainingClient, AzureKeyCredential } from \"@azure/ai-form-recognizer\";\n   *\n   * const client = new FormTrainingClient(\n   *    \"<service endpoint>\",\n   *    new AzureKeyCredential(\"<api key>\")\n   * );\n   * ```\n   * @param endpointUrl - Url to an Azure Form Recognizer service endpoint\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: FormRecognizerClientOptions = {}\n  ) {\n    this.endpointUrl = endpointUrl;\n    this.credential = credential;\n    this.clientOptions = options;\n    const { ...pipelineOptions } = options;\n\n    const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;\n    if (!pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions = {};\n    }\n    if (pipelineOptions.userAgentOptions.userAgentPrefix) {\n      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;\n    } else {\n      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;\n    }\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)\n      : createFormRecognizerAzureKeyCredentialPolicy(credential);\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,\n          allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n\n    this.client = new GeneratedClient(this.endpointUrl, pipeline);\n  }\n\n  /**\n   * Retrieves summary information about the cognitive service account\n   *\n   * @param options - Options to GetSummary operation\n   */\n  public async getAccountProperties(\n    options?: GetAccountPropertiesOptions\n  ): Promise<AccountProperties> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-listCustomModels\",\n      realOptions\n    );\n\n    try {\n      const result = await this.client.getCustomModels({\n        ...operationOptionsToRequestOptionsBase(finalOptions)\n      });\n\n      return {\n        customModelLimit: result.summary!.limit,\n        customModelCount: result.summary!.count\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates an instance of {@link FormTrainingClient} to perform training operations\n   * and to manage trained custom form models.\n   */\n  public getFormRecognizerClient(): FormRecognizerClient {\n    return new FormRecognizerClient(this.endpointUrl, this.credential, this.clientOptions);\n  }\n\n  /**\n   * Mark model for deletion. Model artifacts will be permanently removed within 48 hours.\n   *\n   * @param modelId - Id of the model to mark for deletion\n   * @param options - Options to the Delete Model operation\n   */\n  public async deleteModel(modelId: string, options?: DeleteModelOptions): Promise<RestResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-deleteModel\",\n      realOptions\n    );\n\n    try {\n      return await this.client.deleteCustomModel(\n        modelId,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Get detailed information about a custom model from training.\n   *\n   * @param modelId - Id of the model to get information\n   * @param options - Options to the Get Model operation\n   */\n  public async getCustomModel(\n    modelId: string,\n    options: GetModelOptions = {}\n  ): Promise<FormModelResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-getCustomModel\",\n      realOptions\n    );\n\n    try {\n      const response = await this.client.getCustomModel(modelId, {\n        ...operationOptionsToRequestOptionsBase(finalOptions),\n        // Include keys is always set to true -- the service does not have a use case for includeKeys: false.\n        includeKeys: true\n      });\n\n      return toFormModelResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listModelsPage(\n    settings: PageSettings,\n    options: ListModelsOptions = {}\n  ): AsyncIterableIterator<ListCustomModelsResponse> {\n    let result: ListCustomModelsResponse;\n    if (settings.continuationToken) {\n      result = await this.listNextPage(settings.continuationToken, options);\n    } else {\n      result = await this.list(options);\n    }\n    yield result;\n\n    while (result.nextLink) {\n      result = await this.listNextPage(result.nextLink, options);\n      yield result;\n    }\n  }\n\n  private async *listModelsAll(\n    settings: PageSettings,\n    options: ListModelsOptions = {}\n  ): AsyncIterableIterator<CustomFormModelInfo> {\n    for await (const page of this.listModelsPage(settings, options)) {\n      yield* page.modelList || [];\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list information about all models in the cognitive service account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * const client = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));\n   * const result = client.listCustomModels();\n   * let i = 1;\n   * for await (const model of result) {\n   *   console.log(`model ${i++}:`);\n   *   console.log(model);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = client.listCustomModels();\n   * let modelItem = await iter.next();\n   * while (!modelItem.done) {\n   *   console.log(`model ${i++}: ${modelItem.value}`);\n   *   modelItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   *  let i = 1;\n   *  for await (const response of client.listCustomModels().byPage()) {\n   *    for (const modelInfo of response.modelList!) {\n   *      console.log(`model ${i++}: ${modelInfo.modelId}`);\n   *    }\n   *  }\n   * ```\n   *\n   * @param options - Options to the List Models operation\n   */\n  public listCustomModels(\n    options: ListModelsOptions = {}\n  ): PagedAsyncIterableIterator<CustomFormModelInfo, ListCustomModelsResponse> {\n    const iter = this.listModelsAll({}, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      byPage: (settings: PageSettings = {}) => {\n        return this.listModelsPage(settings, options);\n      }\n    };\n  }\n\n  private async list(options?: ListModelsOptions): Promise<ListCustomModelsResponse> {\n    const realOptions: ListModelsOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-list\",\n      realOptions\n    );\n\n    try {\n      const result = await this.client.listCustomModels({\n        ...operationOptionsToRequestOptionsBase(finalOptions)\n      });\n\n      return result;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async listNextPage(\n    nextLink: string,\n    options?: ListModelsOptions\n  ): Promise<ListCustomModelsResponse> {\n    const realOptions: ListModelsOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-listNextPage\",\n      realOptions\n    );\n\n    try {\n      const result = await this.client.listCustomModelsNext(nextLink, {\n        ...operationOptionsToRequestOptionsBase(finalOptions)\n      });\n\n      return result;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates and trains a custom form model.\n   *\n   * If the `useTrainingLabels` parameter is set to `true`, then the operation will search\n   * for label files in addition to the training documents, and it will create a labeled\n   * model with the field names specified by the labels. Otherwise, it will create an\n   * unlabeled model automatically that returns generated field names for the items it\n   * determines are fields within the document structure.\n   *\n   * This method returns a long-running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Notes:\n   * - The onProgress callback will not be invoked if the operation completes in the first\n   *   request, and attempting to cancel a completed copy will result in an error being thrown.\n   * - Even when the training operation fails, a model is still created in the Azure Form\n   *   Recognizer resource.\n   *\n   * Example usage:\n   * ```ts\n   * const trainingFilesUrl = \"<url to the blob container storing training documents>\";\n   * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));\n   *\n   * const poller = await trainingClient.beginTraining(trainingFilesUrl, false, {\n   *   onProgress: (state) => { console.log(\"training status: \"); console.log(state); }\n   * });\n   * const model = await poller.pollUntilDone();\n   * ```\n   *\n   * Creates and trains a custom form model.\n   * @param trainingFilesUrl - Accessible url to an Azure Storage Blob container storing the training documents and optional label files\n   * @param useTrainingLabels - Specifies whether or not to search for and train using label files\n   * @param options - Options to start the model training operation\n   */\n  public async beginTraining(\n    trainingFilesUrl: string,\n    useTrainingLabels: boolean,\n    options: BeginTrainingOptions = {}\n  ): Promise<PollerLike<TrainingOperationState, CustomFormModel>> {\n    const trainPollerClient: TrainPollerClient = {\n      getCustomModel: (modelId: string, optionsParam: GetModelOptions) =>\n        this.getCustomModel(modelId, optionsParam),\n      trainCustomModelInternal: (\n        source: string | string[],\n        _useLabelFile?: boolean,\n        optionsParam?: BeginTrainingOptions\n      ) => trainCustomModelInternal(this.client, source as string, useTrainingLabels, optionsParam)\n    };\n\n    const poller = new BeginTrainingPoller({\n      client: trainPollerClient,\n      trainingInputs: trainingFilesUrl,\n      updateIntervalInMs: options.updateIntervalInMs,\n      onProgress: options.onProgress,\n      resumeFrom: options.resumeFrom,\n      trainModelOptions: options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Combines pre-existing models with labels into a single composed model.\n   *\n   * The composed model will contain copies of all of its input submodels, and it will\n   * choose (using a machine learning algorithm) the most appropriate of its input models\n   * to use during form recognition.\n   *\n   * This method returns a long-running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Notes:\n   * - Only labeled models can be composed. Attempting to compose an unlabeled model will\n   *   result in an error.\n   * - the onProgress callback will not be invoked if the operation completes in the first\n   *   request, and attempting to cancel a completed copy will result in an error being thrown.\n   * - evena when the training operation fails, a model is still created in the Azure Form\n   *   Recognizer resource.\n   *\n   * Example usage:\n   * ```ts\n   * const modelIds = [\"<model ID 1>\", \"<model ID 2>\", \"<model ID 3>\"];\n   * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));\n   *\n   * const poller = await trainingClient.beginCreateComposedModel(modelIds, {\n   *   modelName: \"<optional name for the composed model>\",\n   *   onProgress: (state) => { console.log(\"training status: \"); console.log(state); }\n   * });\n   * const composedModel = await poller.pollUntilDone();\n   * ```\n   *\n   * Combines pre-existing models with labels into a single composed model.\n   * @param modelIds - An array of model IDs within the Form Recognizer resouce to compose\n   * @param options - Options to start the create composed model operation\n   */\n  public async beginCreateComposedModel(\n    modelIds: string[],\n    options: BeginCreateComposedModelOptions\n  ): Promise<PollerLike<TrainingOperationState, CustomFormModel>> {\n    const composePollerClient: TrainPollerClient = {\n      getCustomModel: (modelId, optionsParam) => this.getCustomModel(modelId, optionsParam),\n      trainCustomModelInternal: (\n        sources: string | string[],\n        _?: boolean,\n        optionsParam?: BeginTrainingOptions\n      ) => composeModelInternal(this.client, sources as string[], optionsParam)\n    };\n\n    const poller = new BeginTrainingPoller({\n      client: composePollerClient,\n      trainingInputs: modelIds,\n      updateIntervalInMs: options.updateIntervalInMs,\n      onProgress: options.onProgress,\n      resumeFrom: options.resumeFrom,\n      trainModelOptions: options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Generate an authorization for copying a custom model into this Azure Form Recognizer resource.\n   *\n   * This method should be called on a client that is authenticated using the target resource (where the\n   * model will be copied to) credentials, and the output can be passed as the `target` parameter to the\n   * `beginCopyModel` method of a source client.\n   *\n   * The required `resourceId` and `resourceRegion` are properties of an Azure Form Recognizer resource and their values can be found in the Azure Portal.\n   *\n   * @param resourceId - Id of the Azure Form Recognizer resource where a custom model will be copied to\n   * @param resourceRegion - Location of the Azure Form Recognizer resource, must be a valid region name supported by Azure Cognitive Services. See https://aka.ms/azsdk/cognitiveservices/regionalavailability for information about the regional availability of Azure Cognitive Services.\n   * @param options - Options to get copy authorization operation\n   * @returns The authorization to copy a custom model\n   */\n  public async getCopyAuthorization(\n    resourceId: string,\n    resourceRegion: string,\n    options: GetCopyAuthorizationOptions = {}\n  ): Promise<CopyAuthorization> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-getCopyAuthorization\",\n      options\n    );\n\n    try {\n      const response = (await this.client.generateModelCopyAuthorization(\n        operationOptionsToRequestOptionsBase(finalOptions)\n      )) as CopyAuthorizationResult;\n      return {\n        resourceId: resourceId,\n        resourceRegion: resourceRegion,\n        expiresOn: new Date(response.expirationDateTimeTicks * 1000), // Convert to ms\n        modelId: response.modelId,\n        accessToken: response.accessToken\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Copies a custom model from this resource (the source) to the specified target Form Recognizer resource.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const targetClient = new FormTrainingClient(targetEndpoint, new AzureKeyCredential(targetApiKey));\n   * const authorization = await targetClient.getCopyAuthorization(targetResourceId, targetResourceRegion);\n   *\n   * const sourceClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await sourceClient.beginCopyModel(sourceModelId, authorization, {\n   *   onProgress: (state) => {\n   *     console.log(`Copy model status: ${state.status}`);\n   *   }\n   * });\n   * const result = await poller.pollUntilDone();\n   * ```\n   * Copies custom model to target resource\n   * @param modelId - Id of the custom model in this resource to be copied to the target Form Recognizer resource\n   * @param target - Copy authorization produced by calling `targetTrainingClient.getCopyAuthorization()`\n   * @param options - Options to copy model operation\n   */\n  public async beginCopyModel(\n    modelId: string,\n    target: CopyAuthorization,\n    options: BeginCopyModelOptions = {}\n  ): Promise<PollerLike<CopyModelOperationState, CustomFormModelInfo>> {\n    const copyModelClient: CopyModelPollerClient = {\n      beginCopyModel: (...args) => this.beginCopyModelInternal(...args),\n      getCopyModelResult: (...args) => this.getCopyModelResult(...args)\n    };\n\n    const poller = new BeginCopyModelPoller({\n      client: copyModelClient,\n      modelId,\n      targetResourceId: target.resourceId,\n      targetResourceRegion: target.resourceRegion,\n      copyAuthorization: target,\n      onProgress: options.onProgress,\n      resumeFrom: options.resumeFrom,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  private async beginCopyModelInternal(\n    modelId: string,\n    copyAuthorization: CopyAuthorization,\n    options: BeginCopyModelOptions = {}\n  ): Promise<CopyCustomModelResponseModel> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-beginCopyModelInternal\",\n      options\n    );\n\n    try {\n      return await this.client.copyCustomModel(\n        modelId,\n        {\n          targetResourceId: copyAuthorization.resourceId,\n          targetResourceRegion: copyAuthorization.resourceRegion,\n          copyAuthorization: {\n            modelId: copyAuthorization.modelId,\n            accessToken: copyAuthorization.accessToken,\n            expirationDateTimeTicks: copyAuthorization.expiresOn.getTime() / 1000\n          }\n        },\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async getCopyModelResult(\n    modelId: string,\n    resultId: string,\n    options: GetCopyModelResultOptions = {}\n  ): Promise<GetCustomModelCopyResultResponseModel> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormTrainingClient-getCopyModelResult\",\n      options\n    );\n\n    try {\n      return await this.client.getCustomModelCopyResult(\n        modelId,\n        resultId,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * @internal\n */\nasync function composeModelInternal(\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  client: GeneratedClient,\n  modelIds: string[],\n  options?: BeginCreateComposedModelOptions\n): Promise<GeneratedClientComposeCustomModelsAsyncResponse> {\n  const { span, updatedOptions: finalOptions } = createSpan(\"composeModelInternal\", options ?? {});\n\n  try {\n    return client.composeCustomModelsAsync(\n      {\n        modelIds,\n        modelName: options?.modelName\n      },\n      operationOptionsToRequestOptionsBase(finalOptions)\n    );\n  } catch (e) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n\n/**\n * @internal\n */\nasync function trainCustomModelInternal(\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  client: GeneratedClient,\n  source: string,\n  useLabelFile?: boolean,\n  options?: BeginTrainingOptions\n): Promise<GeneratedClientTrainCustomModelAsyncResponse> {\n  const realOptions = options || {};\n  const { span, updatedOptions: finalOptions } = createSpan(\n    \"trainCustomModelInternal\",\n    realOptions\n  );\n\n  try {\n    return client.trainCustomModelAsync(\n      {\n        source: source,\n        modelName: options?.modelName,\n        sourceFilter: {\n          prefix: realOptions.prefix,\n          includeSubfolders: realOptions.includeSubfolders\n        },\n        useLabelFile\n      },\n      operationOptionsToRequestOptionsBase(finalOptions)\n    );\n  } catch (e) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\n/** Request parameter to train a new custom model. */\nexport interface TrainRequest {\n  /** Source path containing the training documents. */\n  source: string;\n  /** Filter to apply to the documents in the source path for training. */\n  sourceFilter?: TrainSourceFilter;\n  /** Use label file for training a model. */\n  useLabelFile?: boolean;\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n}\n\n/** Filter to apply to the documents in the source path for training. */\nexport interface TrainSourceFilter {\n  /** A case-sensitive prefix string to filter documents in the source path for training. For example, when using a Azure storage blob Uri, use the prefix to restrict sub folders for training. */\n  prefix?: string;\n  /** A flag to indicate if sub folders within the set of prefix folders will also need to be included when searching for content to be preprocessed. */\n  includeSubfolders?: boolean;\n}\n\nexport interface ErrorResponse {\n  error: ErrorInformation;\n}\n\nexport interface ErrorInformation {\n  code: string;\n  message: string;\n}\n\n/** Response to the get custom model operation. */\nexport interface Model {\n  /** Basic custom model information. */\n  modelInfo: ModelInfo;\n  /** Keys extracted by the custom model. */\n  keys?: KeysResult;\n  /** Training result for custom model. */\n  trainResult?: TrainResult;\n  /** Training result for composed model. */\n  composedTrainResults?: TrainResult[];\n}\n\n/** Basic custom model information. */\nexport interface ModelInfo {\n  /** Model identifier. */\n  modelId: string;\n  /** Status of the model. */\n  status: ModelStatus;\n  /** Date and time (UTC) when the model was created. */\n  trainingStartedOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  trainingCompletedOn: Date;\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n  /** Optional model attributes. */\n  attributes?: Attributes;\n}\n\n/** Optional model attributes. */\nexport interface Attributes {\n  /** Is this model composed? (default: false). */\n  isComposed?: boolean;\n}\n\n/** Keys extracted by the custom model. */\nexport interface KeysResult {\n  /** Object mapping clusterIds to a list of keys. */\n  clusters: { [propertyName: string]: string[] };\n}\n\n/** Custom model training result. */\nexport interface TrainResult {\n  /** List of the documents used to train the model and any errors reported in each document. */\n  trainingDocuments: TrainingDocumentInfo[];\n  /** List of fields used to train the model and the train operation error reported by each. */\n  fields?: FormFieldsReport[];\n  /** Average accuracy. */\n  averageModelAccuracy?: number;\n  /** Model identifier. */\n  modelId?: string;\n  /** Errors returned during the training operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Report for a custom model training document. */\nexport interface TrainingDocumentInfo {\n  /** Training document name. */\n  name: string;\n  /** Total number of pages trained. */\n  pageCount: number;\n  /** List of errors. */\n  errors: ErrorInformation[];\n  /** Status of the training operation. */\n  status: TrainStatus;\n}\n\n/** Report for a custom model training field. */\nexport interface FormFieldsReport {\n  /** Training field name. */\n  fieldName: string;\n  /** Estimated extraction accuracy for this field. */\n  accuracy: number;\n}\n\n/** Uri or local path to source data. */\nexport interface SourcePath {\n  /** File source path. */\n  source?: string;\n}\n\n/** Status and result of the queued analyze operation. */\nexport interface AnalyzeOperationResult {\n  /** Operation status. */\n  status: OperationStatus;\n  /** Date and time (UTC) when the analyze operation was submitted. */\n  createdOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  lastModified: Date;\n  /** Results of the analyze operation. */\n  analyzeResult?: AnalyzeResult;\n}\n\n/** Analyze operation result. */\nexport interface AnalyzeResult {\n  /** Version of schema used for this result. */\n  version: string;\n  /** Text extracted from the input. */\n  readResults: ReadResult[];\n  /** Page-level information extracted from the input. */\n  pageResults?: PageResult[];\n  /** Document-level information extracted from the input. */\n  documentResults?: DocumentResult[];\n  /** List of errors reported during the analyze operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Text extracted from a page in the input document. */\nexport interface ReadResult {\n  /** The 1-based page number in the input document. */\n  pageNumber: number;\n  /** The general orientation of the text in clockwise direction, measured in degrees between (-180, 180]. */\n  angle: number;\n  /** The width of the image/PDF in pixels/inches, respectively. */\n  width: number;\n  /** The height of the image/PDF in pixels/inches, respectively. */\n  height: number;\n  /** The unit used by the width, height and boundingBox properties. For images, the unit is \"pixel\". For PDF, the unit is \"inch\". */\n  unit: LengthUnit;\n  /** When includeTextDetails is set to true, a list of recognized text lines. The maximum number of lines returned is 300 per page. The lines are sorted top to bottom, left to right, although in certain cases proximity is treated with higher priority. As the sorting order depends on the detected text, it may change across images and OCR version updates. Thus, business logic should be built upon the actual line location instead of order. */\n  lines?: TextLine[];\n  /** List of selection marks extracted from the page. */\n  selectionMarks?: SelectionMark[];\n}\n\n/** An object representing an extracted text line. */\nexport interface TextLine {\n  /** The text content of the line. */\n  text: string;\n  /** Bounding box of an extracted line. */\n  boundingBox: number[];\n  /** List of words in the text line. */\n  words: TextWord[];\n  /** Text appearance properties. */\n  appearance?: TextAppearance;\n}\n\n/** An object representing a word. */\nexport interface TextWord {\n  /** The text content of the word. */\n  text: string;\n  /** Bounding box of an extracted word. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence?: number;\n}\n\n/** An object representing the appearance of the text line. */\nexport interface TextAppearance {\n  /** An object representing the style of the text line. */\n  style: TextStyle;\n}\n\n/** An object representing the style of the text line. */\nexport interface TextStyle {\n  /** The text line style name, including handwriting and other. */\n  name: StyleName;\n  /** The confidence of text line style. */\n  confidence: number;\n}\n\n/** Information about the extracted selection mark. */\nexport interface SelectionMark {\n  /** Bounding box of the selection mark. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence: number;\n  /** State of the selection mark. */\n  state: SelectionMarkState;\n}\n\n/** Extracted information from a single page. */\nexport interface PageResult {\n  /** Page number. */\n  pageNumber: number;\n  /** Cluster identifier. */\n  clusterId?: number;\n  /** List of key-value pairs extracted from the page. */\n  keyValuePairs?: KeyValuePair[];\n  /** List of data tables extracted from the page. */\n  tables?: DataTable[];\n}\n\n/** Information about the extracted key-value pair. */\nexport interface KeyValuePair {\n  /** A user defined label for the key/value pair entry. */\n  label?: string;\n  /** Information about the extracted key in a key-value pair. */\n  key: KeyValueElement;\n  /** Information about the extracted value in a key-value pair. */\n  value: KeyValueElement;\n  /** Confidence value. */\n  confidence: number;\n}\n\n/** Information about the extracted key or value in a key-value pair. */\nexport interface KeyValueElement {\n  /** Semantic data type of the key value element. */\n  type?: KeyValueType;\n  /** The text content of the key or value. */\n  text: string;\n  /** Bounding box of the key or value. */\n  boundingBox?: number[];\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this key or value. */\n  elements?: string[];\n}\n\n/** Information about the extracted table contained in a page. */\nexport interface DataTable {\n  /** Number of rows. */\n  rows: number;\n  /** Number of columns. */\n  columns: number;\n  /** List of cells contained in the table. */\n  cells: DataTableCell[];\n  /** Bounding box of the table. */\n  boundingBox: number[];\n}\n\n/** Information about the extracted cell in a table. */\nexport interface DataTableCell {\n  /** Row index of the cell. */\n  rowIndex: number;\n  /** Column index of the cell. */\n  columnIndex: number;\n  /** Number of rows spanned by this cell. */\n  rowSpan?: number;\n  /** Number of columns spanned by this cell. */\n  columnSpan?: number;\n  /** Text content of the cell. */\n  text: string;\n  /** Bounding box of the cell. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence: number;\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this table cell. */\n  elements?: string[];\n  /** Is the current cell a header cell? */\n  isHeader?: boolean;\n  /** Is the current cell a footer cell? */\n  isFooter?: boolean;\n}\n\n/** A set of extracted fields corresponding to the input document. */\nexport interface DocumentResult {\n  /** Document type. */\n  docType: string;\n  /** Model identifier. */\n  modelId?: string;\n  /** First and last page number where the document is found. */\n  pageRange: number[];\n  /** Predicted document type confidence. */\n  docTypeConfidence?: number;\n  /** Dictionary of named field values. */\n  fields: { [propertyName: string]: FieldValue };\n}\n\n/** Recognized field value. */\nexport interface FieldValue {\n  /** Type of field value. */\n  type: FieldValueType;\n  /** String value. */\n  valueString?: string;\n  /** Date value. */\n  valueDate?: Date;\n  /**\n   * Time value.\n   * This value should be an ISO-8601 formatted string representing time. E.g. \"HH:MM:SS\" or \"HH:MM:SS.mm\".\n   */\n  valueTime?: string;\n  /** Phone number value. */\n  valuePhoneNumber?: string;\n  /** Floating point value. */\n  valueNumber?: number;\n  /** Integer value. */\n  valueInteger?: number;\n  /** Array of field values. */\n  valueArray?: FieldValue[];\n  /** Dictionary of named field values. */\n  valueObject?: { [propertyName: string]: FieldValue };\n  /** Selection mark value. */\n  valueSelectionMark?: FieldValueSelectionMark;\n  /** 3-letter country code (ISO 3166-1 alpha-3). */\n  valueCountryRegion?: string;\n  /** Text content of the extracted field. */\n  text?: string;\n  /** Bounding box of the field value, if appropriate. */\n  boundingBox?: number[];\n  /** Confidence score. */\n  confidence?: number;\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this field. */\n  elements?: string[];\n  /** The 1-based page number in the input document. */\n  pageNumber?: number;\n}\n\n/** Request parameter to copy an existing custom model from the source resource to a target resource referenced by the resource ID. */\nexport interface CopyRequest {\n  /** Azure Resource Id of the target Form Recognizer resource where the model is copied to. */\n  targetResourceId: string;\n  /** Location of the target Azure resource. A valid Azure region name supported by Cognitive Services. */\n  targetResourceRegion: string;\n  /** Entity that encodes claims to authorize the copy request. */\n  copyAuthorization: CopyAuthorizationResult;\n}\n\n/** Request parameter that contains authorization claims for copy operation. */\nexport interface CopyAuthorizationResult {\n  /** Model identifier. */\n  modelId: string;\n  /** Token claim used to authorize the request. */\n  accessToken: string;\n  /** The time when the access token expires. The date is represented as the number of seconds from 1970-01-01T0:0:0Z UTC until the expiration time. */\n  expirationDateTimeTicks: number;\n}\n\n/** Status and result of the queued copy operation. */\nexport interface CopyOperationResult {\n  /** Operation status. */\n  status: OperationStatus;\n  /** Date and time (UTC) when the copy operation was submitted. */\n  createdOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  lastModified: Date;\n  /** Results of the copy operation. */\n  copyResult?: CopyResult;\n}\n\n/** Custom model copy result. */\nexport interface CopyResult {\n  /** Identifier of the target model. */\n  modelId: string;\n  /** Errors returned during the copy operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Request contract for compose operation. */\nexport interface ComposeRequest {\n  /** List of model ids to compose. */\n  modelIds: string[];\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n}\n\n/** Response to the list custom models operation. */\nexport interface Models {\n  /** Summary of all trained custom models. */\n  summary?: ModelsSummary;\n  /** Collection of trained custom models. */\n  modelList?: ModelInfo[];\n  /** Link to the next page of custom models. */\n  nextLink?: string;\n}\n\n/** Summary of all trained custom models. */\nexport interface ModelsSummary {\n  /** Current count of trained custom models. */\n  count: number;\n  /** Max number of models that can be trained for this account. */\n  limit: number;\n  /** Date and time (UTC) when the summary was last updated. */\n  lastModified: Date;\n}\n\n/** Defines headers for GeneratedClient_trainCustomModelAsync operation. */\nexport interface GeneratedClientTrainCustomModelAsyncHeaders {\n  /** Location and ID of the model being trained. The status of model training is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeWithCustomModel operation. */\nexport interface GeneratedClientAnalyzeWithCustomModelHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_copyCustomModel operation. */\nexport interface GeneratedClientCopyCustomModelHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the copy operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_generateModelCopyAuthorization operation. */\nexport interface GeneratedClientGenerateModelCopyAuthorizationHeaders {\n  /** Location and ID of the model being copied. The status of model copy is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_composeCustomModelsAsync operation. */\nexport interface GeneratedClientComposeCustomModelsAsyncHeaders {\n  /** Location and ID of the composed model. The status of composed model is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeBusinessCardAsync operation. */\nexport interface GeneratedClientAnalyzeBusinessCardAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeInvoiceAsync operation. */\nexport interface GeneratedClientAnalyzeInvoiceAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeIdDocumentAsync operation. */\nexport interface GeneratedClientAnalyzeIdDocumentAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeReceiptAsync operation. */\nexport interface GeneratedClientAnalyzeReceiptAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeLayoutAsync operation. */\nexport interface GeneratedClientAnalyzeLayoutAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Known values of {@link KeyValueType} that the service accepts. */\nexport const enum KnownKeyValueType {\n  String = \"string\",\n  SelectionMark = \"selectionMark\"\n}\n\n/**\n * Defines values for KeyValueType. \\\n * {@link KnownKeyValueType} can be used interchangeably with KeyValueType,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **string** \\\n * **selectionMark**\n */\nexport type KeyValueType = string;\n\n/** Known values of {@link FieldValueSelectionMark} that the service accepts. */\nexport const enum KnownFieldValueSelectionMark {\n  Selected = \"selected\",\n  Unselected = \"unselected\"\n}\n\n/**\n * Defines values for FieldValueSelectionMark. \\\n * {@link KnownFieldValueSelectionMark} can be used interchangeably with FieldValueSelectionMark,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **selected** \\\n * **unselected**\n */\nexport type FieldValueSelectionMark = string;\n\n/** Known values of {@link FormLocale} that the service accepts. */\nexport const enum KnownFormLocale {\n  EnAU = \"en-AU\",\n  EnCA = \"en-CA\",\n  EnGB = \"en-GB\",\n  EnIN = \"en-IN\",\n  EnUS = \"en-US\"\n}\n\n/**\n * Defines values for FormLocale. \\\n * {@link KnownFormLocale} can be used interchangeably with FormLocale,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **en-AU** \\\n * **en-CA** \\\n * **en-GB** \\\n * **en-IN** \\\n * **en-US**\n */\nexport type FormLocale = string;\n\n/** Known values of {@link FormLanguage} that the service accepts. */\nexport const enum KnownFormLanguage {\n  Af = \"af\",\n  Ast = \"ast\",\n  Bi = \"bi\",\n  Br = \"br\",\n  Ca = \"ca\",\n  Ceb = \"ceb\",\n  Ch = \"ch\",\n  Co = \"co\",\n  Crh = \"crh\",\n  Cs = \"cs\",\n  Csb = \"csb\",\n  Da = \"da\",\n  De = \"de\",\n  En = \"en\",\n  Es = \"es\",\n  Et = \"et\",\n  Eu = \"eu\",\n  Fi = \"fi\",\n  Fil = \"fil\",\n  Fj = \"fj\",\n  Fr = \"fr\",\n  Fur = \"fur\",\n  Fy = \"fy\",\n  Ga = \"ga\",\n  Gd = \"gd\",\n  Gil = \"gil\",\n  Gl = \"gl\",\n  Gv = \"gv\",\n  Hni = \"hni\",\n  Hsb = \"hsb\",\n  Ht = \"ht\",\n  Hu = \"hu\",\n  Ia = \"ia\",\n  Id = \"id\",\n  It = \"it\",\n  Iu = \"iu\",\n  Ja = \"ja\",\n  Jv = \"jv\",\n  Kaa = \"kaa\",\n  Kac = \"kac\",\n  Kea = \"kea\",\n  Kha = \"kha\",\n  Kl = \"kl\",\n  Ko = \"ko\",\n  Ku = \"ku\",\n  Kw = \"kw\",\n  Lb = \"lb\",\n  Ms = \"ms\",\n  Mww = \"mww\",\n  Nap = \"nap\",\n  Nl = \"nl\",\n  No = \"no\",\n  Oc = \"oc\",\n  Pl = \"pl\",\n  Pt = \"pt\",\n  Quc = \"quc\",\n  Rm = \"rm\",\n  Sco = \"sco\",\n  Sl = \"sl\",\n  Sq = \"sq\",\n  Sv = \"sv\",\n  Sw = \"sw\",\n  Tet = \"tet\",\n  Tr = \"tr\",\n  Tt = \"tt\",\n  Uz = \"uz\",\n  Vo = \"vo\",\n  Wae = \"wae\",\n  Yua = \"yua\",\n  Za = \"za\",\n  ZhHans = \"zh-Hans\",\n  ZhHant = \"zh-Hant\",\n  Zu = \"zu\"\n}\n\n/**\n * Defines values for FormLanguage. \\\n * {@link KnownFormLanguage} can be used interchangeably with FormLanguage,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **af** \\\n * **ast** \\\n * **bi** \\\n * **br** \\\n * **ca** \\\n * **ceb** \\\n * **ch** \\\n * **co** \\\n * **crh** \\\n * **cs** \\\n * **csb** \\\n * **da** \\\n * **de** \\\n * **en** \\\n * **es** \\\n * **et** \\\n * **eu** \\\n * **fi** \\\n * **fil** \\\n * **fj** \\\n * **fr** \\\n * **fur** \\\n * **fy** \\\n * **ga** \\\n * **gd** \\\n * **gil** \\\n * **gl** \\\n * **gv** \\\n * **hni** \\\n * **hsb** \\\n * **ht** \\\n * **hu** \\\n * **ia** \\\n * **id** \\\n * **it** \\\n * **iu** \\\n * **ja** \\\n * **jv** \\\n * **kaa** \\\n * **kac** \\\n * **kea** \\\n * **kha** \\\n * **kl** \\\n * **ko** \\\n * **ku** \\\n * **kw** \\\n * **lb** \\\n * **ms** \\\n * **mww** \\\n * **nap** \\\n * **nl** \\\n * **no** \\\n * **oc** \\\n * **pl** \\\n * **pt** \\\n * **quc** \\\n * **rm** \\\n * **sco** \\\n * **sl** \\\n * **sq** \\\n * **sv** \\\n * **sw** \\\n * **tet** \\\n * **tr** \\\n * **tt** \\\n * **uz** \\\n * **vo** \\\n * **wae** \\\n * **yua** \\\n * **za** \\\n * **zh-Hans** \\\n * **zh-Hant** \\\n * **zu**\n */\nexport type FormLanguage = string;\n/** Defines values for ModelStatus. */\nexport type ModelStatus = \"creating\" | \"ready\" | \"invalid\";\n/** Defines values for TrainStatus. */\nexport type TrainStatus = \"succeeded\" | \"partiallySucceeded\" | \"failed\";\n/** Defines values for ContentType. */\nexport type ContentType =\n  | \"application/pdf\"\n  | \"image/bmp\"\n  | \"image/jpeg\"\n  | \"image/png\"\n  | \"image/tiff\";\n/** Defines values for OperationStatus. */\nexport type OperationStatus = \"notStarted\" | \"running\" | \"succeeded\" | \"failed\";\n/** Defines values for LengthUnit. */\nexport type LengthUnit = \"pixel\" | \"inch\";\n/** Defines values for StyleName. */\nexport type StyleName = \"other\" | \"handwriting\";\n/** Defines values for SelectionMarkState. */\nexport type SelectionMarkState = \"selected\" | \"unselected\";\n/** Defines values for FieldValueType. */\nexport type FieldValueType =\n  | \"string\"\n  | \"date\"\n  | \"time\"\n  | \"phoneNumber\"\n  | \"number\"\n  | \"integer\"\n  | \"array\"\n  | \"object\"\n  | \"selectionMark\"\n  | \"countryRegion\";\n/** Defines values for FormReadingOrder. */\nexport type FormReadingOrder = \"basic\" | \"natural\";\n\n/** Contains response data for the trainCustomModelAsync operation. */\nexport type GeneratedClientTrainCustomModelAsyncResponse = GeneratedClientTrainCustomModelAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientTrainCustomModelAsyncHeaders;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientGetCustomModelOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include list of extracted keys in model information. */\n  includeKeys?: boolean;\n}\n\n/** Contains response data for the getCustomModel operation. */\nexport type GeneratedClientGetCustomModelResponse = Model & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Model;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeWithCustomModel$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeWithCustomModel$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Contains response data for the analyzeWithCustomModel operation. */\nexport type GeneratedClientAnalyzeWithCustomModelResponse = GeneratedClientAnalyzeWithCustomModelHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeWithCustomModelHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeFormResult operation. */\nexport type GeneratedClientGetAnalyzeFormResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Contains response data for the copyCustomModel operation. */\nexport type GeneratedClientCopyCustomModelResponse = GeneratedClientCopyCustomModelHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientCopyCustomModelHeaders;\n  };\n};\n\n/** Contains response data for the getCustomModelCopyResult operation. */\nexport type GeneratedClientGetCustomModelCopyResultResponse = CopyOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: CopyOperationResult;\n  };\n};\n\n/** Contains response data for the generateModelCopyAuthorization operation. */\nexport type GeneratedClientGenerateModelCopyAuthorizationResponse = GeneratedClientGenerateModelCopyAuthorizationHeaders &\n  CopyAuthorizationResult & {\n    /** The underlying HTTP response. */\n    _response: coreHttp.HttpResponse & {\n      /** The response body as text (string format) */\n      bodyAsText: string;\n\n      /** The response body as parsed JSON or XML */\n      parsedBody: CopyAuthorizationResult;\n      /** The parsed HTTP response headers. */\n      parsedHeaders: GeneratedClientGenerateModelCopyAuthorizationHeaders;\n    };\n  };\n\n/** Contains response data for the composeCustomModelsAsync operation. */\nexport type GeneratedClientComposeCustomModelsAsyncResponse = GeneratedClientComposeCustomModelsAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientComposeCustomModelsAsyncHeaders;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeBusinessCardAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeBusinessCardAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeBusinessCardAsync operation. */\nexport type GeneratedClientAnalyzeBusinessCardAsyncResponse = GeneratedClientAnalyzeBusinessCardAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeBusinessCardAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeBusinessCardResult operation. */\nexport type GeneratedClientGetAnalyzeBusinessCardResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeInvoiceAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeInvoiceAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeInvoiceAsync operation. */\nexport type GeneratedClientAnalyzeInvoiceAsyncResponse = GeneratedClientAnalyzeInvoiceAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeInvoiceAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeInvoiceResult operation. */\nexport type GeneratedClientGetAnalyzeInvoiceResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeIdDocumentAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeIdDocumentAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Contains response data for the analyzeIdDocumentAsync operation. */\nexport type GeneratedClientAnalyzeIdDocumentAsyncResponse = GeneratedClientAnalyzeIdDocumentAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeIdDocumentAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeIdDocumentResult operation. */\nexport type GeneratedClientGetAnalyzeIdDocumentResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeReceiptAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeReceiptAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeReceiptAsync operation. */\nexport type GeneratedClientAnalyzeReceiptAsyncResponse = GeneratedClientAnalyzeReceiptAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeReceiptAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeReceiptResult operation. */\nexport type GeneratedClientGetAnalyzeReceiptResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeLayoutAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co), Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl), German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa), Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc), Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt), Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are supported (print  seventy-three languages and handwritten  English only). Layout supports auto language identification and multi language documents, so only provide a language code if you would like to force the documented to be processed as that specific language. */\n  language?: FormLanguage;\n  /** Reading order algorithm to sort the text lines returned. Supported reading orders include: basic(default), natural. */\n  readingOrder?: FormReadingOrder;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeLayoutAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co), Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl), German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa), Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc), Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt), Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are supported (print  seventy-three languages and handwritten  English only). Layout supports auto language identification and multi language documents, so only provide a language code if you would like to force the documented to be processed as that specific language. */\n  language?: FormLanguage;\n  /** Reading order algorithm to sort the text lines returned. Supported reading orders include: basic(default), natural. */\n  readingOrder?: FormReadingOrder;\n}\n\n/** Contains response data for the analyzeLayoutAsync operation. */\nexport type GeneratedClientAnalyzeLayoutAsyncResponse = GeneratedClientAnalyzeLayoutAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeLayoutAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeLayoutResult operation. */\nexport type GeneratedClientGetAnalyzeLayoutResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Contains response data for the listCustomModels operation. */\nexport type GeneratedClientListCustomModelsResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Contains response data for the getCustomModels operation. */\nexport type GeneratedClientGetCustomModelsResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Contains response data for the listCustomModelsNext operation. */\nexport type GeneratedClientListCustomModelsNextResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientOptionalParams\n  extends coreHttp.ServiceClientOptions {\n  /** Overrides client endpoint. */\n  endpoint?: string;\n}\n"],"names":["createClientLogger","createSpanFunction","TrainRequestMapper","SourcePathMapper","CopyRequestMapper","ComposeRequestMapper","coreHttp.ServiceClient","coreHttp.getDefaultUserAgentValue","coreHttp.operationOptionsToRequestOptionsBase","coreHttp.Serializer","Mappers.GeneratedClientTrainCustomModelAsyncHeaders","Mappers.ErrorResponse","Parameters.trainRequest","Parameters.endpoint","Parameters.contentType","Parameters.accept","Mappers.Model","Parameters.includeKeys","Parameters.modelId","Mappers.GeneratedClientAnalyzeWithCustomModelHeaders","Parameters.fileStream","Parameters.includeTextDetails","Parameters.pages","Parameters.contentType1","Parameters.accept1","Parameters.fileStream1","Parameters.contentType2","Mappers.AnalyzeOperationResult","Parameters.resultId","Mappers.GeneratedClientCopyCustomModelHeaders","Parameters.copyRequest","Mappers.CopyOperationResult","Mappers.CopyAuthorizationResult","Mappers.GeneratedClientGenerateModelCopyAuthorizationHeaders","Mappers.GeneratedClientComposeCustomModelsAsyncHeaders","Parameters.composeRequest","Parameters.accept2","Mappers.GeneratedClientAnalyzeBusinessCardAsyncHeaders","Parameters.locale","Mappers.GeneratedClientAnalyzeInvoiceAsyncHeaders","Mappers.GeneratedClientAnalyzeIdDocumentAsyncHeaders","Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders","Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders","Parameters.language","Parameters.readingOrder","Mappers.Models","Parameters.op","Parameters.op1","Parameters.nextLink","Poller","delay","BaseRequestPolicy","isTokenCredential","bearerTokenAuthenticationPolicy","createPipelineFromOptions","operationOptionsToRequestOptionsBase","SpanStatusCode","__asyncValues","__asyncDelegator","KnownFormLocale","KnownFormLanguage"],"mappings":"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"}