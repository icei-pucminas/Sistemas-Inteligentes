'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var coreLro = require('@azure/core-lro');
require('@azure/core-paging');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "3.1.0";
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * Maximum size of input documents allowed by the Azure Form Recognizer service.
 * @internal
 */
const MAX_INPUT_DOCUMENT_SIZE = 50 * 1024 * 1024; // 50 MB
const FormRecognizerLoggingAllowedHeaderNames = [
    "apim-request-id",
    "Location",
    "Operation-Location",
    "Strict-Transport-Security",
    "X-Content-Type-Options",
    "x-envoy-upstream-service-time"
];
const FormRecognizerLoggingAllowedQueryParameters = [
    "includeTextDetails",
    "includeKeys",
    "op"
];

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("ai-form-recognizer");

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.CognitiveServices.FormRecognizer",
    namespace: "Microsoft.CognitiveServices"
});

// Copyright (c) Microsoft Corporation.
const SIZE_ONE_MEGA = 1024 * 1024;
/**
 * Reads a readable stream into buffer entirely. NodeJS only.
 * The maximum allowed size is specified in {@link MAX_INPUT_DOCUMENT_SIZE}.
 *
 * @param stream - A Node.js Readable stream
 * @returns The resultant buffer.
 * @throws If buffer size is not big enough.
 */
function streamToBuffer(stream, maxSize) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        let pos = 0; // Position in stream
        let size = SIZE_ONE_MEGA;
        let buffer = Buffer.alloc(size);
        return new Promise((resolve, reject) => {
            stream.on("readable", () => {
                const chunk = stream.read();
                if (!chunk) {
                    return;
                }
                const nextPos = pos + chunk.length;
                if (size < nextPos && nextPos <= maxSize) {
                    // Keep doubling buffer until it is large enough or over max size
                    const oldSize = size;
                    while (size < nextPos && size * 2 < maxSize) {
                        size *= 2;
                    }
                    if (nextPos < size && size < maxSize) {
                        const newBuffer = Buffer.alloc(size - oldSize);
                        buffer = Buffer.concat([buffer, newBuffer]);
                    }
                    else {
                        const newBuffer = Buffer.alloc(maxSize - oldSize);
                        size = maxSize;
                        buffer = Buffer.concat([buffer, newBuffer]);
                    }
                }
                else if (nextPos > maxSize) {
                    reject(new Error(`Input stream exceeds maximum allowed size: ${maxSize}`));
                    return;
                }
                buffer.fill(chunk, pos, nextPos);
                pos = nextPos;
            });
            stream.on("end", () => {
                resolve(buffer.slice(0, pos));
            });
            stream.on("error", reject);
        });
    });
}
function getFirstFourBytesFromBlob(_data) {
    throw new Error("Blob is not supported in NodeJS environment");
}

// Copyright (c) Microsoft Corporation.
/**
 * Translate the content to a format that is understood by Form Recognizer service
 * @internal
 */
function toRequestBody(body) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if (typeof body === "string") {
            return {
                source: body
            };
        }
        else {
            // cache stream to allow retry
            if (isReadableStream(body)) {
                return streamToBuffer(body, MAX_INPUT_DOCUMENT_SIZE);
            }
            return body;
        }
    });
}
function isReadableStream(data) {
    return "read" in data && typeof data.read === "function";
}
function isBlob(data) {
    return "size" in data && "type" in data;
}
function isArrayBuffer(data) {
    return "byteLength" in data && "slice" in data && typeof data.slice === "function";
}
function isArrayBufferView(data) {
    return "buffer" in data && "byteLength" in data && "byteOffset" in data;
}
function isSourcePath(data) {
    return "source" in data && typeof data.source === "string";
}
/**
 * Detects the content type of binary data.
 * See https://en.wikipedia.org/wiki/List_of_file_signatures
 * @internal
 */
function getContentType(data) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if (isSourcePath(data)) {
            return undefined;
        }
        let bytes;
        if (isArrayBuffer(data)) {
            // ArrayBuffer
            if (data.byteLength < 4) {
                throw new RangeError("Invalid input. Expect more than 4 bytes of data");
            }
            bytes = new Uint8Array(data, 0, 4);
        }
        else if (isArrayBufferView(data)) {
            // ArrayBufferView
            if (data.byteLength < 4) {
                throw new RangeError("Invalid input. Expect more than 4 bytes of data");
            }
            bytes = new Uint8Array(data.buffer, 0, 4);
        }
        else if (isBlob(data)) {
            // Blob
            bytes = yield getFirstFourBytesFromBlob();
        }
        else {
            throw new Error("unsupported request body type");
        }
        if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {
            return "application/pdf";
        }
        else if (bytes[0] === 0xff && bytes[1] === 0xd8) {
            return "image/jpeg";
        }
        else if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47) {
            return "image/png";
        }
        else if ((bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2a && bytes[3] === 0x0) ||
            (bytes[0] === 0x4d && bytes[1] === 0x4d && bytes[2] === 0x0 && bytes[3] === 0x2a)) {
            return "image/tiff";
        }
        else if (bytes[0] === 0x42 && bytes[1] === 0x4d) {
            return "image/bmp";
        }
        else {
            throw new RangeError("content type could not be detected");
        }
    });
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const TrainRequest = {
    type: {
        name: "Composite",
        className: "TrainRequest",
        modelProperties: {
            source: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceFilter: {
                serializedName: "sourceFilter",
                type: {
                    name: "Composite",
                    className: "TrainSourceFilter"
                }
            },
            useLabelFile: {
                serializedName: "useLabelFile",
                type: {
                    name: "Boolean"
                }
            },
            modelName: {
                serializedName: "modelName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrainSourceFilter = {
    type: {
        name: "Composite",
        className: "TrainSourceFilter",
        modelProperties: {
            prefix: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "prefix",
                type: {
                    name: "String"
                }
            },
            includeSubfolders: {
                serializedName: "includeSubFolders",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInformation"
                }
            }
        }
    }
};
const ErrorInformation = {
    type: {
        name: "Composite",
        className: "ErrorInformation",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Model = {
    type: {
        name: "Composite",
        className: "Model",
        modelProperties: {
            modelInfo: {
                serializedName: "modelInfo",
                type: {
                    name: "Composite",
                    className: "ModelInfo"
                }
            },
            keys: {
                serializedName: "keys",
                type: {
                    name: "Composite",
                    className: "KeysResult"
                }
            },
            trainResult: {
                serializedName: "trainResult",
                type: {
                    name: "Composite",
                    className: "TrainResult"
                }
            },
            composedTrainResults: {
                serializedName: "composedTrainResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrainResult"
                        }
                    }
                }
            }
        }
    }
};
const ModelInfo = {
    type: {
        name: "Composite",
        className: "ModelInfo",
        modelProperties: {
            modelId: {
                serializedName: "modelId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["creating", "ready", "invalid"]
                }
            },
            trainingStartedOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            trainingCompletedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            modelName: {
                serializedName: "modelName",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "Attributes"
                }
            }
        }
    }
};
const Attributes = {
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            isComposed: {
                serializedName: "isComposed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const KeysResult = {
    type: {
        name: "Composite",
        className: "KeysResult",
        modelProperties: {
            clusters: {
                serializedName: "clusters",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } },
                        constraints: { UniqueItems: true }
                    }
                }
            }
        }
    }
};
const TrainResult = {
    type: {
        name: "Composite",
        className: "TrainResult",
        modelProperties: {
            trainingDocuments: {
                serializedName: "trainingDocuments",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrainingDocumentInfo"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FormFieldsReport"
                        }
                    }
                }
            },
            averageModelAccuracy: {
                serializedName: "averageModelAccuracy",
                type: {
                    name: "Number"
                }
            },
            modelId: {
                serializedName: "modelId",
                type: {
                    name: "Uuid"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorInformation"
                        }
                    }
                }
            }
        }
    }
};
const TrainingDocumentInfo = {
    type: {
        name: "Composite",
        className: "TrainingDocumentInfo",
        modelProperties: {
            name: {
                serializedName: "documentName",
                required: true,
                type: {
                    name: "String"
                }
            },
            pageCount: {
                serializedName: "pages",
                required: true,
                type: {
                    name: "Number"
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorInformation"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["succeeded", "partiallySucceeded", "failed"]
                }
            }
        }
    }
};
const FormFieldsReport = {
    type: {
        name: "Composite",
        className: "FormFieldsReport",
        modelProperties: {
            fieldName: {
                serializedName: "fieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            accuracy: {
                serializedName: "accuracy",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SourcePath = {
    type: {
        name: "Composite",
        className: "SourcePath",
        modelProperties: {
            source: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "source",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalyzeOperationResult = {
    type: {
        name: "Composite",
        className: "AnalyzeOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["notStarted", "running", "succeeded", "failed"]
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            analyzeResult: {
                serializedName: "analyzeResult",
                type: {
                    name: "Composite",
                    className: "AnalyzeResult"
                }
            }
        }
    }
};
const AnalyzeResult = {
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "String"
                }
            },
            readResults: {
                serializedName: "readResults",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReadResult"
                        }
                    }
                }
            },
            pageResults: {
                serializedName: "pageResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PageResult"
                        }
                    }
                }
            },
            documentResults: {
                serializedName: "documentResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentResult"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorInformation"
                        }
                    }
                }
            }
        }
    }
};
const ReadResult = {
    type: {
        name: "Composite",
        className: "ReadResult",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "page",
                required: true,
                type: {
                    name: "Number"
                }
            },
            angle: {
                constraints: {
                    InclusiveMaximum: 180,
                    ExclusiveMinimum: -180
                },
                serializedName: "angle",
                required: true,
                type: {
                    name: "Number"
                }
            },
            width: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "width",
                required: true,
                type: {
                    name: "Number"
                }
            },
            height: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "height",
                required: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["pixel", "inch"]
                }
            },
            lines: {
                serializedName: "lines",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextLine"
                        }
                    }
                }
            },
            selectionMarks: {
                serializedName: "selectionMarks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SelectionMark"
                        }
                    }
                }
            }
        }
    }
};
const TextLine = {
    type: {
        name: "Composite",
        className: "TextLine",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            words: {
                serializedName: "words",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextWord"
                        }
                    }
                }
            },
            appearance: {
                serializedName: "appearance",
                type: {
                    name: "Composite",
                    className: "TextAppearance"
                }
            }
        }
    }
};
const TextWord = {
    type: {
        name: "Composite",
        className: "TextWord",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TextAppearance = {
    type: {
        name: "Composite",
        className: "TextAppearance",
        modelProperties: {
            style: {
                serializedName: "style",
                type: {
                    name: "Composite",
                    className: "TextStyle"
                }
            }
        }
    }
};
const TextStyle = {
    type: {
        name: "Composite",
        className: "TextStyle",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["other", "handwriting"]
                }
            },
            confidence: {
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SelectionMark = {
    type: {
        name: "Composite",
        className: "SelectionMark",
        modelProperties: {
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["selected", "unselected"]
                }
            }
        }
    }
};
const PageResult = {
    type: {
        name: "Composite",
        className: "PageResult",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "page",
                required: true,
                type: {
                    name: "Number"
                }
            },
            clusterId: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "clusterId",
                type: {
                    name: "Number"
                }
            },
            keyValuePairs: {
                serializedName: "keyValuePairs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValuePair"
                        }
                    }
                }
            },
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataTable"
                        }
                    }
                }
            }
        }
    }
};
const KeyValuePair = {
    type: {
        name: "Composite",
        className: "KeyValuePair",
        modelProperties: {
            label: {
                serializedName: "label",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "KeyValueElement"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "KeyValueElement"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KeyValueElement = {
    type: {
        name: "Composite",
        className: "KeyValueElement",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            elements: {
                serializedName: "elements",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DataTable = {
    type: {
        name: "Composite",
        className: "DataTable",
        modelProperties: {
            rows: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rows",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columns: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columns",
                required: true,
                type: {
                    name: "Number"
                }
            },
            cells: {
                serializedName: "cells",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataTableCell"
                        }
                    }
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const DataTableCell = {
    type: {
        name: "Composite",
        className: "DataTableCell",
        modelProperties: {
            rowIndex: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "rowIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columnIndex: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "columnIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rowSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rowSpan",
                type: {
                    name: "Number"
                }
            },
            columnSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columnSpan",
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            },
            elements: {
                serializedName: "elements",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isHeader: {
                serializedName: "isHeader",
                type: {
                    name: "Boolean"
                }
            },
            isFooter: {
                serializedName: "isFooter",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DocumentResult = {
    type: {
        name: "Composite",
        className: "DocumentResult",
        modelProperties: {
            docType: {
                serializedName: "docType",
                required: true,
                type: {
                    name: "String"
                }
            },
            modelId: {
                serializedName: "modelId",
                type: {
                    name: "Uuid"
                }
            },
            pageRange: {
                constraints: {
                    MinItems: 2,
                    MaxItems: 2
                },
                serializedName: "pageRange",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 1
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            docTypeConfidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "docTypeConfidence",
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "FieldValue" } }
                }
            }
        }
    }
};
const FieldValue = {
    type: {
        name: "Composite",
        className: "FieldValue",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "string",
                        "date",
                        "time",
                        "phoneNumber",
                        "number",
                        "integer",
                        "array",
                        "object",
                        "selectionMark",
                        "countryRegion"
                    ]
                }
            },
            valueString: {
                serializedName: "valueString",
                type: {
                    name: "String"
                }
            },
            valueDate: {
                serializedName: "valueDate",
                type: {
                    name: "Date"
                }
            },
            valueTime: {
                serializedName: "valueTime",
                type: {
                    name: "String"
                }
            },
            valuePhoneNumber: {
                serializedName: "valuePhoneNumber",
                type: {
                    name: "String"
                }
            },
            valueNumber: {
                serializedName: "valueNumber",
                type: {
                    name: "Number"
                }
            },
            valueInteger: {
                serializedName: "valueInteger",
                type: {
                    name: "Number"
                }
            },
            valueArray: {
                serializedName: "valueArray",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldValue"
                        }
                    }
                }
            },
            valueObject: {
                serializedName: "valueObject",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "FieldValue" } }
                }
            },
            valueSelectionMark: {
                serializedName: "valueSelectionMark",
                type: {
                    name: "String"
                }
            },
            valueCountryRegion: {
                serializedName: "valueCountryRegion",
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            boundingBox: {
                constraints: {
                    MinItems: 8,
                    MaxItems: 8
                },
                serializedName: "boundingBox",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                type: {
                    name: "Number"
                }
            },
            elements: {
                serializedName: "elements",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "page",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CopyRequest = {
    type: {
        name: "Composite",
        className: "CopyRequest",
        modelProperties: {
            targetResourceId: {
                constraints: {
                    Pattern: new RegExp("^/subscriptions/[^/]*/resourceGroups/[^/]*/providers/Microsoft.CognitiveServices/accounts/[^/]*$"),
                    MaxLength: 1024
                },
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetResourceRegion: {
                constraints: {
                    Pattern: new RegExp("^[a-z0-9]+$"),
                    MaxLength: 24,
                    MinLength: 1
                },
                serializedName: "targetResourceRegion",
                required: true,
                type: {
                    name: "String"
                }
            },
            copyAuthorization: {
                serializedName: "copyAuthorization",
                type: {
                    name: "Composite",
                    className: "CopyAuthorizationResult"
                }
            }
        }
    }
};
const CopyAuthorizationResult = {
    type: {
        name: "Composite",
        className: "CopyAuthorizationResult",
        modelProperties: {
            modelId: {
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                required: true,
                type: {
                    name: "String"
                }
            },
            expirationDateTimeTicks: {
                serializedName: "expirationDateTimeTicks",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CopyOperationResult = {
    type: {
        name: "Composite",
        className: "CopyOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["notStarted", "running", "succeeded", "failed"]
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            copyResult: {
                serializedName: "copyResult",
                type: {
                    name: "Composite",
                    className: "CopyResult"
                }
            }
        }
    }
};
const CopyResult = {
    type: {
        name: "Composite",
        className: "CopyResult",
        modelProperties: {
            modelId: {
                serializedName: "modelId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorInformation"
                        }
                    }
                }
            }
        }
    }
};
const ComposeRequest = {
    type: {
        name: "Composite",
        className: "ComposeRequest",
        modelProperties: {
            modelIds: {
                serializedName: "modelIds",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Uuid"
                        }
                    }
                }
            },
            modelName: {
                serializedName: "modelName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Models = {
    type: {
        name: "Composite",
        className: "Models",
        modelProperties: {
            summary: {
                serializedName: "summary",
                type: {
                    name: "Composite",
                    className: "ModelsSummary"
                }
            },
            modelList: {
                serializedName: "modelList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ModelInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ModelsSummary = {
    type: {
        name: "Composite",
        className: "ModelsSummary",
        modelProperties: {
            count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            lastModified: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GeneratedClientTrainCustomModelAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientTrainCustomModelAsyncHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeWithCustomModelHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeWithCustomModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientCopyCustomModelHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientCopyCustomModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientGenerateModelCopyAuthorizationHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientGenerateModelCopyAuthorizationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientComposeCustomModelsAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientComposeCustomModelsAsyncHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeBusinessCardAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeBusinessCardAsyncHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeInvoiceAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeInvoiceAsyncHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeIdDocumentAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeIdDocumentAsyncHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeReceiptAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeReceiptAsyncHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientAnalyzeLayoutAsyncHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeLayoutAsyncHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TrainRequest: TrainRequest,
    TrainSourceFilter: TrainSourceFilter,
    ErrorResponse: ErrorResponse,
    ErrorInformation: ErrorInformation,
    Model: Model,
    ModelInfo: ModelInfo,
    Attributes: Attributes,
    KeysResult: KeysResult,
    TrainResult: TrainResult,
    TrainingDocumentInfo: TrainingDocumentInfo,
    FormFieldsReport: FormFieldsReport,
    SourcePath: SourcePath,
    AnalyzeOperationResult: AnalyzeOperationResult,
    AnalyzeResult: AnalyzeResult,
    ReadResult: ReadResult,
    TextLine: TextLine,
    TextWord: TextWord,
    TextAppearance: TextAppearance,
    TextStyle: TextStyle,
    SelectionMark: SelectionMark,
    PageResult: PageResult,
    KeyValuePair: KeyValuePair,
    KeyValueElement: KeyValueElement,
    DataTable: DataTable,
    DataTableCell: DataTableCell,
    DocumentResult: DocumentResult,
    FieldValue: FieldValue,
    CopyRequest: CopyRequest,
    CopyAuthorizationResult: CopyAuthorizationResult,
    CopyOperationResult: CopyOperationResult,
    CopyResult: CopyResult,
    ComposeRequest: ComposeRequest,
    Models: Models,
    ModelsSummary: ModelsSummary,
    GeneratedClientTrainCustomModelAsyncHeaders: GeneratedClientTrainCustomModelAsyncHeaders,
    GeneratedClientAnalyzeWithCustomModelHeaders: GeneratedClientAnalyzeWithCustomModelHeaders,
    GeneratedClientCopyCustomModelHeaders: GeneratedClientCopyCustomModelHeaders,
    GeneratedClientGenerateModelCopyAuthorizationHeaders: GeneratedClientGenerateModelCopyAuthorizationHeaders,
    GeneratedClientComposeCustomModelsAsyncHeaders: GeneratedClientComposeCustomModelsAsyncHeaders,
    GeneratedClientAnalyzeBusinessCardAsyncHeaders: GeneratedClientAnalyzeBusinessCardAsyncHeaders,
    GeneratedClientAnalyzeInvoiceAsyncHeaders: GeneratedClientAnalyzeInvoiceAsyncHeaders,
    GeneratedClientAnalyzeIdDocumentAsyncHeaders: GeneratedClientAnalyzeIdDocumentAsyncHeaders,
    GeneratedClientAnalyzeReceiptAsyncHeaders: GeneratedClientAnalyzeReceiptAsyncHeaders,
    GeneratedClientAnalyzeLayoutAsyncHeaders: GeneratedClientAnalyzeLayoutAsyncHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const trainRequest = {
    parameterPath: "trainRequest",
    mapper: TrainRequest
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const modelId = {
    parameterPath: "modelId",
    mapper: {
        serializedName: "modelId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const includeKeys = {
    parameterPath: ["options", "includeKeys"],
    mapper: {
        serializedName: "includeKeys",
        type: {
            name: "Boolean"
        }
    }
};
const contentType1 = {
    parameterPath: "contentType",
    mapper: {
        serializedName: "Content-Type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: [
                "application/pdf",
                "image/bmp",
                "image/jpeg",
                "image/png",
                "image/tiff"
            ]
        }
    }
};
const fileStream = {
    parameterPath: "fileStream",
    mapper: {
        serializedName: "fileStream",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType2 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const fileStream1 = {
    parameterPath: ["options", "fileStream"],
    mapper: SourcePath
};
const includeTextDetails = {
    parameterPath: ["options", "includeTextDetails"],
    mapper: {
        serializedName: "includeTextDetails",
        type: {
            name: "Boolean"
        }
    }
};
const pages = {
    parameterPath: ["options", "pages"],
    mapper: {
        serializedName: "pages",
        type: {
            name: "Sequence",
            element: {
                constraints: {
                    Pattern: new RegExp("(^[0-9]+-[0-9]+$)|(^[0-9]+$)")
                },
                type: {
                    name: "String"
                }
            }
        }
    }
};
const resultId = {
    parameterPath: "resultId",
    mapper: {
        serializedName: "resultId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const copyRequest = {
    parameterPath: "copyRequest",
    mapper: CopyRequest
};
const composeRequest = {
    parameterPath: "composeRequest",
    mapper: ComposeRequest
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const locale = {
    parameterPath: ["options", "locale"],
    mapper: {
        serializedName: "locale",
        type: {
            name: "String"
        }
    }
};
const language = {
    parameterPath: ["options", "language"],
    mapper: {
        serializedName: "language",
        type: {
            name: "String"
        }
    }
};
const readingOrder = {
    parameterPath: ["options", "readingOrder"],
    mapper: {
        defaultValue: "basic",
        serializedName: "readingOrder",
        type: {
            name: "Enum",
            allowedValues: ["basic", "natural"]
        }
    }
};
const op = {
    parameterPath: "op",
    mapper: {
        defaultValue: "full",
        isConstant: true,
        serializedName: "op",
        type: {
            name: "String"
        }
    }
};
const op1 = {
    parameterPath: "op",
    mapper: {
        defaultValue: "summary",
        isConstant: true,
        serializedName: "op",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/ai-form-recognizer";
const packageVersion = "3.1.0";
/** @hidden */
class GeneratedClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}/formrecognizer/v2.1";
        // Parameter assignments
        this.endpoint = endpoint;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @hidden */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Create and train a custom model. The request must include a source parameter that is either an
     * externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or
     * valid path to a data folder in a locally mounted drive. When local paths are specified, they must
     * follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration
     * setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source
     * path would be '/input/contosodataset'. All data to be trained is expected to be under the source
     * folder or sub folders under it. Models are trained using documents that are of the following content
     * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Other type of
     * content is ignored.
     * @param trainRequest Training request parameters.
     * @param options The options parameters.
     */
    trainCustomModelAsync(trainRequest, options) {
        const operationArguments = {
            trainRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, trainCustomModelAsyncOperationSpec);
    }
    /**
     * Get detailed information about a custom model.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    getCustomModel(modelId, options) {
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelOperationSpec);
    }
    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    deleteCustomModel(modelId, options) {
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCustomModelOperationSpec);
    }
    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must
     * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',
     * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri
     * or local path) of the document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeWithCustomModel(...args) {
        let operationSpec;
        let operationArguments;
        if (args[1] === "application/pdf" ||
            args[1] === "image/bmp" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeWithCustomModel$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                fileStream: args[2],
                options: args[3]
            };
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeWithCustomModel$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Obtain current status and the result of the analyze form operation.
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeFormResult(modelId, resultId, options) {
        const operationArguments = {
            modelId,
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeFormResultOperationSpec);
    }
    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer
     * resource.
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param options The options parameters.
     */
    copyCustomModel(modelId, copyRequest, options) {
        const operationArguments = {
            modelId,
            copyRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, copyCustomModelOperationSpec);
    }
    /**
     * Obtain current status and the result of a custom model copy operation.
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param options The options parameters.
     */
    getCustomModelCopyResult(modelId, resultId, options) {
        const operationArguments = {
            modelId,
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelCopyResultOperationSpec);
    }
    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * @param options The options parameters.
     */
    generateModelCopyAuthorization(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, generateModelCopyAuthorizationOperationSpec);
    }
    /**
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * @param composeRequest Compose models
     * @param options The options parameters.
     */
    composeCustomModelsAsync(composeRequest, options) {
        const operationArguments = {
            composeRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, composeCustomModelsAsyncOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given business card document. The input document must
     * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',
     * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location
     * (Uri) of the document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeBusinessCardAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeBusinessCardAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeBusinessCardAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze business card operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeBusinessCardResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeBusinessCardResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given invoice document. The input document must be of
     * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeInvoiceAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeInvoiceAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeInvoiceAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze invoice operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeInvoiceResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeInvoiceResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given ID document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeIdDocumentAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeIdDocumentAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeIdDocumentAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze ID operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeIdDocumentResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeIdDocumentResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of
     * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeReceiptAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeReceiptAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeReceiptAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeReceiptResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeReceiptResultOperationSpec);
    }
    /**
     * Extract text and layout information from a given document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeLayoutAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeLayoutAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeLayoutAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze layout operation
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeLayoutResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeLayoutResultOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    listCustomModels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, listCustomModelsOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    getCustomModels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelsOperationSpec);
    }
    /**
     * ListCustomModelsNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomModels method.
     * @param options The options parameters.
     */
    listCustomModelsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, listCustomModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const trainCustomModelAsyncOperationSpec = {
    path: "/custom/models",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: GeneratedClientTrainCustomModelAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: trainRequest,
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Model
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [includeKeys],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept],
    serializer
};
const deleteCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, modelId],
    headerParameters: [accept],
    serializer
};
const analyzeWithCustomModel$binaryOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [includeTextDetails, pages],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeWithCustomModel$jsonOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [includeTextDetails, pages],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeFormResultOperationSpec = {
    path: "/custom/models/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, modelId, resultId],
    headerParameters: [accept],
    serializer
};
const copyCustomModelOperationSpec = {
    path: "/custom/models/{modelId}/copy",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientCopyCustomModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: copyRequest,
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getCustomModelCopyResultOperationSpec = {
    path: "/custom/models/{modelId}/copyResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CopyOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, modelId, resultId],
    headerParameters: [accept],
    serializer
};
const generateModelCopyAuthorizationOperationSpec = {
    path: "/custom/models/copyAuthorization",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CopyAuthorizationResult,
            headersMapper: GeneratedClientGenerateModelCopyAuthorizationHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer
};
const composeCustomModelsAsyncOperationSpec = {
    path: "/custom/models/compose",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: GeneratedClientComposeCustomModelsAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: composeRequest,
    urlParameters: [endpoint],
    headerParameters: [contentType, accept2],
    mediaType: "json",
    serializer
};
const analyzeBusinessCardAsync$binaryOperationSpec = {
    path: "/prebuilt/businessCard/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeBusinessCardAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeBusinessCardAsync$jsonOperationSpec = {
    path: "/prebuilt/businessCard/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeBusinessCardAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeBusinessCardResultOperationSpec = {
    path: "/prebuilt/businessCard/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, resultId],
    headerParameters: [accept],
    serializer
};
const analyzeInvoiceAsync$binaryOperationSpec = {
    path: "/prebuilt/invoice/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeInvoiceAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeInvoiceAsync$jsonOperationSpec = {
    path: "/prebuilt/invoice/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeInvoiceAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeInvoiceResultOperationSpec = {
    path: "/prebuilt/invoice/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, resultId],
    headerParameters: [accept],
    serializer
};
const analyzeIdDocumentAsync$binaryOperationSpec = {
    path: "/prebuilt/idDocument/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeIdDocumentAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [includeTextDetails, pages],
    urlParameters: [endpoint],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeIdDocumentAsync$jsonOperationSpec = {
    path: "/prebuilt/idDocument/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeIdDocumentAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [includeTextDetails, pages],
    urlParameters: [endpoint],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeIdDocumentResultOperationSpec = {
    path: "/prebuilt/idDocument/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, resultId],
    headerParameters: [accept],
    serializer
};
const analyzeReceiptAsync$binaryOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeReceiptAsync$jsonOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [
        includeTextDetails,
        pages,
        locale
    ],
    urlParameters: [endpoint],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeReceiptResultOperationSpec = {
    path: "/prebuilt/receipt/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, resultId],
    headerParameters: [accept],
    serializer
};
const analyzeLayoutAsync$binaryOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream,
    queryParameters: [
        pages,
        language,
        readingOrder
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType1, accept1],
    mediaType: "binary",
    serializer
};
const analyzeLayoutAsync$jsonOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: fileStream1,
    queryParameters: [
        pages,
        language,
        readingOrder
    ],
    urlParameters: [endpoint],
    headerParameters: [accept, contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeLayoutResultOperationSpec = {
    path: "/layout/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [endpoint, resultId],
    headerParameters: [accept],
    serializer
};
const listCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Models
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [op],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer
};
const getCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Models
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [op1],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer
};
const listCustomModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Models
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [op],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept],
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits until a model has been trained.
 */
class BeginRecognizeContentPoller extends coreLro.Poller {
    constructor(options) {
        const { client, source, contentType, updateIntervalInMs = 5000, resultId, onProgress, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginRecognizePollOperation(Object.assign(Object.assign({}, state), { client,
            source,
            contentType,
            resultId, status: "notStarted", analyzeOptions: options }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return coreHttp.delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @internal
 */
function makeBeginRecognizePollOperation(state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            var _a;
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const pollerState = this.state;
                const { client, source, contentType, analyzeOptions } = pollerState;
                if (!pollerState.isStarted) {
                    if (!source) {
                        throw new Error("Expect a valid 'source'");
                    }
                    pollerState.isStarted = true;
                    const result = yield client.beginRecognize(source, contentType, analyzeOptions || {});
                    if (!result.operationLocation) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.operationLocation.lastIndexOf("/");
                    pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);
                    // source is no longer needed
                    pollerState.source = undefined;
                }
                const response = yield client.getRecognizeResult(pollerState.resultId, {
                    abortSignal: analyzeOptions === null || analyzeOptions === void 0 ? void 0 : analyzeOptions.abortSignal
                });
                pollerState.status = response.status;
                if (!pollerState.isCompleted) {
                    if (typeof options.fireProgress === "function") {
                        options.fireProgress(pollerState);
                    }
                    if (response.status === "succeeded") {
                        pollerState.result = response.pages;
                        pollerState.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Content recognition failed.
Error(s):
${errors || ""}
`;
                        throw new Error(message);
                    }
                }
                return makeBeginRecognizePollOperation(pollerState);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client" || key === "source") {
                    return undefined;
                }
                return value;
            });
        }
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toBoundingBox(original) {
    return [
        { x: original[0], y: original[1] },
        { x: original[2], y: original[3] },
        { x: original[4], y: original[5] },
        { x: original[6], y: original[7] }
    ];
}
function toTextLine(original, pageNumber) {
    const appearance = original.appearance !== undefined
        ? {
            styleName: original.appearance.style.name,
            styleConfidence: original.appearance.style.confidence
        }
        : undefined;
    const line = {
        kind: "line",
        pageNumber,
        text: original.text,
        boundingBox: toBoundingBox(original.boundingBox),
        appearance,
        words: original.words.map((w) => {
            return {
                kind: "word",
                text: w.text,
                boundingBox: toBoundingBox(w.boundingBox),
                confidence: w.confidence || 1,
                pageNumber
            };
        })
    };
    return line;
}
function toSelectionMark(original, pageNumber) {
    return {
        kind: "selectionMark",
        pageNumber,
        boundingBox: toBoundingBox(original.boundingBox),
        confidence: original.confidence,
        state: original.state
    };
}
function toFormPage(original) {
    var _a, _b;
    return {
        pageNumber: original.pageNumber,
        textAngle: original.angle,
        width: original.width,
        height: original.height,
        unit: original.unit,
        lines: (_a = original.lines) === null || _a === void 0 ? void 0 : _a.map((l) => toTextLine(l, original.pageNumber)),
        selectionMarks: (_b = original.selectionMarks) === null || _b === void 0 ? void 0 : _b.map((m) => toSelectionMark(m, original.pageNumber))
    };
}
// Note: might need to support other element types in future, e.g., checkbox
const textPattern = /\/readResults\/(\d+)\/lines\/(\d+)(?:\/words\/(\d+))?/;
function toFormContent(element, readResults) {
    const result = textPattern.exec(element);
    if (!result || !result[0] || !result[1] || !result[2]) {
        throw new Error(`Unexpected element reference encountered: ${element}`);
    }
    const readIndex = Number.parseInt(result[1]);
    const lineIndex = Number.parseInt(result[2]);
    if (result[3]) {
        const wordIndex = Number.parseInt(result[3]);
        return readResults[readIndex].lines[lineIndex].words[wordIndex];
    }
    else {
        return readResults[readIndex].lines[lineIndex];
    }
}
function toFieldData(pageNumber, original, readResults) {
    var _a;
    return {
        pageNumber,
        text: original.text,
        boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
        fieldElements: (_a = original.elements) === null || _a === void 0 ? void 0 : _a.map((element) => toFormContent(element, readResults))
    };
}
function toFormFieldFromKeyValuePairModel(pageNumber, original, readResults) {
    return {
        name: original.label,
        confidence: original.confidence || 1,
        labelData: toFieldData(pageNumber, original.key, readResults),
        valueData: toFieldData(pageNumber, original.value, readResults),
        value: original.value.text,
        valueType: "string"
    };
}
function toFormTable(original, readResults, pageNumber) {
    return {
        rowCount: original.rows,
        columnCount: original.columns,
        boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
        cells: original.cells.map((cell) => {
            var _a, _b, _c, _d, _e, _f;
            return ({
                boundingBox: toBoundingBox(cell.boundingBox),
                columnIndex: cell.columnIndex,
                fieldElements: (_a = cell.elements) === null || _a === void 0 ? void 0 : _a.map((element) => toFormContent(element, readResults)),
                rowIndex: cell.rowIndex,
                columnSpan: (_b = cell.columnSpan) !== null && _b !== void 0 ? _b : 1,
                rowSpan: (_c = cell.rowSpan) !== null && _c !== void 0 ? _c : 1,
                isHeader: (_d = cell.isHeader) !== null && _d !== void 0 ? _d : false,
                isFooter: (_e = cell.isFooter) !== null && _e !== void 0 ? _e : false,
                confidence: (_f = cell.confidence) !== null && _f !== void 0 ? _f : 1,
                text: cell.text,
                pageNumber
            });
        }),
        pageNumber
    };
}
function toFormPages(readResults, pageResults) {
    var _a;
    const transformed = readResults === null || readResults === void 0 ? void 0 : readResults.map(toFormPage);
    // maps from page numbers to the objects
    const pageMap = new Map(pageResults === null || pageResults === void 0 ? void 0 : pageResults.map((r) => [r.pageNumber, r]));
    return ((_a = transformed === null || transformed === void 0 ? void 0 : transformed.map((page) => {
        var _a, _b;
        const { pageNumber } = page;
        const pageResult = pageMap.get(pageNumber);
        return Object.assign(Object.assign({}, page), { tables: (_b = (_a = pageResult === null || pageResult === void 0 ? void 0 : pageResult.tables) === null || _a === void 0 ? void 0 : _a.map((table) => toFormTable(table, transformed, pageNumber))) !== null && _b !== void 0 ? _b : [] });
    })) !== null && _a !== void 0 ? _a : []);
}
function toRecognizedFormArray(original, expectedDocTypePrefix) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const pages = toFormPages((_a = original.analyzeResult) === null || _a === void 0 ? void 0 : _a.readResults, (_b = original.analyzeResult) === null || _b === void 0 ? void 0 : _b.pageResults);
    if ((_d = (_c = original.analyzeResult) === null || _c === void 0 ? void 0 : _c.documentResults) === null || _d === void 0 ? void 0 : _d.length) {
        // supervised/prebuilt results come from documentResults
        return ((_h = (_g = (_f = (_e = original.analyzeResult) === null || _e === void 0 ? void 0 : _e.documentResults) === null || _f === void 0 ? void 0 : _f.filter((d) => !!d.fields)) === null || _g === void 0 ? void 0 : _g.map((d) => {
            if (expectedDocTypePrefix !== undefined && !d.docType.startsWith(expectedDocTypePrefix)) {
                throw new RangeError(`Expected document type to start with '${expectedDocTypePrefix}', but found '${d.docType}'.`);
            }
            return toRecognizedForm(d, pages);
        })) !== null && _h !== void 0 ? _h : []);
    }
    else {
        // unsupervised results from from pageResults;
        return (_l = (_k = (_j = original.analyzeResult) === null || _j === void 0 ? void 0 : _j.pageResults) === null || _k === void 0 ? void 0 : _k.map((p) => toFormFromPageResult(p, pages))) !== null && _l !== void 0 ? _l : [];
    }
}
function toFormFieldFromFieldValueModel(original, key, readResults) {
    var _a, _b, _c;
    let value;
    function unreachable(v) {
        throw new Error(`Encountered unknown field value type: ${v}`);
    }
    switch (original.type) {
        case "string":
            value = original.valueString;
            break;
        case "date":
            value = original.valueDate;
            break;
        case "time":
            value = original.valueTime;
            break;
        case "integer":
            value = original.valueInteger;
            break;
        case "number":
            value = original.valueNumber;
            break;
        case "phoneNumber":
            value = original.valuePhoneNumber;
            break;
        case "selectionMark":
            value = original.valueSelectionMark;
            break;
        case "array":
            value = (_a = original.valueArray) === null || _a === void 0 ? void 0 : _a.map((fieldValueModel) => toFormFieldFromFieldValueModel(fieldValueModel, key, readResults));
            break;
        case "object":
            value = original.valueObject
                ? toFieldsFromFieldValue(original.valueObject, readResults)
                : undefined;
            break;
        case "countryRegion":
            value = original.valueCountryRegion;
            break;
        default:
            return unreachable(original.type);
    }
    return {
        confidence: original.confidence || 1,
        name: key,
        valueData: {
            pageNumber: (_b = original.pageNumber) !== null && _b !== void 0 ? _b : 0,
            text: original.text,
            boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
            fieldElements: (_c = original.elements) === null || _c === void 0 ? void 0 : _c.map((element) => toFormContent(element, readResults))
        },
        valueType: original.type,
        value
    };
}
function toFieldsFromFieldValue(original, readResults) {
    const result = {};
    for (const key in original) {
        if (Object.prototype.hasOwnProperty.call(original, key)) {
            if (!original[key]) {
                result[key] = { name: key };
                continue;
            }
            const formField = toFormFieldFromFieldValueModel(original[key], key, readResults);
            result[key] = formField;
        }
    }
    return result;
}
function toFieldsFromKeyValuePairs(pageNumber, original, pages) {
    const result = {};
    for (let i = 0; i < original.length; i++) {
        const pair = original[i];
        const stringField = toFormFieldFromKeyValuePairModel(pageNumber, pair, pages);
        stringField.name = stringField.name || `field-${i}`;
        result[`field-${i}`] = stringField;
    }
    return result;
}
function toFormFromPageResult(original, pages) {
    return {
        formType: `form-${original.clusterId}`,
        pageRange: { firstPageNumber: original.pageNumber, lastPageNumber: original.pageNumber },
        pages: pages.filter((p) => p.pageNumber === original.pageNumber),
        fields: original.keyValuePairs
            ? toFieldsFromKeyValuePairs(original.pageNumber, original.keyValuePairs, pages)
            : {}
    };
}
function toRecognizedForm(original, pages) {
    return {
        formType: original.docType,
        formTypeConfidence: original.docTypeConfidence,
        modelId: original.modelId,
        pageRange: { firstPageNumber: original.pageRange[0], lastPageNumber: original.pageRange[1] },
        fields: toFieldsFromFieldValue(original.fields, pages),
        pages: pages.filter((p) => original.pageRange[0] <= p.pageNumber && p.pageNumber <= original.pageRange[1])
    };
}
function toRecognizeContentResultResponse(original) {
    var _a;
    function toRecognizeContentResult(model) {
        if (!model) {
            return undefined;
        }
        const pages = toFormPages(model.readResults, model.pageResults);
        return {
            version: model.version,
            pages: pages
        };
    }
    const common = {
        status: original.status,
        createdOn: original.createdOn,
        errors: (_a = original.analyzeResult) === null || _a === void 0 ? void 0 : _a.errors,
        lastModified: original.lastModified,
        _response: original._response
    };
    if (original.status === "succeeded") {
        return Object.assign(Object.assign({}, common), toRecognizeContentResult(original.analyzeResult));
    }
    else {
        return common;
    }
}
function flattenTrainingDocuments(original) {
    if (original.composedTrainResults) {
        // Composed model, need to zip the training documents into a flat array and add modelID correlation.
        const mappedResultDocuments = original.composedTrainResults.map((innerResult) => innerResult.trainingDocuments.map((info) => {
            var _a;
            return (Object.assign(Object.assign({}, info), { modelId: innerResult.modelId, errors: (_a = info.errors) !== null && _a !== void 0 ? _a : [] }));
        }));
        return [].concat(...mappedResultDocuments);
    }
    else if (original.trainResult) {
        // Normal training scenario with only one trainResult
        return original.trainResult.trainingDocuments.map((info) => {
            var _a;
            return (Object.assign(Object.assign({}, info), { modelId: original.modelInfo.modelId, errors: (_a = info.errors) !== null && _a !== void 0 ? _a : [] }));
        });
    }
    return undefined;
}
function toSubmodelsFromComposedTrainResults(results) {
    const mappedSubmodels = results.map((r) => toSubmodelsFromTrainResultLabeled(r));
    // Flatten the array
    return [].concat(...mappedSubmodels);
}
function toSubmodelsFromTrainResultLabeled(result, modelName) {
    var _a, _b;
    return [
        {
            modelId: result.modelId,
            accuracy: result.averageModelAccuracy,
            formType: `custom:${modelName !== null && modelName !== void 0 ? modelName : result.modelId}`,
            fields: (_b = (_a = result.fields) === null || _a === void 0 ? void 0 : _a.reduce((fields, field) => {
                fields[field.fieldName] = {
                    name: field.fieldName,
                    accuracy: field.accuracy,
                    label: null
                };
                return fields;
            }, {})) !== null && _b !== void 0 ? _b : {}
        }
    ];
}
function toSubmodelsFromTrainResultUnlabeled(keys, modelId) {
    // Each cluster becomes a submodel
    return Object.entries(keys.clusters).map(([clusterKey, cluster]) => ({
        modelId,
        // Create formType from the key of the cluster
        formType: `form-${clusterKey}`,
        // Roll the fields up into the correct shape
        fields: cluster.reduce((fields, label, idx) => {
            fields[`field-${idx}`] = {
                name: `field-${idx}`,
                label
            };
            return fields;
        }, {})
    }));
}
function flattenCustomFormSubmodels(original) {
    var _a, _b;
    if (original.modelInfo.status === "ready") {
        if (original.composedTrainResults !== undefined) {
            return toSubmodelsFromComposedTrainResults(original.composedTrainResults);
        }
        else if (((_a = original.trainResult) === null || _a === void 0 ? void 0 : _a.fields) || ((_b = original.trainResult) === null || _b === void 0 ? void 0 : _b.averageModelAccuracy)) {
            return toSubmodelsFromTrainResultLabeled(original.trainResult, original.modelInfo.modelName);
        }
        else if (original.keys) {
            return toSubmodelsFromTrainResultUnlabeled(original.keys, original.modelInfo.modelId);
        }
        else {
            throw new Error("No submodel information was found in the training response.");
        }
    }
    return undefined;
}
function toCustomFormModelProperties(original) {
    if (original) {
        return {
            isComposedModel: original.isComposed
        };
    }
    else {
        return undefined;
    }
}
function toFormModelResponse(response) {
    var _a;
    return {
        status: response.modelInfo.status,
        modelId: response.modelInfo.modelId,
        modelName: response.modelInfo.modelName,
        trainingStartedOn: response.modelInfo.trainingStartedOn,
        trainingCompletedOn: response.modelInfo.trainingCompletedOn,
        trainingDocuments: flattenTrainingDocuments(response),
        properties: toCustomFormModelProperties(response.modelInfo.attributes),
        errors: (_a = response.trainResult) === null || _a === void 0 ? void 0 : _a.errors,
        submodels: flattenCustomFormSubmodels(response),
        _response: response._response
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Create a form recognition poll operation.
 *
 * This operation handles the creation, polling, and transformation of results.
 *
 * @internal
 */
function makeFormRecognitionOperation(description, initialState) {
    const self = {
        state: Object.assign({}, initialState),
        cancel() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                throw new Error("The cancel operation is not supported on this poller.");
            });
        },
        update(options) {
            var _a, _b, _c, _d;
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { isStarted, isCompleted, modelId, expectedDocType } = self.state;
                if (!isStarted || !self.state.resultId) {
                    self.state.resultId = yield description.createOperation();
                    self.state.isStarted = true;
                }
                const response = yield description.getResult(self.state.resultId, modelId);
                self.state.status = response.status;
                if (!isCompleted) {
                    // eslint-disable-next-line no-unused-expressions
                    (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, Object.assign({}, self.state));
                    if (response.status === "succeeded") {
                        self.state.result = toRecognizedFormArray(response, (expectedDocType === null || expectedDocType === void 0 ? void 0 : expectedDocType.startsWith("prebuilt:")) ? expectedDocType : undefined);
                        self.state.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        throw new Error([
                            `Failed to recognize forms using the model "${description.modelId}"`,
                            "Error(s):",
                            ...((_d = (_c = (_b = response.analyzeResult) === null || _b === void 0 ? void 0 : _b.errors) === null || _c === void 0 ? void 0 : _c.map((e) => `  Code ${e.code}, message: '${e.message}'`)) !== null && _d !== void 0 ? _d : ["  <empty>"])
                        ].join("\n"));
                    }
                }
                return self;
            });
        },
        // Maintaining the depth of "state" in the serialized poller is
        // important for maintaining compatibility with previous versions
        toString: () => JSON.stringify({ state: self.state })
    };
    return self;
}
const DEFAULT_POLLING_INTERVAL = 5000;
/**
 * A poller for Form Recognition that works for all analysis endpoints
 * that return the basic, weakly-typed `RecognizedFormArray` type.
 */
class FormRecognitionPoller extends coreLro.Poller {
    constructor(description) {
        const state = description.resumeFrom
            ? JSON.parse(description.resumeFrom).state
            : {
                modelId: description.modelId,
                status: "notStarted",
                expectedDocType: description.expectedDocType
            };
        super(makeFormRecognitionOperation(description, state));
        if (typeof description.onProgress === "function") {
            this.onProgress(description.onProgress);
        }
        this.options = description;
    }
    /**
     * Delay the poller
     */
    delay() {
        var _a;
        return coreHttp.delay((_a = this.options.updateIntervalInMs) !== null && _a !== void 0 ? _a : DEFAULT_POLLING_INTERVAL);
    }
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Form Recognizer
 */
function createFormRecognizerAzureKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new FormRecognizerAzureKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for Azure Form Recognizer
 */
class FormRecognizerAzureKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// #endregion
/**
 * Client class for interacting with the Azure Form Recognizer service.
 */
class FormRecognizerClient {
    /**
     * Creates an instance of FormRecognizerClient.
     *
     * Example usage:
     * ```ts
     * import { FormRecognizerClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormRecognizerClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     *
     * @param endpointUrl - Url to an Azure Form Recognizer service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const pipelineOptions = tslib.__rest(options, []);
        const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createFormRecognizerAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,
                allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    // #region content
    /**
     * Recognizes content, including text and table structure from a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_7.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContent(readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     * Recognizes content/layout information from a given document
     * @param form - Input document
     * @param options - Options to start content recognition operation
     */
    beginRecognizeContent(form, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const client = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            const poller = new BeginRecognizeContentPoller(Object.assign({ client, source: form }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes content, including text and table structure from a url to a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContentFromUrl(url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     *
     * Recognizes content/layout information from a url to a form document
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the content recognition operation
     */
    beginRecognizeContentFromUrl(formUrl, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const client = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const poller = new BeginRecognizeContentPoller(Object.assign(Object.assign({ client, source: formUrl }, options), { contentType: undefined }));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves result of content recognition operation.
     * @internal
     */
    getRecognizedContent(resultId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormRecognizerClient-getRecognizedLayoutResult", realOptions);
            try {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(finalOptions);
                const analyzeResult = yield this.client.getAnalyzeLayoutResult(resultId, requestOptions);
                return toRecognizeContentResultResponse(analyzeResult);
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    // #endregion
    // #region customforms
    /**
     * Recognizes forms from a given document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_6.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomForms(modelId, readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     * Recognizes form information from a given document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param form - Input form document
     * @param options - Options to start the form recognition operation
     */
    beginRecognizeCustomForms(modelId, form, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid model id");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeCustomForms", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ modelId, createOperation: span("customFormsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(form);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeWithCustomModel(modelId, contentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getCustomForms", (finalOptions, resultId, modelIdParam) => tslib.__awaiter(this, void 0, void 0, function* () {
                    // using the modelId from the parameter here is important, as we could be restoring from
                    // a suspended LRO
                    return this.client.getAnalyzeFormResult(
                    // Must be defined to have reached this point, but only for custom form recognition
                    modelIdParam, resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes forms from a URL to a document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     *
     * Recognizes form information from a url to a document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeCustomFormsFromUrl(modelId, formUrl, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid model id");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeCustomForms", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ modelId, createOperation: span("customFormsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeWithCustomModel(modelId, "application/json", Object.assign({ fileStream: {
                            source: formUrl
                        } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getCustomForms", (finalOptions, resultId, modelIdParam) => tslib.__awaiter(this, void 0, void 0, function* () {
                    // using the modelId from the parameter here is important, as we could be restoring from
                    // a suspended LRO
                    return this.client.getAnalyzeFormResult(
                    // Must be defined to have reached this point, but only for custom form recognition
                    modelIdParam, resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::businesscard
    /**
     * Recognizes data from business cards using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./business-card-english.png";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCards(readStream, {
     *   contentType: "image/png",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given document
     * @param businessCard - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCards(businessCard, options = { includeFieldElements: false }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeBusinessCards", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:businesscard", createOperation: span("businessCardsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(businessCard);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeBusinessCardAsync(contentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getBusinessCards", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeBusinessCardResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes business card information from a url using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the business card document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCardsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given accessible url to a document
     * @param businessCardUrl - Url to a business card document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCardsFromUrl(businessCardUrl, options = { includeFieldElements: false }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeBusinessCardsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:businesscard", createOperation: span("businessCardsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeBusinessCardAsync("application/json", Object.assign({ fileStream: {
                            source: businessCardUrl
                        } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getBusinessCards", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeBusinessCardResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::invoice
    /**
     * Recognizes data from invoices using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_1.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoices(readStream, {
     *   contentType: "application/pdf",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given document
     * @param invoice - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoices(invoice, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeInvoices", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:invoice", createOperation: span("invoicesInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(invoice);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeInvoiceAsync(contentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getInvoices", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeInvoiceResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes invoice information from a URL using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the invoice document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoicesFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given accessible url to a document
     * @param invoiceUrl - Url to an invoice document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoicesFromUrl(invoiceUrl, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeInvoicesFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:invoice", createOperation: span("invoicesInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeInvoiceAsync("application/json", Object.assign({ fileStream: {
                            source: invoiceUrl
                        } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getInvoices", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeInvoiceResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::identityDocument
    /**
     * Recognizes data from identification documents using a pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     *
     * ```ts
     * const path = "./license.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocuments(readStream, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocument - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocuments(identityDocument, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeIdentityDocuments", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:idDocument", createOperation: span("identityDocumentsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(identityDocument);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeIdDocumentAsync(contentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getIdentityDocuments", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeIdDocumentResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes identity document information from a url using pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the identity document>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocumentsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocumentUrl - Url to an identity document that is accessible from
     * the service. Must be a valid, encoded URL to a document of a supported
     * content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocumentsFromUrl(identityDocumentUrl, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeIdentityDocumentsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:idDocument", createOperation: span("identityDocumentsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeIdDocumentAsync("application/json", Object.assign({ fileStream: {
                            source: identityDocumentUrl
                        } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getIdDocuments", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeIdDocumentResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::receipt
    /**
     * Recognizes data from receipts using a pre-built receipt model, enabling you to extract structured data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./contoso-allinone.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceipts(readStream, {
     *   contentType: "image/jpeg",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given document
     * @param receipt - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceipts(receipt, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeReceipts", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:receipt", createOperation: span("receiptsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(receipt);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeReceiptAsync(contentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getReceipts", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeReceiptResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the receipt document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceiptsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given accessible url to a document
     * @param receiptUrl - Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceiptsFromUrl(receiptUrl, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeReceiptsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:receipt", createOperation: span("receiptsInternal", (finalOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeReceiptAsync("application/json", Object.assign({ fileStream: {
                            source: receiptUrl
                        } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getReceipts", (finalOptions, resultId) => tslib.__awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeReceiptResult(resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
}
/**
 * Validates a remote operation's location is defined and extracts the
 * result ID from it.
 *
 * @param remoteOperation - The operation to process
 * @returns The remote operation ID
 *
 * @internal
 */
function processOperationLocation({ operationLocation }) {
    if (!operationLocation) {
        throw new Error("The service did not respond with an 'operationLocation' to retrieve results.");
    }
    else {
        const lastSlashIndex = operationLocation.lastIndexOf("/");
        return operationLocation.substring(lastSlashIndex + 1);
    }
}
/**
 * Helper function to create spans for internal polling handlers
 *
 * The argument is a handler function that will be wrapped in a tracing
 * span, where tracing-updated options will be inserted as its first parameter.
 *
 * @example
 * ```typescript
 * const spanned = makeSpanner("FormRecognizerClient-beginRecognizeReceipts", {
 *   ...options,
 *   // Override any options you need here
 * });
 *
 * const autoSpannedFunction = spanner("autoSpannedFunction", (updatedOptions) => {
 *  // ...
 * });
 * ```
 *
 * @internal
 */
function makeSpanner(prefix, options) {
    return {
        span: (name, handler) => (...args) => {
            const { span, updatedOptions } = createSpan(`${prefix}-${name}`, options);
            try {
                return handler(updatedOptions, ...args);
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        }
    };
}
/**
 * The worker function of layout analysis.
 *
 * @internal
 */
function recognizeLayoutInternal(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, body, contentType, options, _modelId) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const realOptions = options || {};
        const { span, updatedOptions: finalOptions } = createSpan("analyzeLayoutInternal", realOptions);
        const requestBody = yield toRequestBody(body);
        const requestContentType = contentType ? contentType : yield getContentType(requestBody);
        try {
            if (requestContentType) {
                return yield client.analyzeLayoutAsync(requestContentType, requestBody, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
            }
            return yield client.analyzeLayoutAsync("application/json", Object.assign({ fileStream: requestBody }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits until a model has been trained.
 */
class BeginTrainingPoller extends coreLro.Poller {
    constructor(options) {
        const { client, trainingInputs, updateIntervalInMs = 5000, onProgress, resumeFrom, trainModelOptions } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginTrainingPollOperation(client, Object.assign(Object.assign({}, state), { trainingInputs, status: "creating", trainModelOptions }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return coreHttp.delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @internal
 */
function makeBeginTrainingPollOperation(client, state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            var _a, _b;
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const pollerState = this.state;
                const { trainingInputs, trainModelOptions } = state;
                if (!pollerState.isStarted) {
                    pollerState.isStarted = true;
                    const result = yield client.trainCustomModelInternal(trainingInputs, false, trainModelOptions || {});
                    if (!result.location) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.location.lastIndexOf("/");
                    pollerState.modelId = result.location.substring(lastSlashIndex + 1);
                }
                const model = yield client.getCustomModel(pollerState.modelId, {
                    abortSignal: trainModelOptions === null || trainModelOptions === void 0 ? void 0 : trainModelOptions.abortSignal
                });
                pollerState.status = model.status;
                if (!pollerState.isCompleted) {
                    if (typeof options.fireProgress === "function") {
                        options.fireProgress(pollerState);
                    }
                    if (model.status === "ready") {
                        pollerState.result = model;
                        pollerState.isCompleted = true;
                    }
                    else if (model.status === "invalid") {
                        const errors = (_a = model.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const additionalInfo = (_b = model.trainingDocuments) === null || _b === void 0 ? void 0 : _b.map((d) => {
                            var _a;
                            return `  document: ${d.name}, status: ${d.status}, errors: ${(_a = d.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `code ${e.code}, message: '${e.message}'`).join("\n")}`;
                        }).join("\n");
                        const message = `Model training failed. Invalid model was created with id '${pollerState.modelId}'.
Error(s):
${errors || ""}
Additional information:
${additionalInfo || ""}
`;
                        throw new Error(message);
                    }
                }
                return makeBeginTrainingPollOperation(client, pollerState);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client") {
                    return undefined;
                }
                return value;
            });
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits until a model has been trained.
 */
class BeginCopyModelPoller extends coreLro.Poller {
    constructor(options) {
        const { client, updateIntervalInMs = 5000, modelId, resultId, targetResourceId, targetResourceRegion, copyAuthorization, onProgress, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginCopyModelPollOperation(Object.assign(Object.assign({}, state), { client,
            modelId,
            targetResourceId,
            targetResourceRegion,
            copyAuthorization,
            resultId, status: "notStarted", copyModelOptions: options }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return coreHttp.delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @internal
 */
function makeBeginCopyModelPollOperation(state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const pollerState = this.state;
                const { client, modelId, copyAuthorization, copyModelOptions } = pollerState;
                if (!pollerState.isStarted) {
                    pollerState.isStarted = true;
                    const result = yield client.beginCopyModel(modelId, copyAuthorization, copyModelOptions || {});
                    if (!result.operationLocation) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.operationLocation.lastIndexOf("/");
                    pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);
                }
                const response = yield client.getCopyModelResult(modelId, pollerState.resultId, {
                    abortSignal: copyModelOptions === null || copyModelOptions === void 0 ? void 0 : copyModelOptions.abortSignal
                });
                pollerState.status = response.status;
                if (!pollerState.isCompleted) {
                    if ((response.status === "running" || response.status === "notStarted") &&
                        typeof options.fireProgress === "function") {
                        options.fireProgress(pollerState);
                    }
                    else if (response.status === "succeeded") {
                        pollerState.result = {
                            status: "ready",
                            trainingStartedOn: response.createdOn,
                            trainingCompletedOn: response.lastModified,
                            modelId: copyAuthorization.modelId
                        };
                        pollerState.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        throw new Error(`Copy model operation failed: ${response._response.bodyAsText}`);
                    }
                }
                return makeBeginCopyModelPollOperation(pollerState);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client" || key === "source") {
                    return undefined;
                }
                return value;
            });
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Client class for training and managing custom form models.
 */
class FormTrainingClient {
    /**
     * Creates an instance of FormTrainingClient.
     *
     * Example usage:
     * ```ts
     * import {FormTrainingClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormTrainingClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - Url to an Azure Form Recognizer service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        this.credential = credential;
        this.clientOptions = options;
        const pipelineOptions = tslib.__rest(options, []);
        const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createFormRecognizerAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,
                allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    /**
     * Retrieves summary information about the cognitive service account
     *
     * @param options - Options to GetSummary operation
     */
    getAccountProperties(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-listCustomModels", realOptions);
            try {
                const result = yield this.client.getCustomModels(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                return {
                    customModelLimit: result.summary.limit,
                    customModelCount: result.summary.count
                };
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates an instance of {@link FormTrainingClient} to perform training operations
     * and to manage trained custom form models.
     */
    getFormRecognizerClient() {
        return new FormRecognizerClient(this.endpointUrl, this.credential, this.clientOptions);
    }
    /**
     * Mark model for deletion. Model artifacts will be permanently removed within 48 hours.
     *
     * @param modelId - Id of the model to mark for deletion
     * @param options - Options to the Delete Model operation
     */
    deleteModel(modelId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-deleteModel", realOptions);
            try {
                return yield this.client.deleteCustomModel(modelId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Get detailed information about a custom model from training.
     *
     * @param modelId - Id of the model to get information
     * @param options - Options to the Get Model operation
     */
    getCustomModel(modelId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-getCustomModel", realOptions);
            try {
                const response = yield this.client.getCustomModel(modelId, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)), { 
                    // Include keys is always set to true -- the service does not have a use case for includeKeys: false.
                    includeKeys: true }));
                return toFormModelResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listModelsPage(settings, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listModelsPage_1() {
            let result;
            if (settings.continuationToken) {
                result = yield tslib.__await(this.listNextPage(settings.continuationToken, options));
            }
            else {
                result = yield tslib.__await(this.list(options));
            }
            yield yield tslib.__await(result);
            while (result.nextLink) {
                result = yield tslib.__await(this.listNextPage(result.nextLink, options));
                yield yield tslib.__await(result);
            }
        });
    }
    listModelsAll(settings, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listModelsAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listModelsPage(settings, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page.modelList || [])));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list information about all models in the cognitive service account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const client = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     * const result = client.listCustomModels();
     * let i = 1;
     * for await (const model of result) {
     *   console.log(`model ${i++}:`);
     *   console.log(model);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = client.listCustomModels();
     * let modelItem = await iter.next();
     * while (!modelItem.done) {
     *   console.log(`model ${i++}: ${modelItem.value}`);
     *   modelItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     *  let i = 1;
     *  for await (const response of client.listCustomModels().byPage()) {
     *    for (const modelInfo of response.modelList!) {
     *      console.log(`model ${i++}: ${modelInfo.modelId}`);
     *    }
     *  }
     * ```
     *
     * @param options - Options to the List Models operation
     */
    listCustomModels(options = {}) {
        const iter = this.listModelsAll({}, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                return this.listModelsPage(settings, options);
            }
        };
    }
    list(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-list", realOptions);
            try {
                const result = yield this.client.listCustomModels(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listNextPage(nextLink, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-listNextPage", realOptions);
            try {
                const result = yield this.client.listCustomModelsNext(nextLink, Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates and trains a custom form model.
     *
     * If the `useTrainingLabels` parameter is set to `true`, then the operation will search
     * for label files in addition to the training documents, and it will create a labeled
     * model with the field names specified by the labels. Otherwise, it will create an
     * unlabeled model automatically that returns generated field names for the items it
     * determines are fields within the document structure.
     *
     * This method returns a long-running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Notes:
     * - The onProgress callback will not be invoked if the operation completes in the first
     *   request, and attempting to cancel a completed copy will result in an error being thrown.
     * - Even when the training operation fails, a model is still created in the Azure Form
     *   Recognizer resource.
     *
     * Example usage:
     * ```ts
     * const trainingFilesUrl = "<url to the blob container storing training documents>";
     * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     *
     * const poller = await trainingClient.beginTraining(trainingFilesUrl, false, {
     *   onProgress: (state) => { console.log("training status: "); console.log(state); }
     * });
     * const model = await poller.pollUntilDone();
     * ```
     *
     * Creates and trains a custom form model.
     * @param trainingFilesUrl - Accessible url to an Azure Storage Blob container storing the training documents and optional label files
     * @param useTrainingLabels - Specifies whether or not to search for and train using label files
     * @param options - Options to start the model training operation
     */
    beginTraining(trainingFilesUrl, useTrainingLabels, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const trainPollerClient = {
                getCustomModel: (modelId, optionsParam) => this.getCustomModel(modelId, optionsParam),
                trainCustomModelInternal: (source, _useLabelFile, optionsParam) => trainCustomModelInternal(this.client, source, useTrainingLabels, optionsParam)
            };
            const poller = new BeginTrainingPoller({
                client: trainPollerClient,
                trainingInputs: trainingFilesUrl,
                updateIntervalInMs: options.updateIntervalInMs,
                onProgress: options.onProgress,
                resumeFrom: options.resumeFrom,
                trainModelOptions: options
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Combines pre-existing models with labels into a single composed model.
     *
     * The composed model will contain copies of all of its input submodels, and it will
     * choose (using a machine learning algorithm) the most appropriate of its input models
     * to use during form recognition.
     *
     * This method returns a long-running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Notes:
     * - Only labeled models can be composed. Attempting to compose an unlabeled model will
     *   result in an error.
     * - the onProgress callback will not be invoked if the operation completes in the first
     *   request, and attempting to cancel a completed copy will result in an error being thrown.
     * - evena when the training operation fails, a model is still created in the Azure Form
     *   Recognizer resource.
     *
     * Example usage:
     * ```ts
     * const modelIds = ["<model ID 1>", "<model ID 2>", "<model ID 3>"];
     * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     *
     * const poller = await trainingClient.beginCreateComposedModel(modelIds, {
     *   modelName: "<optional name for the composed model>",
     *   onProgress: (state) => { console.log("training status: "); console.log(state); }
     * });
     * const composedModel = await poller.pollUntilDone();
     * ```
     *
     * Combines pre-existing models with labels into a single composed model.
     * @param modelIds - An array of model IDs within the Form Recognizer resouce to compose
     * @param options - Options to start the create composed model operation
     */
    beginCreateComposedModel(modelIds, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const composePollerClient = {
                getCustomModel: (modelId, optionsParam) => this.getCustomModel(modelId, optionsParam),
                trainCustomModelInternal: (sources, _, optionsParam) => composeModelInternal(this.client, sources, optionsParam)
            };
            const poller = new BeginTrainingPoller({
                client: composePollerClient,
                trainingInputs: modelIds,
                updateIntervalInMs: options.updateIntervalInMs,
                onProgress: options.onProgress,
                resumeFrom: options.resumeFrom,
                trainModelOptions: options
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generate an authorization for copying a custom model into this Azure Form Recognizer resource.
     *
     * This method should be called on a client that is authenticated using the target resource (where the
     * model will be copied to) credentials, and the output can be passed as the `target` parameter to the
     * `beginCopyModel` method of a source client.
     *
     * The required `resourceId` and `resourceRegion` are properties of an Azure Form Recognizer resource and their values can be found in the Azure Portal.
     *
     * @param resourceId - Id of the Azure Form Recognizer resource where a custom model will be copied to
     * @param resourceRegion - Location of the Azure Form Recognizer resource, must be a valid region name supported by Azure Cognitive Services. See https://aka.ms/azsdk/cognitiveservices/regionalavailability for information about the regional availability of Azure Cognitive Services.
     * @param options - Options to get copy authorization operation
     * @returns The authorization to copy a custom model
     */
    getCopyAuthorization(resourceId, resourceRegion, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-getCopyAuthorization", options);
            try {
                const response = (yield this.client.generateModelCopyAuthorization(coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
                return {
                    resourceId: resourceId,
                    resourceRegion: resourceRegion,
                    expiresOn: new Date(response.expirationDateTimeTicks * 1000),
                    modelId: response.modelId,
                    accessToken: response.accessToken
                };
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Copies a custom model from this resource (the source) to the specified target Form Recognizer resource.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const targetClient = new FormTrainingClient(targetEndpoint, new AzureKeyCredential(targetApiKey));
     * const authorization = await targetClient.getCopyAuthorization(targetResourceId, targetResourceRegion);
     *
     * const sourceClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await sourceClient.beginCopyModel(sourceModelId, authorization, {
     *   onProgress: (state) => {
     *     console.log(`Copy model status: ${state.status}`);
     *   }
     * });
     * const result = await poller.pollUntilDone();
     * ```
     * Copies custom model to target resource
     * @param modelId - Id of the custom model in this resource to be copied to the target Form Recognizer resource
     * @param target - Copy authorization produced by calling `targetTrainingClient.getCopyAuthorization()`
     * @param options - Options to copy model operation
     */
    beginCopyModel(modelId, target, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const copyModelClient = {
                beginCopyModel: (...args) => this.beginCopyModelInternal(...args),
                getCopyModelResult: (...args) => this.getCopyModelResult(...args)
            };
            const poller = new BeginCopyModelPoller(Object.assign({ client: copyModelClient, modelId, targetResourceId: target.resourceId, targetResourceRegion: target.resourceRegion, copyAuthorization: target, onProgress: options.onProgress, resumeFrom: options.resumeFrom }, options));
            yield poller.poll();
            return poller;
        });
    }
    beginCopyModelInternal(modelId, copyAuthorization, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-beginCopyModelInternal", options);
            try {
                return yield this.client.copyCustomModel(modelId, {
                    targetResourceId: copyAuthorization.resourceId,
                    targetResourceRegion: copyAuthorization.resourceRegion,
                    copyAuthorization: {
                        modelId: copyAuthorization.modelId,
                        accessToken: copyAuthorization.accessToken,
                        expirationDateTimeTicks: copyAuthorization.expiresOn.getTime() / 1000
                    }
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    getCopyModelResult(modelId, resultId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("FormTrainingClient-getCopyModelResult", options);
            try {
                return yield this.client.getCustomModelCopyResult(modelId, resultId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
/**
 * @internal
 */
function composeModelInternal(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, modelIds, options) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const { span, updatedOptions: finalOptions } = createSpan("composeModelInternal", options !== null && options !== void 0 ? options : {});
        try {
            return client.composeCustomModelsAsync({
                modelIds,
                modelName: options === null || options === void 0 ? void 0 : options.modelName
            }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}
/**
 * @internal
 */
function trainCustomModelInternal(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, source, useLabelFile, options) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const realOptions = options || {};
        const { span, updatedOptions: finalOptions } = createSpan("trainCustomModelInternal", realOptions);
        try {
            return client.trainCustomModelAsync({
                source: source,
                modelName: options === null || options === void 0 ? void 0 : options.modelName,
                sourceFilter: {
                    prefix: realOptions.prefix,
                    includeSubfolders: realOptions.includeSubfolders
                },
                useLabelFile
            }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link KeyValueType} that the service accepts. */
var KnownKeyValueType;
(function (KnownKeyValueType) {
    KnownKeyValueType["String"] = "string";
    KnownKeyValueType["SelectionMark"] = "selectionMark";
})(KnownKeyValueType || (KnownKeyValueType = {}));
/** Known values of {@link FieldValueSelectionMark} that the service accepts. */
var KnownFieldValueSelectionMark;
(function (KnownFieldValueSelectionMark) {
    KnownFieldValueSelectionMark["Selected"] = "selected";
    KnownFieldValueSelectionMark["Unselected"] = "unselected";
})(KnownFieldValueSelectionMark || (KnownFieldValueSelectionMark = {}));
(function (KnownFormLocale) {
    KnownFormLocale["EnAU"] = "en-AU";
    KnownFormLocale["EnCA"] = "en-CA";
    KnownFormLocale["EnGB"] = "en-GB";
    KnownFormLocale["EnIN"] = "en-IN";
    KnownFormLocale["EnUS"] = "en-US";
})(exports.KnownFormLocale || (exports.KnownFormLocale = {}));
(function (KnownFormLanguage) {
    KnownFormLanguage["Af"] = "af";
    KnownFormLanguage["Ast"] = "ast";
    KnownFormLanguage["Bi"] = "bi";
    KnownFormLanguage["Br"] = "br";
    KnownFormLanguage["Ca"] = "ca";
    KnownFormLanguage["Ceb"] = "ceb";
    KnownFormLanguage["Ch"] = "ch";
    KnownFormLanguage["Co"] = "co";
    KnownFormLanguage["Crh"] = "crh";
    KnownFormLanguage["Cs"] = "cs";
    KnownFormLanguage["Csb"] = "csb";
    KnownFormLanguage["Da"] = "da";
    KnownFormLanguage["De"] = "de";
    KnownFormLanguage["En"] = "en";
    KnownFormLanguage["Es"] = "es";
    KnownFormLanguage["Et"] = "et";
    KnownFormLanguage["Eu"] = "eu";
    KnownFormLanguage["Fi"] = "fi";
    KnownFormLanguage["Fil"] = "fil";
    KnownFormLanguage["Fj"] = "fj";
    KnownFormLanguage["Fr"] = "fr";
    KnownFormLanguage["Fur"] = "fur";
    KnownFormLanguage["Fy"] = "fy";
    KnownFormLanguage["Ga"] = "ga";
    KnownFormLanguage["Gd"] = "gd";
    KnownFormLanguage["Gil"] = "gil";
    KnownFormLanguage["Gl"] = "gl";
    KnownFormLanguage["Gv"] = "gv";
    KnownFormLanguage["Hni"] = "hni";
    KnownFormLanguage["Hsb"] = "hsb";
    KnownFormLanguage["Ht"] = "ht";
    KnownFormLanguage["Hu"] = "hu";
    KnownFormLanguage["Ia"] = "ia";
    KnownFormLanguage["Id"] = "id";
    KnownFormLanguage["It"] = "it";
    KnownFormLanguage["Iu"] = "iu";
    KnownFormLanguage["Ja"] = "ja";
    KnownFormLanguage["Jv"] = "jv";
    KnownFormLanguage["Kaa"] = "kaa";
    KnownFormLanguage["Kac"] = "kac";
    KnownFormLanguage["Kea"] = "kea";
    KnownFormLanguage["Kha"] = "kha";
    KnownFormLanguage["Kl"] = "kl";
    KnownFormLanguage["Ko"] = "ko";
    KnownFormLanguage["Ku"] = "ku";
    KnownFormLanguage["Kw"] = "kw";
    KnownFormLanguage["Lb"] = "lb";
    KnownFormLanguage["Ms"] = "ms";
    KnownFormLanguage["Mww"] = "mww";
    KnownFormLanguage["Nap"] = "nap";
    KnownFormLanguage["Nl"] = "nl";
    KnownFormLanguage["No"] = "no";
    KnownFormLanguage["Oc"] = "oc";
    KnownFormLanguage["Pl"] = "pl";
    KnownFormLanguage["Pt"] = "pt";
    KnownFormLanguage["Quc"] = "quc";
    KnownFormLanguage["Rm"] = "rm";
    KnownFormLanguage["Sco"] = "sco";
    KnownFormLanguage["Sl"] = "sl";
    KnownFormLanguage["Sq"] = "sq";
    KnownFormLanguage["Sv"] = "sv";
    KnownFormLanguage["Sw"] = "sw";
    KnownFormLanguage["Tet"] = "tet";
    KnownFormLanguage["Tr"] = "tr";
    KnownFormLanguage["Tt"] = "tt";
    KnownFormLanguage["Uz"] = "uz";
    KnownFormLanguage["Vo"] = "vo";
    KnownFormLanguage["Wae"] = "wae";
    KnownFormLanguage["Yua"] = "yua";
    KnownFormLanguage["Za"] = "za";
    KnownFormLanguage["ZhHans"] = "zh-Hans";
    KnownFormLanguage["ZhHant"] = "zh-Hant";
    KnownFormLanguage["Zu"] = "zu";
})(exports.KnownFormLanguage || (exports.KnownFormLanguage = {}));

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.FormRecognizerClient = FormRecognizerClient;
exports.FormTrainingClient = FormTrainingClient;
//# sourceMappingURL=index.js.map
