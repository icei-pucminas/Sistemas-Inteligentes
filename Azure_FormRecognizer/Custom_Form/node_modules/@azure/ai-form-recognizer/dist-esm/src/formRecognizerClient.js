// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __rest } from "tslib";
import { createPipelineFromOptions, isTokenCredential, bearerTokenAuthenticationPolicy, operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { SDK_VERSION, DEFAULT_COGNITIVE_SCOPE, FormRecognizerLoggingAllowedHeaderNames, FormRecognizerLoggingAllowedQueryParameters } from "./constants";
import { logger } from "./logger";
import { createSpan } from "./tracing";
import { toRequestBody, getContentType } from "./common";
import { SpanStatusCode } from "@azure/core-tracing";
import { GeneratedClient } from "./generated/generatedClient";
import { BeginRecognizeContentPoller } from "./lro/analyze/contentPoller";
import { FormRecognitionPoller } from "./lro/analyze/recognitionPoller";
import { toRecognizeContentResultResponse } from "./transforms";
import { createFormRecognizerAzureKeyCredentialPolicy } from "./azureKeyCredentialPolicy";
// #endregion
/**
 * Client class for interacting with the Azure Form Recognizer service.
 */
export class FormRecognizerClient {
    /**
     * Creates an instance of FormRecognizerClient.
     *
     * Example usage:
     * ```ts
     * import { FormRecognizerClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormRecognizerClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     *
     * @param endpointUrl - Url to an Azure Form Recognizer service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const pipelineOptions = __rest(options, []);
        const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createFormRecognizerAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,
                allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters
            }
        });
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    // #region content
    /**
     * Recognizes content, including text and table structure from a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_7.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContent(readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     * Recognizes content/layout information from a given document
     * @param form - Input document
     * @param options - Options to start content recognition operation
     */
    beginRecognizeContent(form, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            const poller = new BeginRecognizeContentPoller(Object.assign({ client, source: form }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes content, including text and table structure from a url to a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContentFromUrl(url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     *
     * Recognizes content/layout information from a url to a form document
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the content recognition operation
     */
    beginRecognizeContentFromUrl(formUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const poller = new BeginRecognizeContentPoller(Object.assign(Object.assign({ client, source: formUrl }, options), { contentType: undefined }));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves result of content recognition operation.
     * @internal
     */
    getRecognizedContent(resultId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormRecognizerClient-getRecognizedLayoutResult", realOptions);
            try {
                const requestOptions = operationOptionsToRequestOptionsBase(finalOptions);
                const analyzeResult = yield this.client.getAnalyzeLayoutResult(resultId, requestOptions);
                return toRecognizeContentResultResponse(analyzeResult);
            }
            catch (e) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    // #endregion
    // #region customforms
    /**
     * Recognizes forms from a given document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_6.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomForms(modelId, readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     * Recognizes form information from a given document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param form - Input form document
     * @param options - Options to start the form recognition operation
     */
    beginRecognizeCustomForms(modelId, form, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid model id");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeCustomForms", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ modelId, createOperation: span("customFormsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(form);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeWithCustomModel(modelId, contentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getCustomForms", (finalOptions, resultId, modelIdParam) => __awaiter(this, void 0, void 0, function* () {
                    // using the modelId from the parameter here is important, as we could be restoring from
                    // a suspended LRO
                    return this.client.getAnalyzeFormResult(
                    // Must be defined to have reached this point, but only for custom form recognition
                    modelIdParam, resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes forms from a URL to a document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     *
     * Recognizes form information from a url to a document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeCustomFormsFromUrl(modelId, formUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid model id");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeCustomForms", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ modelId, createOperation: span("customFormsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeWithCustomModel(modelId, "application/json", Object.assign({ fileStream: {
                            source: formUrl
                        } }, operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getCustomForms", (finalOptions, resultId, modelIdParam) => __awaiter(this, void 0, void 0, function* () {
                    // using the modelId from the parameter here is important, as we could be restoring from
                    // a suspended LRO
                    return this.client.getAnalyzeFormResult(
                    // Must be defined to have reached this point, but only for custom form recognition
                    modelIdParam, resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::businesscard
    /**
     * Recognizes data from business cards using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./business-card-english.png";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCards(readStream, {
     *   contentType: "image/png",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given document
     * @param businessCard - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCards(businessCard, options = { includeFieldElements: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeBusinessCards", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:businesscard", createOperation: span("businessCardsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(businessCard);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeBusinessCardAsync(contentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getBusinessCards", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeBusinessCardResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes business card information from a url using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the business card document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCardsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given accessible url to a document
     * @param businessCardUrl - Url to a business card document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCardsFromUrl(businessCardUrl, options = { includeFieldElements: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeBusinessCardsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:businesscard", createOperation: span("businessCardsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeBusinessCardAsync("application/json", Object.assign({ fileStream: {
                            source: businessCardUrl
                        } }, operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getBusinessCards", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeBusinessCardResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::invoice
    /**
     * Recognizes data from invoices using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_1.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoices(readStream, {
     *   contentType: "application/pdf",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given document
     * @param invoice - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoices(invoice, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeInvoices", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:invoice", createOperation: span("invoicesInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(invoice);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeInvoiceAsync(contentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getInvoices", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeInvoiceResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes invoice information from a URL using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the invoice document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoicesFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given accessible url to a document
     * @param invoiceUrl - Url to an invoice document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoicesFromUrl(invoiceUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeInvoicesFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:invoice", createOperation: span("invoicesInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeInvoiceAsync("application/json", Object.assign({ fileStream: {
                            source: invoiceUrl
                        } }, operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getInvoices", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeInvoiceResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::identityDocument
    /**
     * Recognizes data from identification documents using a pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     *
     * ```ts
     * const path = "./license.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocuments(readStream, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocument - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocuments(identityDocument, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeIdentityDocuments", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:idDocument", createOperation: span("identityDocumentsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(identityDocument);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeIdDocumentAsync(contentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getIdentityDocuments", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeIdDocumentResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes identity document information from a url using pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the identity document>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocumentsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocumentUrl - Url to an identity document that is accessible from
     * the service. Must be a valid, encoded URL to a document of a supported
     * content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocumentsFromUrl(identityDocumentUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeIdentityDocumentsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:idDocument", createOperation: span("identityDocumentsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeIdDocumentAsync("application/json", Object.assign({ fileStream: {
                            source: identityDocumentUrl
                        } }, operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getIdDocuments", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeIdDocumentResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    // #endregion
    // #region prebuilt::receipt
    /**
     * Recognizes data from receipts using a pre-built receipt model, enabling you to extract structured data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./contoso-allinone.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceipts(readStream, {
     *   contentType: "image/jpeg",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given document
     * @param receipt - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceipts(receipt, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeReceipts", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:receipt", createOperation: span("receiptsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const requestBody = yield toRequestBody(receipt);
                    const contentType = (_a = finalOptions.contentType) !== null && _a !== void 0 ? _a : (yield getContentType(requestBody));
                    return processOperationLocation(yield this.client.analyzeReceiptAsync(contentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions)));
                })), getResult: span("getReceipts", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeReceiptResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the receipt document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceiptsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given accessible url to a document
     * @param receiptUrl - Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceiptsFromUrl(receiptUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const { span } = makeSpanner("FormRecognizerClient-beginRecognizeReceiptsFromUrl", Object.assign(Object.assign({}, options), { contentType: undefined, includeTextDetails: options.includeFieldElements }));
            const poller = new FormRecognitionPoller(Object.assign({ expectedDocType: "prebuilt:receipt", createOperation: span("receiptsInternal", (finalOptions) => __awaiter(this, void 0, void 0, function* () {
                    return processOperationLocation(yield this.client.analyzeReceiptAsync("application/json", Object.assign({ fileStream: {
                            source: receiptUrl
                        } }, operationOptionsToRequestOptionsBase(finalOptions))));
                })), getResult: span("getReceipts", (finalOptions, resultId) => __awaiter(this, void 0, void 0, function* () {
                    return this.client.getAnalyzeReceiptResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                })) }, options));
            yield poller.poll();
            return poller;
        });
    }
}
/**
 * Validates a remote operation's location is defined and extracts the
 * result ID from it.
 *
 * @param remoteOperation - The operation to process
 * @returns The remote operation ID
 *
 * @internal
 */
function processOperationLocation({ operationLocation }) {
    if (!operationLocation) {
        throw new Error("The service did not respond with an 'operationLocation' to retrieve results.");
    }
    else {
        const lastSlashIndex = operationLocation.lastIndexOf("/");
        return operationLocation.substring(lastSlashIndex + 1);
    }
}
/**
 * Helper function to create spans for internal polling handlers
 *
 * The argument is a handler function that will be wrapped in a tracing
 * span, where tracing-updated options will be inserted as its first parameter.
 *
 * @example
 * ```typescript
 * const spanned = makeSpanner("FormRecognizerClient-beginRecognizeReceipts", {
 *   ...options,
 *   // Override any options you need here
 * });
 *
 * const autoSpannedFunction = spanner("autoSpannedFunction", (updatedOptions) => {
 *  // ...
 * });
 * ```
 *
 * @internal
 */
function makeSpanner(prefix, options) {
    return {
        span: (name, handler) => (...args) => {
            const { span, updatedOptions } = createSpan(`${prefix}-${name}`, options);
            try {
                return handler(updatedOptions, ...args);
            }
            catch (e) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        }
    };
}
/**
 * The worker function of layout analysis.
 *
 * @internal
 */
function recognizeLayoutInternal(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, body, contentType, options, _modelId) {
    return __awaiter(this, void 0, void 0, function* () {
        const realOptions = options || {};
        const { span, updatedOptions: finalOptions } = createSpan("analyzeLayoutInternal", realOptions);
        const requestBody = yield toRequestBody(body);
        const requestContentType = contentType ? contentType : yield getContentType(requestBody);
        try {
            if (requestContentType) {
                return yield client.analyzeLayoutAsync(requestContentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions));
            }
            return yield client.analyzeLayoutAsync("application/json", Object.assign({ fileStream: requestBody }, operationOptionsToRequestOptionsBase(finalOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}
//# sourceMappingURL=formRecognizerClient.js.map