/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreHttp from "@azure/core-http";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import { GeneratedClientContext } from "./generatedClientContext";
/** @hidden */
export class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Create and train a custom model. The request must include a source parameter that is either an
     * externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or
     * valid path to a data folder in a locally mounted drive. When local paths are specified, they must
     * follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration
     * setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source
     * path would be '/input/contosodataset'. All data to be trained is expected to be under the source
     * folder or sub folders under it. Models are trained using documents that are of the following content
     * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Other type of
     * content is ignored.
     * @param trainRequest Training request parameters.
     * @param options The options parameters.
     */
    trainCustomModelAsync(trainRequest, options) {
        const operationArguments = {
            trainRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, trainCustomModelAsyncOperationSpec);
    }
    /**
     * Get detailed information about a custom model.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    getCustomModel(modelId, options) {
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelOperationSpec);
    }
    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    deleteCustomModel(modelId, options) {
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCustomModelOperationSpec);
    }
    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must
     * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',
     * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri
     * or local path) of the document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeWithCustomModel(...args) {
        let operationSpec;
        let operationArguments;
        if (args[1] === "application/pdf" ||
            args[1] === "image/bmp" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeWithCustomModel$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                fileStream: args[2],
                options: args[3]
            };
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeWithCustomModel$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Obtain current status and the result of the analyze form operation.
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeFormResult(modelId, resultId, options) {
        const operationArguments = {
            modelId,
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeFormResultOperationSpec);
    }
    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer
     * resource.
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param options The options parameters.
     */
    copyCustomModel(modelId, copyRequest, options) {
        const operationArguments = {
            modelId,
            copyRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, copyCustomModelOperationSpec);
    }
    /**
     * Obtain current status and the result of a custom model copy operation.
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param options The options parameters.
     */
    getCustomModelCopyResult(modelId, resultId, options) {
        const operationArguments = {
            modelId,
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelCopyResultOperationSpec);
    }
    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * @param options The options parameters.
     */
    generateModelCopyAuthorization(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, generateModelCopyAuthorizationOperationSpec);
    }
    /**
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * @param composeRequest Compose models
     * @param options The options parameters.
     */
    composeCustomModelsAsync(composeRequest, options) {
        const operationArguments = {
            composeRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, composeCustomModelsAsyncOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given business card document. The input document must
     * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png',
     * 'image/tiff' or 'image/bmp'. Alternatively, use 'application/json' type to specify the location
     * (Uri) of the document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeBusinessCardAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeBusinessCardAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeBusinessCardAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze business card operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeBusinessCardResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeBusinessCardResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given invoice document. The input document must be of
     * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeInvoiceAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeInvoiceAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeInvoiceAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze invoice operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeInvoiceResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeInvoiceResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given ID document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeIdDocumentAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeIdDocumentAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeIdDocumentAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze ID operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeIdDocumentResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeIdDocumentResultOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of
     * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Alternatively, use 'application/json' type to specify the location (Uri) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeReceiptAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeReceiptAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeReceiptAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeReceiptResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeReceiptResultOperationSpec);
    }
    /**
     * Extract text and layout information from a given document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeLayoutAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/bmp" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeLayoutAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeLayoutAsync$jsonOperationSpec;
            operationArguments = { contentType: args[0], options: args[1] };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        operationArguments.options = coreHttp.operationOptionsToRequestOptionsBase(operationArguments.options || {});
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze layout operation
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeLayoutResult(resultId, options) {
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getAnalyzeLayoutResultOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    listCustomModels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, listCustomModelsOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    getCustomModels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCustomModelsOperationSpec);
    }
    /**
     * ListCustomModelsNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomModels method.
     * @param options The options parameters.
     */
    listCustomModelsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, listCustomModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const trainCustomModelAsyncOperationSpec = {
    path: "/custom/models",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: Mappers.GeneratedClientTrainCustomModelAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.trainRequest,
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "json",
    serializer
};
const getCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Model
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.includeKeys],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept],
    serializer
};
const analyzeWithCustomModel$binaryOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [Parameters.includeTextDetails, Parameters.pages],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeWithCustomModel$jsonOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [Parameters.includeTextDetails, Parameters.pages],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeFormResultOperationSpec = {
    path: "/custom/models/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const copyCustomModelOperationSpec = {
    path: "/custom/models/{modelId}/copy",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientCopyCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.copyRequest,
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "json",
    serializer
};
const getCustomModelCopyResultOperationSpec = {
    path: "/custom/models/{modelId}/copyResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.CopyOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const generateModelCopyAuthorizationOperationSpec = {
    path: "/custom/models/copyAuthorization",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: Mappers.CopyAuthorizationResult,
            headersMapper: Mappers.GeneratedClientGenerateModelCopyAuthorizationHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept],
    serializer
};
const composeCustomModelsAsyncOperationSpec = {
    path: "/custom/models/compose",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: Mappers.GeneratedClientComposeCustomModelsAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.composeRequest,
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType, Parameters.accept2],
    mediaType: "json",
    serializer
};
const analyzeBusinessCardAsync$binaryOperationSpec = {
    path: "/prebuilt/businessCard/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeBusinessCardAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeBusinessCardAsync$jsonOperationSpec = {
    path: "/prebuilt/businessCard/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeBusinessCardAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeBusinessCardResultOperationSpec = {
    path: "/prebuilt/businessCard/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const analyzeInvoiceAsync$binaryOperationSpec = {
    path: "/prebuilt/invoice/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeInvoiceAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeInvoiceAsync$jsonOperationSpec = {
    path: "/prebuilt/invoice/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeInvoiceAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeInvoiceResultOperationSpec = {
    path: "/prebuilt/invoice/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const analyzeIdDocumentAsync$binaryOperationSpec = {
    path: "/prebuilt/idDocument/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeIdDocumentAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [Parameters.includeTextDetails, Parameters.pages],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeIdDocumentAsync$jsonOperationSpec = {
    path: "/prebuilt/idDocument/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeIdDocumentAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [Parameters.includeTextDetails, Parameters.pages],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeIdDocumentResultOperationSpec = {
    path: "/prebuilt/idDocument/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const analyzeReceiptAsync$binaryOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeReceiptAsync$jsonOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [
        Parameters.includeTextDetails,
        Parameters.pages,
        Parameters.locale
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeReceiptResultOperationSpec = {
    path: "/prebuilt/receipt/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const analyzeLayoutAsync$binaryOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [
        Parameters.pages,
        Parameters.language,
        Parameters.readingOrder
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "binary",
    serializer
};
const analyzeLayoutAsync$jsonOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [
        Parameters.pages,
        Parameters.language,
        Parameters.readingOrder
    ],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeLayoutResultOperationSpec = {
    path: "/layout/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    headerParameters: [Parameters.accept],
    serializer
};
const listCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept],
    serializer
};
const getCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op1],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept],
    serializer
};
const listCustomModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op],
    urlParameters: [Parameters.endpoint, Parameters.nextLink],
    headerParameters: [Parameters.accept],
    serializer
};
//# sourceMappingURL=generatedClient.js.map