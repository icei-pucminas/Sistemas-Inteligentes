{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/generated/models/index.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAwcH,qEAAqE;AACrE,MAAM,CAAN,IAAkB,iBAGjB;AAHD,WAAkB,iBAAiB;IACjC,sCAAiB,CAAA;IACjB,oDAA+B,CAAA;AACjC,CAAC,EAHiB,iBAAiB,KAAjB,iBAAiB,QAGlC;AAYD,gFAAgF;AAChF,MAAM,CAAN,IAAkB,4BAGjB;AAHD,WAAkB,4BAA4B;IAC5C,qDAAqB,CAAA;IACrB,yDAAyB,CAAA;AAC3B,CAAC,EAHiB,4BAA4B,KAA5B,4BAA4B,QAG7C;AAYD,mEAAmE;AACnE,MAAM,CAAN,IAAkB,eAMjB;AAND,WAAkB,eAAe;IAC/B,iCAAc,CAAA;IACd,iCAAc,CAAA;IACd,iCAAc,CAAA;IACd,iCAAc,CAAA;IACd,iCAAc,CAAA;AAChB,CAAC,EANiB,eAAe,KAAf,eAAe,QAMhC;AAeD,qEAAqE;AACrE,MAAM,CAAN,IAAkB,iBA0EjB;AA1ED,WAAkB,iBAAiB;IACjC,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,8BAAS,CAAA;IACT,gCAAW,CAAA;IACX,gCAAW,CAAA;IACX,8BAAS,CAAA;IACT,uCAAkB,CAAA;IAClB,uCAAkB,CAAA;IAClB,8BAAS,CAAA;AACX,CAAC,EA1EiB,iBAAiB,KAAjB,iBAAiB,QA0ElC","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\n/** Request parameter to train a new custom model. */\nexport interface TrainRequest {\n  /** Source path containing the training documents. */\n  source: string;\n  /** Filter to apply to the documents in the source path for training. */\n  sourceFilter?: TrainSourceFilter;\n  /** Use label file for training a model. */\n  useLabelFile?: boolean;\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n}\n\n/** Filter to apply to the documents in the source path for training. */\nexport interface TrainSourceFilter {\n  /** A case-sensitive prefix string to filter documents in the source path for training. For example, when using a Azure storage blob Uri, use the prefix to restrict sub folders for training. */\n  prefix?: string;\n  /** A flag to indicate if sub folders within the set of prefix folders will also need to be included when searching for content to be preprocessed. */\n  includeSubfolders?: boolean;\n}\n\nexport interface ErrorResponse {\n  error: ErrorInformation;\n}\n\nexport interface ErrorInformation {\n  code: string;\n  message: string;\n}\n\n/** Response to the get custom model operation. */\nexport interface Model {\n  /** Basic custom model information. */\n  modelInfo: ModelInfo;\n  /** Keys extracted by the custom model. */\n  keys?: KeysResult;\n  /** Training result for custom model. */\n  trainResult?: TrainResult;\n  /** Training result for composed model. */\n  composedTrainResults?: TrainResult[];\n}\n\n/** Basic custom model information. */\nexport interface ModelInfo {\n  /** Model identifier. */\n  modelId: string;\n  /** Status of the model. */\n  status: ModelStatus;\n  /** Date and time (UTC) when the model was created. */\n  trainingStartedOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  trainingCompletedOn: Date;\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n  /** Optional model attributes. */\n  attributes?: Attributes;\n}\n\n/** Optional model attributes. */\nexport interface Attributes {\n  /** Is this model composed? (default: false). */\n  isComposed?: boolean;\n}\n\n/** Keys extracted by the custom model. */\nexport interface KeysResult {\n  /** Object mapping clusterIds to a list of keys. */\n  clusters: { [propertyName: string]: string[] };\n}\n\n/** Custom model training result. */\nexport interface TrainResult {\n  /** List of the documents used to train the model and any errors reported in each document. */\n  trainingDocuments: TrainingDocumentInfo[];\n  /** List of fields used to train the model and the train operation error reported by each. */\n  fields?: FormFieldsReport[];\n  /** Average accuracy. */\n  averageModelAccuracy?: number;\n  /** Model identifier. */\n  modelId?: string;\n  /** Errors returned during the training operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Report for a custom model training document. */\nexport interface TrainingDocumentInfo {\n  /** Training document name. */\n  name: string;\n  /** Total number of pages trained. */\n  pageCount: number;\n  /** List of errors. */\n  errors: ErrorInformation[];\n  /** Status of the training operation. */\n  status: TrainStatus;\n}\n\n/** Report for a custom model training field. */\nexport interface FormFieldsReport {\n  /** Training field name. */\n  fieldName: string;\n  /** Estimated extraction accuracy for this field. */\n  accuracy: number;\n}\n\n/** Uri or local path to source data. */\nexport interface SourcePath {\n  /** File source path. */\n  source?: string;\n}\n\n/** Status and result of the queued analyze operation. */\nexport interface AnalyzeOperationResult {\n  /** Operation status. */\n  status: OperationStatus;\n  /** Date and time (UTC) when the analyze operation was submitted. */\n  createdOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  lastModified: Date;\n  /** Results of the analyze operation. */\n  analyzeResult?: AnalyzeResult;\n}\n\n/** Analyze operation result. */\nexport interface AnalyzeResult {\n  /** Version of schema used for this result. */\n  version: string;\n  /** Text extracted from the input. */\n  readResults: ReadResult[];\n  /** Page-level information extracted from the input. */\n  pageResults?: PageResult[];\n  /** Document-level information extracted from the input. */\n  documentResults?: DocumentResult[];\n  /** List of errors reported during the analyze operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Text extracted from a page in the input document. */\nexport interface ReadResult {\n  /** The 1-based page number in the input document. */\n  pageNumber: number;\n  /** The general orientation of the text in clockwise direction, measured in degrees between (-180, 180]. */\n  angle: number;\n  /** The width of the image/PDF in pixels/inches, respectively. */\n  width: number;\n  /** The height of the image/PDF in pixels/inches, respectively. */\n  height: number;\n  /** The unit used by the width, height and boundingBox properties. For images, the unit is \"pixel\". For PDF, the unit is \"inch\". */\n  unit: LengthUnit;\n  /** When includeTextDetails is set to true, a list of recognized text lines. The maximum number of lines returned is 300 per page. The lines are sorted top to bottom, left to right, although in certain cases proximity is treated with higher priority. As the sorting order depends on the detected text, it may change across images and OCR version updates. Thus, business logic should be built upon the actual line location instead of order. */\n  lines?: TextLine[];\n  /** List of selection marks extracted from the page. */\n  selectionMarks?: SelectionMark[];\n}\n\n/** An object representing an extracted text line. */\nexport interface TextLine {\n  /** The text content of the line. */\n  text: string;\n  /** Bounding box of an extracted line. */\n  boundingBox: number[];\n  /** List of words in the text line. */\n  words: TextWord[];\n  /** Text appearance properties. */\n  appearance?: TextAppearance;\n}\n\n/** An object representing a word. */\nexport interface TextWord {\n  /** The text content of the word. */\n  text: string;\n  /** Bounding box of an extracted word. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence?: number;\n}\n\n/** An object representing the appearance of the text line. */\nexport interface TextAppearance {\n  /** An object representing the style of the text line. */\n  style: TextStyle;\n}\n\n/** An object representing the style of the text line. */\nexport interface TextStyle {\n  /** The text line style name, including handwriting and other. */\n  name: StyleName;\n  /** The confidence of text line style. */\n  confidence: number;\n}\n\n/** Information about the extracted selection mark. */\nexport interface SelectionMark {\n  /** Bounding box of the selection mark. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence: number;\n  /** State of the selection mark. */\n  state: SelectionMarkState;\n}\n\n/** Extracted information from a single page. */\nexport interface PageResult {\n  /** Page number. */\n  pageNumber: number;\n  /** Cluster identifier. */\n  clusterId?: number;\n  /** List of key-value pairs extracted from the page. */\n  keyValuePairs?: KeyValuePair[];\n  /** List of data tables extracted from the page. */\n  tables?: DataTable[];\n}\n\n/** Information about the extracted key-value pair. */\nexport interface KeyValuePair {\n  /** A user defined label for the key/value pair entry. */\n  label?: string;\n  /** Information about the extracted key in a key-value pair. */\n  key: KeyValueElement;\n  /** Information about the extracted value in a key-value pair. */\n  value: KeyValueElement;\n  /** Confidence value. */\n  confidence: number;\n}\n\n/** Information about the extracted key or value in a key-value pair. */\nexport interface KeyValueElement {\n  /** Semantic data type of the key value element. */\n  type?: KeyValueType;\n  /** The text content of the key or value. */\n  text: string;\n  /** Bounding box of the key or value. */\n  boundingBox?: number[];\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this key or value. */\n  elements?: string[];\n}\n\n/** Information about the extracted table contained in a page. */\nexport interface DataTable {\n  /** Number of rows. */\n  rows: number;\n  /** Number of columns. */\n  columns: number;\n  /** List of cells contained in the table. */\n  cells: DataTableCell[];\n  /** Bounding box of the table. */\n  boundingBox: number[];\n}\n\n/** Information about the extracted cell in a table. */\nexport interface DataTableCell {\n  /** Row index of the cell. */\n  rowIndex: number;\n  /** Column index of the cell. */\n  columnIndex: number;\n  /** Number of rows spanned by this cell. */\n  rowSpan?: number;\n  /** Number of columns spanned by this cell. */\n  columnSpan?: number;\n  /** Text content of the cell. */\n  text: string;\n  /** Bounding box of the cell. */\n  boundingBox: number[];\n  /** Confidence value. */\n  confidence: number;\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this table cell. */\n  elements?: string[];\n  /** Is the current cell a header cell? */\n  isHeader?: boolean;\n  /** Is the current cell a footer cell? */\n  isFooter?: boolean;\n}\n\n/** A set of extracted fields corresponding to the input document. */\nexport interface DocumentResult {\n  /** Document type. */\n  docType: string;\n  /** Model identifier. */\n  modelId?: string;\n  /** First and last page number where the document is found. */\n  pageRange: number[];\n  /** Predicted document type confidence. */\n  docTypeConfidence?: number;\n  /** Dictionary of named field values. */\n  fields: { [propertyName: string]: FieldValue };\n}\n\n/** Recognized field value. */\nexport interface FieldValue {\n  /** Type of field value. */\n  type: FieldValueType;\n  /** String value. */\n  valueString?: string;\n  /** Date value. */\n  valueDate?: Date;\n  /**\n   * Time value.\n   * This value should be an ISO-8601 formatted string representing time. E.g. \"HH:MM:SS\" or \"HH:MM:SS.mm\".\n   */\n  valueTime?: string;\n  /** Phone number value. */\n  valuePhoneNumber?: string;\n  /** Floating point value. */\n  valueNumber?: number;\n  /** Integer value. */\n  valueInteger?: number;\n  /** Array of field values. */\n  valueArray?: FieldValue[];\n  /** Dictionary of named field values. */\n  valueObject?: { [propertyName: string]: FieldValue };\n  /** Selection mark value. */\n  valueSelectionMark?: FieldValueSelectionMark;\n  /** 3-letter country code (ISO 3166-1 alpha-3). */\n  valueCountryRegion?: string;\n  /** Text content of the extracted field. */\n  text?: string;\n  /** Bounding box of the field value, if appropriate. */\n  boundingBox?: number[];\n  /** Confidence score. */\n  confidence?: number;\n  /** When includeTextDetails is set to true, a list of references to the text elements constituting this field. */\n  elements?: string[];\n  /** The 1-based page number in the input document. */\n  pageNumber?: number;\n}\n\n/** Request parameter to copy an existing custom model from the source resource to a target resource referenced by the resource ID. */\nexport interface CopyRequest {\n  /** Azure Resource Id of the target Form Recognizer resource where the model is copied to. */\n  targetResourceId: string;\n  /** Location of the target Azure resource. A valid Azure region name supported by Cognitive Services. */\n  targetResourceRegion: string;\n  /** Entity that encodes claims to authorize the copy request. */\n  copyAuthorization: CopyAuthorizationResult;\n}\n\n/** Request parameter that contains authorization claims for copy operation. */\nexport interface CopyAuthorizationResult {\n  /** Model identifier. */\n  modelId: string;\n  /** Token claim used to authorize the request. */\n  accessToken: string;\n  /** The time when the access token expires. The date is represented as the number of seconds from 1970-01-01T0:0:0Z UTC until the expiration time. */\n  expirationDateTimeTicks: number;\n}\n\n/** Status and result of the queued copy operation. */\nexport interface CopyOperationResult {\n  /** Operation status. */\n  status: OperationStatus;\n  /** Date and time (UTC) when the copy operation was submitted. */\n  createdOn: Date;\n  /** Date and time (UTC) when the status was last updated. */\n  lastModified: Date;\n  /** Results of the copy operation. */\n  copyResult?: CopyResult;\n}\n\n/** Custom model copy result. */\nexport interface CopyResult {\n  /** Identifier of the target model. */\n  modelId: string;\n  /** Errors returned during the copy operation. */\n  errors?: ErrorInformation[];\n}\n\n/** Request contract for compose operation. */\nexport interface ComposeRequest {\n  /** List of model ids to compose. */\n  modelIds: string[];\n  /** Optional user defined model name (max length: 1024). */\n  modelName?: string;\n}\n\n/** Response to the list custom models operation. */\nexport interface Models {\n  /** Summary of all trained custom models. */\n  summary?: ModelsSummary;\n  /** Collection of trained custom models. */\n  modelList?: ModelInfo[];\n  /** Link to the next page of custom models. */\n  nextLink?: string;\n}\n\n/** Summary of all trained custom models. */\nexport interface ModelsSummary {\n  /** Current count of trained custom models. */\n  count: number;\n  /** Max number of models that can be trained for this account. */\n  limit: number;\n  /** Date and time (UTC) when the summary was last updated. */\n  lastModified: Date;\n}\n\n/** Defines headers for GeneratedClient_trainCustomModelAsync operation. */\nexport interface GeneratedClientTrainCustomModelAsyncHeaders {\n  /** Location and ID of the model being trained. The status of model training is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeWithCustomModel operation. */\nexport interface GeneratedClientAnalyzeWithCustomModelHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_copyCustomModel operation. */\nexport interface GeneratedClientCopyCustomModelHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the copy operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_generateModelCopyAuthorization operation. */\nexport interface GeneratedClientGenerateModelCopyAuthorizationHeaders {\n  /** Location and ID of the model being copied. The status of model copy is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_composeCustomModelsAsync operation. */\nexport interface GeneratedClientComposeCustomModelsAsyncHeaders {\n  /** Location and ID of the composed model. The status of composed model is specified in the status property at the model location. */\n  location?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeBusinessCardAsync operation. */\nexport interface GeneratedClientAnalyzeBusinessCardAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeInvoiceAsync operation. */\nexport interface GeneratedClientAnalyzeInvoiceAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeIdDocumentAsync operation. */\nexport interface GeneratedClientAnalyzeIdDocumentAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeReceiptAsync operation. */\nexport interface GeneratedClientAnalyzeReceiptAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Defines headers for GeneratedClient_analyzeLayoutAsync operation. */\nexport interface GeneratedClientAnalyzeLayoutAsyncHeaders {\n  /** URL containing the resultId used to track the progress and obtain the result of the analyze operation. */\n  operationLocation?: string;\n}\n\n/** Known values of {@link KeyValueType} that the service accepts. */\nexport const enum KnownKeyValueType {\n  String = \"string\",\n  SelectionMark = \"selectionMark\"\n}\n\n/**\n * Defines values for KeyValueType. \\\n * {@link KnownKeyValueType} can be used interchangeably with KeyValueType,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **string** \\\n * **selectionMark**\n */\nexport type KeyValueType = string;\n\n/** Known values of {@link FieldValueSelectionMark} that the service accepts. */\nexport const enum KnownFieldValueSelectionMark {\n  Selected = \"selected\",\n  Unselected = \"unselected\"\n}\n\n/**\n * Defines values for FieldValueSelectionMark. \\\n * {@link KnownFieldValueSelectionMark} can be used interchangeably with FieldValueSelectionMark,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **selected** \\\n * **unselected**\n */\nexport type FieldValueSelectionMark = string;\n\n/** Known values of {@link FormLocale} that the service accepts. */\nexport const enum KnownFormLocale {\n  EnAU = \"en-AU\",\n  EnCA = \"en-CA\",\n  EnGB = \"en-GB\",\n  EnIN = \"en-IN\",\n  EnUS = \"en-US\"\n}\n\n/**\n * Defines values for FormLocale. \\\n * {@link KnownFormLocale} can be used interchangeably with FormLocale,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **en-AU** \\\n * **en-CA** \\\n * **en-GB** \\\n * **en-IN** \\\n * **en-US**\n */\nexport type FormLocale = string;\n\n/** Known values of {@link FormLanguage} that the service accepts. */\nexport const enum KnownFormLanguage {\n  Af = \"af\",\n  Ast = \"ast\",\n  Bi = \"bi\",\n  Br = \"br\",\n  Ca = \"ca\",\n  Ceb = \"ceb\",\n  Ch = \"ch\",\n  Co = \"co\",\n  Crh = \"crh\",\n  Cs = \"cs\",\n  Csb = \"csb\",\n  Da = \"da\",\n  De = \"de\",\n  En = \"en\",\n  Es = \"es\",\n  Et = \"et\",\n  Eu = \"eu\",\n  Fi = \"fi\",\n  Fil = \"fil\",\n  Fj = \"fj\",\n  Fr = \"fr\",\n  Fur = \"fur\",\n  Fy = \"fy\",\n  Ga = \"ga\",\n  Gd = \"gd\",\n  Gil = \"gil\",\n  Gl = \"gl\",\n  Gv = \"gv\",\n  Hni = \"hni\",\n  Hsb = \"hsb\",\n  Ht = \"ht\",\n  Hu = \"hu\",\n  Ia = \"ia\",\n  Id = \"id\",\n  It = \"it\",\n  Iu = \"iu\",\n  Ja = \"ja\",\n  Jv = \"jv\",\n  Kaa = \"kaa\",\n  Kac = \"kac\",\n  Kea = \"kea\",\n  Kha = \"kha\",\n  Kl = \"kl\",\n  Ko = \"ko\",\n  Ku = \"ku\",\n  Kw = \"kw\",\n  Lb = \"lb\",\n  Ms = \"ms\",\n  Mww = \"mww\",\n  Nap = \"nap\",\n  Nl = \"nl\",\n  No = \"no\",\n  Oc = \"oc\",\n  Pl = \"pl\",\n  Pt = \"pt\",\n  Quc = \"quc\",\n  Rm = \"rm\",\n  Sco = \"sco\",\n  Sl = \"sl\",\n  Sq = \"sq\",\n  Sv = \"sv\",\n  Sw = \"sw\",\n  Tet = \"tet\",\n  Tr = \"tr\",\n  Tt = \"tt\",\n  Uz = \"uz\",\n  Vo = \"vo\",\n  Wae = \"wae\",\n  Yua = \"yua\",\n  Za = \"za\",\n  ZhHans = \"zh-Hans\",\n  ZhHant = \"zh-Hant\",\n  Zu = \"zu\"\n}\n\n/**\n * Defines values for FormLanguage. \\\n * {@link KnownFormLanguage} can be used interchangeably with FormLanguage,\n *  this enum contains the known values that the service supports.\n * ### Know values supported by the service\n * **af** \\\n * **ast** \\\n * **bi** \\\n * **br** \\\n * **ca** \\\n * **ceb** \\\n * **ch** \\\n * **co** \\\n * **crh** \\\n * **cs** \\\n * **csb** \\\n * **da** \\\n * **de** \\\n * **en** \\\n * **es** \\\n * **et** \\\n * **eu** \\\n * **fi** \\\n * **fil** \\\n * **fj** \\\n * **fr** \\\n * **fur** \\\n * **fy** \\\n * **ga** \\\n * **gd** \\\n * **gil** \\\n * **gl** \\\n * **gv** \\\n * **hni** \\\n * **hsb** \\\n * **ht** \\\n * **hu** \\\n * **ia** \\\n * **id** \\\n * **it** \\\n * **iu** \\\n * **ja** \\\n * **jv** \\\n * **kaa** \\\n * **kac** \\\n * **kea** \\\n * **kha** \\\n * **kl** \\\n * **ko** \\\n * **ku** \\\n * **kw** \\\n * **lb** \\\n * **ms** \\\n * **mww** \\\n * **nap** \\\n * **nl** \\\n * **no** \\\n * **oc** \\\n * **pl** \\\n * **pt** \\\n * **quc** \\\n * **rm** \\\n * **sco** \\\n * **sl** \\\n * **sq** \\\n * **sv** \\\n * **sw** \\\n * **tet** \\\n * **tr** \\\n * **tt** \\\n * **uz** \\\n * **vo** \\\n * **wae** \\\n * **yua** \\\n * **za** \\\n * **zh-Hans** \\\n * **zh-Hant** \\\n * **zu**\n */\nexport type FormLanguage = string;\n/** Defines values for ModelStatus. */\nexport type ModelStatus = \"creating\" | \"ready\" | \"invalid\";\n/** Defines values for TrainStatus. */\nexport type TrainStatus = \"succeeded\" | \"partiallySucceeded\" | \"failed\";\n/** Defines values for ContentType. */\nexport type ContentType =\n  | \"application/pdf\"\n  | \"image/bmp\"\n  | \"image/jpeg\"\n  | \"image/png\"\n  | \"image/tiff\";\n/** Defines values for OperationStatus. */\nexport type OperationStatus = \"notStarted\" | \"running\" | \"succeeded\" | \"failed\";\n/** Defines values for LengthUnit. */\nexport type LengthUnit = \"pixel\" | \"inch\";\n/** Defines values for StyleName. */\nexport type StyleName = \"other\" | \"handwriting\";\n/** Defines values for SelectionMarkState. */\nexport type SelectionMarkState = \"selected\" | \"unselected\";\n/** Defines values for FieldValueType. */\nexport type FieldValueType =\n  | \"string\"\n  | \"date\"\n  | \"time\"\n  | \"phoneNumber\"\n  | \"number\"\n  | \"integer\"\n  | \"array\"\n  | \"object\"\n  | \"selectionMark\"\n  | \"countryRegion\";\n/** Defines values for FormReadingOrder. */\nexport type FormReadingOrder = \"basic\" | \"natural\";\n\n/** Contains response data for the trainCustomModelAsync operation. */\nexport type GeneratedClientTrainCustomModelAsyncResponse = GeneratedClientTrainCustomModelAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientTrainCustomModelAsyncHeaders;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientGetCustomModelOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include list of extracted keys in model information. */\n  includeKeys?: boolean;\n}\n\n/** Contains response data for the getCustomModel operation. */\nexport type GeneratedClientGetCustomModelResponse = Model & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Model;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeWithCustomModel$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeWithCustomModel$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Contains response data for the analyzeWithCustomModel operation. */\nexport type GeneratedClientAnalyzeWithCustomModelResponse = GeneratedClientAnalyzeWithCustomModelHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeWithCustomModelHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeFormResult operation. */\nexport type GeneratedClientGetAnalyzeFormResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Contains response data for the copyCustomModel operation. */\nexport type GeneratedClientCopyCustomModelResponse = GeneratedClientCopyCustomModelHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientCopyCustomModelHeaders;\n  };\n};\n\n/** Contains response data for the getCustomModelCopyResult operation. */\nexport type GeneratedClientGetCustomModelCopyResultResponse = CopyOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: CopyOperationResult;\n  };\n};\n\n/** Contains response data for the generateModelCopyAuthorization operation. */\nexport type GeneratedClientGenerateModelCopyAuthorizationResponse = GeneratedClientGenerateModelCopyAuthorizationHeaders &\n  CopyAuthorizationResult & {\n    /** The underlying HTTP response. */\n    _response: coreHttp.HttpResponse & {\n      /** The response body as text (string format) */\n      bodyAsText: string;\n\n      /** The response body as parsed JSON or XML */\n      parsedBody: CopyAuthorizationResult;\n      /** The parsed HTTP response headers. */\n      parsedHeaders: GeneratedClientGenerateModelCopyAuthorizationHeaders;\n    };\n  };\n\n/** Contains response data for the composeCustomModelsAsync operation. */\nexport type GeneratedClientComposeCustomModelsAsyncResponse = GeneratedClientComposeCustomModelsAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientComposeCustomModelsAsyncHeaders;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeBusinessCardAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeBusinessCardAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeBusinessCardAsync operation. */\nexport type GeneratedClientAnalyzeBusinessCardAsyncResponse = GeneratedClientAnalyzeBusinessCardAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeBusinessCardAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeBusinessCardResult operation. */\nexport type GeneratedClientGetAnalyzeBusinessCardResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeInvoiceAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeInvoiceAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeInvoiceAsync operation. */\nexport type GeneratedClientAnalyzeInvoiceAsyncResponse = GeneratedClientAnalyzeInvoiceAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeInvoiceAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeInvoiceResult operation. */\nexport type GeneratedClientGetAnalyzeInvoiceResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeIdDocumentAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeIdDocumentAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n}\n\n/** Contains response data for the analyzeIdDocumentAsync operation. */\nexport type GeneratedClientAnalyzeIdDocumentAsyncResponse = GeneratedClientAnalyzeIdDocumentAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeIdDocumentAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeIdDocumentResult operation. */\nexport type GeneratedClientGetAnalyzeIdDocumentResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeReceiptAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeReceiptAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Include text lines and element references in the result. */\n  includeTextDetails?: boolean;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN, en-US(default). */\n  locale?: FormLocale;\n}\n\n/** Contains response data for the analyzeReceiptAsync operation. */\nexport type GeneratedClientAnalyzeReceiptAsyncResponse = GeneratedClientAnalyzeReceiptAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeReceiptAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeReceiptResult operation. */\nexport type GeneratedClientGetAnalyzeReceiptResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeLayoutAsync$binaryOptionalParams\n  extends coreHttp.OperationOptions {\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’), Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’), Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’), Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English only). Layout supports auto language identification and multi language documents, so only provide a language code if you would like to force the documented to be processed as that specific language. */\n  language?: FormLanguage;\n  /** Reading order algorithm to sort the text lines returned. Supported reading orders include: basic(default), natural. */\n  readingOrder?: FormReadingOrder;\n}\n\n/** Optional parameters. */\nexport interface GeneratedClientAnalyzeLayoutAsync$jsonOptionalParams\n  extends coreHttp.OperationOptions {\n  /** .json, .pdf, .jpg, .png, .tiff or .bmp type file stream. */\n  fileStream?: SourcePath;\n  /** Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma. */\n  pages?: string[];\n  /** Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’), Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’), Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’), Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English only). Layout supports auto language identification and multi language documents, so only provide a language code if you would like to force the documented to be processed as that specific language. */\n  language?: FormLanguage;\n  /** Reading order algorithm to sort the text lines returned. Supported reading orders include: basic(default), natural. */\n  readingOrder?: FormReadingOrder;\n}\n\n/** Contains response data for the analyzeLayoutAsync operation. */\nexport type GeneratedClientAnalyzeLayoutAsyncResponse = GeneratedClientAnalyzeLayoutAsyncHeaders & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The parsed HTTP response headers. */\n    parsedHeaders: GeneratedClientAnalyzeLayoutAsyncHeaders;\n  };\n};\n\n/** Contains response data for the getAnalyzeLayoutResult operation. */\nexport type GeneratedClientGetAnalyzeLayoutResultResponse = AnalyzeOperationResult & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: AnalyzeOperationResult;\n  };\n};\n\n/** Contains response data for the listCustomModels operation. */\nexport type GeneratedClientListCustomModelsResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Contains response data for the getCustomModels operation. */\nexport type GeneratedClientGetCustomModelsResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Contains response data for the listCustomModelsNext operation. */\nexport type GeneratedClientListCustomModelsNextResponse = Models & {\n  /** The underlying HTTP response. */\n  _response: coreHttp.HttpResponse & {\n    /** The response body as text (string format) */\n    bodyAsText: string;\n\n    /** The response body as parsed JSON or XML */\n    parsedBody: Models;\n  };\n};\n\n/** Optional parameters. */\nexport interface GeneratedClientOptionalParams\n  extends coreHttp.ServiceClientOptions {\n  /** Overrides client endpoint. */\n  endpoint?: string;\n}\n"]}