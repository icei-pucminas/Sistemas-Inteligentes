// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toBoundingBox(original) {
    return [
        { x: original[0], y: original[1] },
        { x: original[2], y: original[3] },
        { x: original[4], y: original[5] },
        { x: original[6], y: original[7] }
    ];
}
export function toTextLine(original, pageNumber) {
    const appearance = original.appearance !== undefined
        ? {
            styleName: original.appearance.style.name,
            styleConfidence: original.appearance.style.confidence
        }
        : undefined;
    const line = {
        kind: "line",
        pageNumber,
        text: original.text,
        boundingBox: toBoundingBox(original.boundingBox),
        appearance,
        words: original.words.map((w) => {
            return {
                kind: "word",
                text: w.text,
                boundingBox: toBoundingBox(w.boundingBox),
                confidence: w.confidence || 1,
                pageNumber
            };
        })
    };
    return line;
}
export function toSelectionMark(original, pageNumber) {
    return {
        kind: "selectionMark",
        pageNumber,
        boundingBox: toBoundingBox(original.boundingBox),
        confidence: original.confidence,
        state: original.state
    };
}
export function toFormPage(original) {
    var _a, _b;
    return {
        pageNumber: original.pageNumber,
        textAngle: original.angle,
        width: original.width,
        height: original.height,
        unit: original.unit,
        lines: (_a = original.lines) === null || _a === void 0 ? void 0 : _a.map((l) => toTextLine(l, original.pageNumber)),
        selectionMarks: (_b = original.selectionMarks) === null || _b === void 0 ? void 0 : _b.map((m) => toSelectionMark(m, original.pageNumber))
    };
}
// Note: might need to support other element types in future, e.g., checkbox
const textPattern = /\/readResults\/(\d+)\/lines\/(\d+)(?:\/words\/(\d+))?/;
export function toFormContent(element, readResults) {
    const result = textPattern.exec(element);
    if (!result || !result[0] || !result[1] || !result[2]) {
        throw new Error(`Unexpected element reference encountered: ${element}`);
    }
    const readIndex = Number.parseInt(result[1]);
    const lineIndex = Number.parseInt(result[2]);
    if (result[3]) {
        const wordIndex = Number.parseInt(result[3]);
        return readResults[readIndex].lines[lineIndex].words[wordIndex];
    }
    else {
        return readResults[readIndex].lines[lineIndex];
    }
}
export function toFieldData(pageNumber, original, readResults) {
    var _a;
    return {
        pageNumber,
        text: original.text,
        boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
        fieldElements: (_a = original.elements) === null || _a === void 0 ? void 0 : _a.map((element) => toFormContent(element, readResults))
    };
}
export function toFormFieldFromKeyValuePairModel(pageNumber, original, readResults) {
    return {
        name: original.label,
        confidence: original.confidence || 1,
        labelData: toFieldData(pageNumber, original.key, readResults),
        valueData: toFieldData(pageNumber, original.value, readResults),
        value: original.value.text,
        valueType: "string"
    };
}
export function toFormTable(original, readResults, pageNumber) {
    return {
        rowCount: original.rows,
        columnCount: original.columns,
        boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
        cells: original.cells.map((cell) => {
            var _a, _b, _c, _d, _e, _f;
            return ({
                boundingBox: toBoundingBox(cell.boundingBox),
                columnIndex: cell.columnIndex,
                fieldElements: (_a = cell.elements) === null || _a === void 0 ? void 0 : _a.map((element) => toFormContent(element, readResults)),
                rowIndex: cell.rowIndex,
                columnSpan: (_b = cell.columnSpan) !== null && _b !== void 0 ? _b : 1,
                rowSpan: (_c = cell.rowSpan) !== null && _c !== void 0 ? _c : 1,
                isHeader: (_d = cell.isHeader) !== null && _d !== void 0 ? _d : false,
                isFooter: (_e = cell.isFooter) !== null && _e !== void 0 ? _e : false,
                confidence: (_f = cell.confidence) !== null && _f !== void 0 ? _f : 1,
                text: cell.text,
                pageNumber
            });
        }),
        pageNumber
    };
}
export function toFormPages(readResults, pageResults) {
    var _a;
    const transformed = readResults === null || readResults === void 0 ? void 0 : readResults.map(toFormPage);
    // maps from page numbers to the objects
    const pageMap = new Map(pageResults === null || pageResults === void 0 ? void 0 : pageResults.map((r) => [r.pageNumber, r]));
    return ((_a = transformed === null || transformed === void 0 ? void 0 : transformed.map((page) => {
        var _a, _b;
        const { pageNumber } = page;
        const pageResult = pageMap.get(pageNumber);
        return Object.assign(Object.assign({}, page), { tables: (_b = (_a = pageResult === null || pageResult === void 0 ? void 0 : pageResult.tables) === null || _a === void 0 ? void 0 : _a.map((table) => toFormTable(table, transformed, pageNumber))) !== null && _b !== void 0 ? _b : [] });
    })) !== null && _a !== void 0 ? _a : []);
}
export function toRecognizedFormArray(original, expectedDocTypePrefix) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const pages = toFormPages((_a = original.analyzeResult) === null || _a === void 0 ? void 0 : _a.readResults, (_b = original.analyzeResult) === null || _b === void 0 ? void 0 : _b.pageResults);
    if ((_d = (_c = original.analyzeResult) === null || _c === void 0 ? void 0 : _c.documentResults) === null || _d === void 0 ? void 0 : _d.length) {
        // supervised/prebuilt results come from documentResults
        return ((_h = (_g = (_f = (_e = original.analyzeResult) === null || _e === void 0 ? void 0 : _e.documentResults) === null || _f === void 0 ? void 0 : _f.filter((d) => !!d.fields)) === null || _g === void 0 ? void 0 : _g.map((d) => {
            if (expectedDocTypePrefix !== undefined && !d.docType.startsWith(expectedDocTypePrefix)) {
                throw new RangeError(`Expected document type to start with '${expectedDocTypePrefix}', but found '${d.docType}'.`);
            }
            return toRecognizedForm(d, pages);
        })) !== null && _h !== void 0 ? _h : []);
    }
    else {
        // unsupervised results from from pageResults;
        return (_l = (_k = (_j = original.analyzeResult) === null || _j === void 0 ? void 0 : _j.pageResults) === null || _k === void 0 ? void 0 : _k.map((p) => toFormFromPageResult(p, pages))) !== null && _l !== void 0 ? _l : [];
    }
}
export function toFormFieldFromFieldValueModel(original, key, readResults) {
    var _a, _b, _c;
    let value;
    function unreachable(v) {
        throw new Error(`Encountered unknown field value type: ${v}`);
    }
    switch (original.type) {
        case "string":
            value = original.valueString;
            break;
        case "date":
            value = original.valueDate;
            break;
        case "time":
            value = original.valueTime;
            break;
        case "integer":
            value = original.valueInteger;
            break;
        case "number":
            value = original.valueNumber;
            break;
        case "phoneNumber":
            value = original.valuePhoneNumber;
            break;
        case "selectionMark":
            value = original.valueSelectionMark;
            break;
        case "array":
            value = (_a = original.valueArray) === null || _a === void 0 ? void 0 : _a.map((fieldValueModel) => toFormFieldFromFieldValueModel(fieldValueModel, key, readResults));
            break;
        case "object":
            value = original.valueObject
                ? toFieldsFromFieldValue(original.valueObject, readResults)
                : undefined;
            break;
        case "countryRegion":
            value = original.valueCountryRegion;
            break;
        default:
            return unreachable(original.type);
    }
    return {
        confidence: original.confidence || 1,
        name: key,
        valueData: {
            pageNumber: (_b = original.pageNumber) !== null && _b !== void 0 ? _b : 0,
            text: original.text,
            boundingBox: original.boundingBox ? toBoundingBox(original.boundingBox) : undefined,
            fieldElements: (_c = original.elements) === null || _c === void 0 ? void 0 : _c.map((element) => toFormContent(element, readResults))
        },
        valueType: original.type,
        value
    };
}
export function toFieldsFromFieldValue(original, readResults) {
    const result = {};
    for (const key in original) {
        if (Object.prototype.hasOwnProperty.call(original, key)) {
            if (!original[key]) {
                result[key] = { name: key };
                continue;
            }
            const formField = toFormFieldFromFieldValueModel(original[key], key, readResults);
            result[key] = formField;
        }
    }
    return result;
}
export function toFieldsFromKeyValuePairs(pageNumber, original, pages) {
    const result = {};
    for (let i = 0; i < original.length; i++) {
        const pair = original[i];
        const stringField = toFormFieldFromKeyValuePairModel(pageNumber, pair, pages);
        stringField.name = stringField.name || `field-${i}`;
        result[`field-${i}`] = stringField;
    }
    return result;
}
export function toFormFromPageResult(original, pages) {
    return {
        formType: `form-${original.clusterId}`,
        pageRange: { firstPageNumber: original.pageNumber, lastPageNumber: original.pageNumber },
        pages: pages.filter((p) => p.pageNumber === original.pageNumber),
        fields: original.keyValuePairs
            ? toFieldsFromKeyValuePairs(original.pageNumber, original.keyValuePairs, pages)
            : {}
    };
}
export function toRecognizedForm(original, pages) {
    return {
        formType: original.docType,
        formTypeConfidence: original.docTypeConfidence,
        modelId: original.modelId,
        pageRange: { firstPageNumber: original.pageRange[0], lastPageNumber: original.pageRange[1] },
        fields: toFieldsFromFieldValue(original.fields, pages),
        pages: pages.filter((p) => original.pageRange[0] <= p.pageNumber && p.pageNumber <= original.pageRange[1])
    };
}
export function toRecognizeContentResultResponse(original) {
    var _a;
    function toRecognizeContentResult(model) {
        if (!model) {
            return undefined;
        }
        const pages = toFormPages(model.readResults, model.pageResults);
        return {
            version: model.version,
            pages: pages
        };
    }
    const common = {
        status: original.status,
        createdOn: original.createdOn,
        errors: (_a = original.analyzeResult) === null || _a === void 0 ? void 0 : _a.errors,
        lastModified: original.lastModified,
        _response: original._response
    };
    if (original.status === "succeeded") {
        return Object.assign(Object.assign({}, common), toRecognizeContentResult(original.analyzeResult));
    }
    else {
        return common;
    }
}
function flattenTrainingDocuments(original) {
    if (original.composedTrainResults) {
        // Composed model, need to zip the training documents into a flat array and add modelID correlation.
        const mappedResultDocuments = original.composedTrainResults.map((innerResult) => innerResult.trainingDocuments.map((info) => {
            var _a;
            return (Object.assign(Object.assign({}, info), { modelId: innerResult.modelId, errors: (_a = info.errors) !== null && _a !== void 0 ? _a : [] }));
        }));
        return [].concat(...mappedResultDocuments);
    }
    else if (original.trainResult) {
        // Normal training scenario with only one trainResult
        return original.trainResult.trainingDocuments.map((info) => {
            var _a;
            return (Object.assign(Object.assign({}, info), { modelId: original.modelInfo.modelId, errors: (_a = info.errors) !== null && _a !== void 0 ? _a : [] }));
        });
    }
    return undefined;
}
function toSubmodelsFromComposedTrainResults(results) {
    const mappedSubmodels = results.map((r) => toSubmodelsFromTrainResultLabeled(r));
    // Flatten the array
    return [].concat(...mappedSubmodels);
}
function toSubmodelsFromTrainResultLabeled(result, modelName) {
    var _a, _b;
    return [
        {
            modelId: result.modelId,
            accuracy: result.averageModelAccuracy,
            formType: `custom:${modelName !== null && modelName !== void 0 ? modelName : result.modelId}`,
            fields: (_b = (_a = result.fields) === null || _a === void 0 ? void 0 : _a.reduce((fields, field) => {
                fields[field.fieldName] = {
                    name: field.fieldName,
                    accuracy: field.accuracy,
                    label: null
                };
                return fields;
            }, {})) !== null && _b !== void 0 ? _b : {}
        }
    ];
}
function toSubmodelsFromTrainResultUnlabeled(keys, modelId) {
    // Each cluster becomes a submodel
    return Object.entries(keys.clusters).map(([clusterKey, cluster]) => ({
        modelId,
        // Create formType from the key of the cluster
        formType: `form-${clusterKey}`,
        // Roll the fields up into the correct shape
        fields: cluster.reduce((fields, label, idx) => {
            fields[`field-${idx}`] = {
                name: `field-${idx}`,
                label
            };
            return fields;
        }, {})
    }));
}
function flattenCustomFormSubmodels(original) {
    var _a, _b;
    if (original.modelInfo.status === "ready") {
        if (original.composedTrainResults !== undefined) {
            return toSubmodelsFromComposedTrainResults(original.composedTrainResults);
        }
        else if (((_a = original.trainResult) === null || _a === void 0 ? void 0 : _a.fields) || ((_b = original.trainResult) === null || _b === void 0 ? void 0 : _b.averageModelAccuracy)) {
            return toSubmodelsFromTrainResultLabeled(original.trainResult, original.modelInfo.modelName);
        }
        else if (original.keys) {
            return toSubmodelsFromTrainResultUnlabeled(original.keys, original.modelInfo.modelId);
        }
        else {
            throw new Error("No submodel information was found in the training response.");
        }
    }
    return undefined;
}
export function toCustomFormModelProperties(original) {
    if (original) {
        return {
            isComposedModel: original.isComposed
        };
    }
    else {
        return undefined;
    }
}
export function toFormModelResponse(response) {
    var _a;
    return {
        status: response.modelInfo.status,
        modelId: response.modelInfo.modelId,
        modelName: response.modelInfo.modelName,
        trainingStartedOn: response.modelInfo.trainingStartedOn,
        trainingCompletedOn: response.modelInfo.trainingCompletedOn,
        trainingDocuments: flattenTrainingDocuments(response),
        properties: toCustomFormModelProperties(response.modelInfo.attributes),
        errors: (_a = response.trainResult) === null || _a === void 0 ? void 0 : _a.errors,
        submodels: flattenCustomFormSubmodels(response),
        _response: response._response
    };
}
//# sourceMappingURL=transforms.js.map