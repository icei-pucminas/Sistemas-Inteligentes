// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
/**
 * Class that represents a poller that waits until a model has been trained.
 */
export class BeginCopyModelPoller extends Poller {
    constructor(options) {
        const { client, updateIntervalInMs = 5000, modelId, resultId, targetResourceId, targetResourceRegion, copyAuthorization, onProgress, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginCopyModelPollOperation(Object.assign(Object.assign({}, state), { client,
            modelId,
            targetResourceId,
            targetResourceRegion,
            copyAuthorization,
            resultId, status: "notStarted", copyModelOptions: options }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @internal
 */
function makeBeginCopyModelPollOperation(state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const pollerState = this.state;
                const { client, modelId, copyAuthorization, copyModelOptions } = pollerState;
                if (!pollerState.isStarted) {
                    pollerState.isStarted = true;
                    const result = yield client.beginCopyModel(modelId, copyAuthorization, copyModelOptions || {});
                    if (!result.operationLocation) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.operationLocation.lastIndexOf("/");
                    pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);
                }
                const response = yield client.getCopyModelResult(modelId, pollerState.resultId, {
                    abortSignal: copyModelOptions === null || copyModelOptions === void 0 ? void 0 : copyModelOptions.abortSignal
                });
                pollerState.status = response.status;
                if (!pollerState.isCompleted) {
                    if ((response.status === "running" || response.status === "notStarted") &&
                        typeof options.fireProgress === "function") {
                        options.fireProgress(pollerState);
                    }
                    else if (response.status === "succeeded") {
                        pollerState.result = {
                            status: "ready",
                            trainingStartedOn: response.createdOn,
                            trainingCompletedOn: response.lastModified,
                            modelId: copyAuthorization.modelId
                        };
                        pollerState.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        throw new Error(`Copy model operation failed: ${response._response.bodyAsText}`);
                    }
                }
                return makeBeginCopyModelPollOperation(pollerState);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client" || key === "source") {
                    return undefined;
                }
                return value;
            });
        }
    };
}
//# sourceMappingURL=poller.js.map