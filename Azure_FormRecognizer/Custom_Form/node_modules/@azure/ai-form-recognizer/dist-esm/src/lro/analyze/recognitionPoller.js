// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
import { toRecognizedFormArray } from "../../transforms";
/**
 * Create a form recognition poll operation.
 *
 * This operation handles the creation, polling, and transformation of results.
 *
 * @internal
 */
function makeFormRecognitionOperation(description, initialState) {
    const self = {
        state: Object.assign({}, initialState),
        cancel() {
            return __awaiter(this, void 0, void 0, function* () {
                throw new Error("The cancel operation is not supported on this poller.");
            });
        },
        update(options) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const { isStarted, isCompleted, modelId, expectedDocType } = self.state;
                if (!isStarted || !self.state.resultId) {
                    self.state.resultId = yield description.createOperation();
                    self.state.isStarted = true;
                }
                const response = yield description.getResult(self.state.resultId, modelId);
                self.state.status = response.status;
                if (!isCompleted) {
                    // eslint-disable-next-line no-unused-expressions
                    (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, Object.assign({}, self.state));
                    if (response.status === "succeeded") {
                        self.state.result = toRecognizedFormArray(response, (expectedDocType === null || expectedDocType === void 0 ? void 0 : expectedDocType.startsWith("prebuilt:")) ? expectedDocType : undefined);
                        self.state.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        throw new Error([
                            `Failed to recognize forms using the model "${description.modelId}"`,
                            "Error(s):",
                            ...((_d = (_c = (_b = response.analyzeResult) === null || _b === void 0 ? void 0 : _b.errors) === null || _c === void 0 ? void 0 : _c.map((e) => `  Code ${e.code}, message: '${e.message}'`)) !== null && _d !== void 0 ? _d : ["  <empty>"])
                        ].join("\n"));
                    }
                }
                return self;
            });
        },
        // Maintaining the depth of "state" in the serialized poller is
        // important for maintaining compatibility with previous versions
        toString: () => JSON.stringify({ state: self.state })
    };
    return self;
}
const DEFAULT_POLLING_INTERVAL = 5000;
/**
 * A poller for Form Recognition that works for all analysis endpoints
 * that return the basic, weakly-typed `RecognizedFormArray` type.
 */
export class FormRecognitionPoller extends Poller {
    constructor(description) {
        const state = description.resumeFrom
            ? JSON.parse(description.resumeFrom).state
            : {
                modelId: description.modelId,
                status: "notStarted",
                expectedDocType: description.expectedDocType
            };
        super(makeFormRecognitionOperation(description, state));
        if (typeof description.onProgress === "function") {
            this.onProgress(description.onProgress);
        }
        this.options = description;
    }
    /**
     * Delay the poller
     */
    delay() {
        var _a;
        return delay((_a = this.options.updateIntervalInMs) !== null && _a !== void 0 ? _a : DEFAULT_POLLING_INTERVAL);
    }
}
//# sourceMappingURL=recognitionPoller.js.map