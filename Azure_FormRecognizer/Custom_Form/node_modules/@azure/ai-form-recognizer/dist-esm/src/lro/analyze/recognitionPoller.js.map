{"version":3,"file":"recognitionPoller.js","sourceRoot":"","sources":["../../../../src/lro/analyze/recognitionPoller.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  GeneratedClientGetAnalyzeFormResultResponse,\n  OperationStatus\n} from \"../../generated/models\";\nimport { RecognizedFormArray } from \"../../models\";\nimport { toRecognizedFormArray } from \"../../transforms\";\n\n/**\n * Options for Form Recognition shared between prebuilt and custom models.\n */\nexport interface FormPollerOperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  updateIntervalInMs?: number;\n\n  /**\n   * Callback that will receive events related to the progress of the\n   * form recognition operation.\n   */\n  onProgress?: (state: RecognizeFormsOperationState) => void;\n\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Encapsulates the steps to start and query the status of\n * a form recognition operation\n */\nexport interface FormRecognitionOperationClient {\n  /**\n   * Creates the analysis operation on the service\n   */\n  createOperation(): Promise<string>;\n  /**\n   * Returns the results of the operation\n   */\n  getResult(\n    operationId: string,\n    modelId?: string\n  ): Promise<GeneratedClientGetAnalyzeFormResultResponse>;\n}\n\n/**\n * The status of a form recognition operation\n */\nexport interface RecognizeFormsOperationState extends PollOperationState<RecognizedFormArray> {\n  /**\n   * Identifier for the recognition operation.\n   */\n  modelId?: string;\n  /**\n   * Expected document type from recognition.\n   */\n  expectedDocType?: string;\n  /**\n   * Identifier for the recognition operation\n   */\n  resultId?: string;\n  /**\n   * Last-known status of the recognition operation\n   */\n  status: OperationStatus;\n}\n\n/**\n * Create a form recognition poll operation.\n *\n * This operation handles the creation, polling, and transformation of results.\n *\n * @internal\n */\nfunction makeFormRecognitionOperation(\n  description: FormPollerOperationDescription,\n  initialState: RecognizeFormsOperationState\n): PollOperation<typeof initialState, RecognizedFormArray> {\n  const self: PollOperation<typeof initialState, RecognizedFormArray> = {\n    state: { ...initialState },\n    async cancel() {\n      throw new Error(\"The cancel operation is not supported on this poller.\");\n    },\n    async update(options) {\n      const { isStarted, isCompleted, modelId, expectedDocType } = self.state;\n\n      if (!isStarted || !self.state.resultId) {\n        self.state.resultId = await description.createOperation();\n        self.state.isStarted = true;\n      }\n\n      const response = await description.getResult(self.state.resultId, modelId);\n      self.state.status = response.status;\n\n      if (!isCompleted) {\n        // eslint-disable-next-line no-unused-expressions\n        options?.fireProgress?.({ ...self.state });\n\n        if (response.status === \"succeeded\") {\n          self.state.result = toRecognizedFormArray(\n            response,\n            expectedDocType?.startsWith(\"prebuilt:\") ? expectedDocType : undefined\n          );\n          self.state.isCompleted = true;\n        } else if (response.status === \"failed\") {\n          throw new Error(\n            [\n              `Failed to recognize forms using the model \"${description.modelId}\"`,\n              \"Error(s):\",\n              ...(response.analyzeResult?.errors?.map(\n                (e) => `  Code ${e.code}, message: '${e.message}'`\n              ) ?? [\"  <empty>\"])\n            ].join(\"\\n\")\n          );\n        }\n      }\n      return self;\n    },\n    // Maintaining the depth of \"state\" in the serialized poller is\n    // important for maintaining compatibility with previous versions\n    toString: () => JSON.stringify({ state: self.state })\n  };\n\n  return self;\n}\n\n/**\n * Set of intrinsic properties that describe a form recognition polling operation.\n */\nexport type FormPollerOperationDescription = FormPollerOperationOptions &\n  FormRecognitionOperationClient & {\n    /**\n     * The expected document type that should be used to validate recognition\n     * results.\n     */\n    expectedDocType?: string;\n    /**\n     * The model ID that should be used for this poller, if one is required.\n     */\n    modelId?: string;\n  };\n\nconst DEFAULT_POLLING_INTERVAL = 5000;\n\n/**\n * A poller for Form Recognition that works for all analysis endpoints\n * that return the basic, weakly-typed `RecognizedFormArray` type.\n */\nexport class FormRecognitionPoller extends Poller<\n  RecognizeFormsOperationState,\n  RecognizedFormArray\n> {\n  private options: FormPollerOperationOptions;\n\n  constructor(description: FormPollerOperationDescription) {\n    const state: RecognizeFormsOperationState = description.resumeFrom\n      ? JSON.parse(description.resumeFrom).state\n      : {\n          modelId: description.modelId,\n          status: \"notStarted\",\n          expectedDocType: description.expectedDocType\n        };\n\n    super(makeFormRecognitionOperation(description, state));\n\n    if (typeof description.onProgress === \"function\") {\n      this.onProgress(description.onProgress);\n    }\n\n    this.options = description;\n  }\n\n  /**\n   * Delay the poller\n   */\n  public delay(): Promise<void> {\n    return delay(this.options.updateIntervalInMs ?? DEFAULT_POLLING_INTERVAL);\n  }\n}\n"]}