{"version":3,"file":"formRecognizerClient.js","sourceRoot":"","sources":["../../src/formRecognizerClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createPipelineFromOptions,\n  InternalPipelineOptions,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  operationOptionsToRequestOptionsBase,\n  OperationOptions\n} from \"@azure/core-http\";\nimport { TokenCredential, KeyCredential } from \"@azure/core-auth\";\nimport {\n  SDK_VERSION,\n  DEFAULT_COGNITIVE_SCOPE,\n  FormRecognizerLoggingAllowedHeaderNames,\n  FormRecognizerLoggingAllowedQueryParameters\n} from \"./constants\";\nimport { logger } from \"./logger\";\nimport { createSpan } from \"./tracing\";\nimport {\n  FormContentType,\n  FormRecognizerClientOptions,\n  FormRecognizerOperationOptions,\n  toRequestBody,\n  getContentType\n} from \"./common\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\n\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport {\n  GeneratedClientAnalyzeLayoutAsyncResponse as AnalyzeLayoutAsyncResponseModel,\n  SourcePath,\n  OperationStatus,\n  FormReadingOrder\n} from \"./generated/models\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport {\n  RecognizeContentPollerClient,\n  BeginRecognizeContentPoller\n} from \"./lro/analyze/contentPoller\";\nimport {\n  RecognizeFormsOperationState,\n  FormRecognitionPoller\n} from \"./lro/analyze/recognitionPoller\";\nimport { FormRecognizerRequestBody, RecognizedFormArray, FormPageArray } from \"./models\";\nimport { RecognizeContentResultResponse } from \"./internalModels\";\nimport { toRecognizeContentResultResponse } from \"./transforms\";\nimport { createFormRecognizerAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\n\n// #region types\n\n/**\n * Options for content/layout recognition.\n */\nexport type RecognizeContentOptions = FormRecognizerOperationOptions;\n\n/**\n * The state of a recognize content operation\n */\nexport type RecognizeContentOperationState = PollOperationState<FormPageArray> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: OperationStatus;\n};\n\n/**\n * Options for the start content/layout recognition operation\n */\nexport type BeginRecognizeContentOptions = RecognizeContentOptions & {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the content recognition Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeContentOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Content type of the input. Supported types are \"application/pdf\",\n   * \"image/jpeg\", \"image/png\", \"image/tiff\", and \"image/bmp\".\n   */\n  contentType?: FormContentType;\n  /**\n   * The BCP-47 language code of the text in the document.\n   *\n   * See the `KnownFormLanguage` type for a list of known languages that the\n   * service supports.\n   *\n   * Handwritten text is only supported in English ('en').\n   *\n   * Content recognition supports auto language identification and multi\n   * language documents, so only provide a language code if you would like to\n   * override the service's default behavior and force the document to be\n   * processed using a specific language.\n   *\n   * @see KnownFormLanguage\n   */\n  language?: string;\n  /**\n   * The reading order algorithm to use when analyzing the page and sorting\n   * the output text lines. Possible values include \"basic\" (default) and\n   * \"natural\".\n   *\n   * The \"basic\" reading order uses a strict top-to-bottom, left-to-right\n   * reading order.\n   *\n   * The \"natural\" reading order uses positional information and heuristics to\n   * keep nearby lines together.\n   */\n  readingOrder?: FormReadingOrder;\n  /**\n   * Custom page numbers for multi-page documents(PDF/TIFF). If a value is\n   * provided, content information will only be provided for the selected\n   * pages. A range of pages may be denoted using a hyphen.\n   *\n   * For example, to select pages 1, 3 and 5 through 9, set this property to\n   * `[\"1\", \"3\", \"5-9\"]`.\n   */\n  pages?: string[];\n};\n\n/**\n * The Long-Running-Operation (LRO) poller that allows you to wait until form content is recognized.\n */\nexport type ContentPollerLike = PollerLike<PollOperationState<FormPageArray>, FormPageArray>;\n\n/**\n * Options for retrieving recognized content data\n */\ntype GetRecognizedContentResultOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for recognition of forms\n */\nexport interface RecognizeFormsOptions extends FormRecognizerOperationOptions {\n  /**\n   * Specifies whether to include text lines and element references in the result\n   */\n  includeFieldElements?: boolean;\n}\n\n/**\n * Shared options for starting form recognition operations.\n */\nexport interface BeginRecognizeFormsOptions extends RecognizeFormsOptions {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the Recognize Form Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeFormsOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Custom page numbers for multi-page documents(PDF/TIFF). If a value is\n   * provided, content information will only be provided for the selected\n   * pages. A range of pages may be denoted using a hyphen.\n   *\n   * For example, to select pages 1, 3 and 5 through 9, set this property to\n   * `[\"1\", \"3\", \"5-9\"]`.\n   */\n  pages?: string[];\n  /**\n   * Content type of the input. Supported types are \"application/pdf\",\n   * \"image/jpeg\", \"image/png\", \"image/tiff\", and \"image/bmp\".\n   */\n  contentType?: FormContentType;\n}\n\n/**\n * Options for starting the custom form recognition operation.\n */\nexport interface BeginRecognizeCustomFormsOptions extends BeginRecognizeFormsOptions {}\n\n/**\n * Result type of the Recognize Form Long-Running-Operation (LRO)\n */\nexport type FormPollerLike = PollerLike<RecognizeFormsOperationState, RecognizedFormArray>;\n\n/**\n * Options for starting a recognition operation using a prebuilt model.\n */\nexport interface BeginRecognizePrebuiltOptions extends BeginRecognizeFormsOptions {\n  /**\n   * Locale of the document.\n   *\n   * Supported locales include:\n   * - \"en-AU\"\n   * - \"en-CA\"\n   * - \"en-GB\"\n   * - \"en-IN\"\n   * - \"en-US\" (default if none provided)\n   *\n   * @see KnownFormLocale\n   */\n  locale?: string;\n}\n\n/**\n * Options for starting the receipt recognition operation\n */\nexport type BeginRecognizeReceiptsOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the Business Card recognition operation\n */\nexport type BeginRecognizeBusinessCardsOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the Invoice recognition operation\n */\nexport type BeginRecognizeInvoicesOptions = BeginRecognizePrebuiltOptions;\n\n/**\n * Options for starting the ID document recognition operation\n */\nexport type BeginRecognizeIdentityDocumentsOptions = BeginRecognizePrebuiltOptions;\n\n// #endregion\n\n/**\n * Client class for interacting with the Azure Form Recognizer service.\n */\nexport class FormRecognizerClient {\n  /**\n   * URL to an Azure Form Recognizer service endpoint\n   */\n  public readonly endpointUrl: string;\n\n  /**\n   * @internal\n   * A reference to the auto-generated FormRecognizer HTTP client.\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of FormRecognizerClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { FormRecognizerClient, AzureKeyCredential } from \"@azure/ai-form-recognizer\";\n   *\n   * const client = new FormRecognizerClient(\n   *    \"<service endpoint>\",\n   *    new AzureKeyCredential(\"<api key>\")\n   * );\n   * ```\n   *\n   * @param endpointUrl - Url to an Azure Form Recognizer service endpoint\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Form Recognizer client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: FormRecognizerClientOptions = {}\n  ) {\n    this.endpointUrl = endpointUrl;\n    const { ...pipelineOptions } = options;\n\n    const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;\n    if (!pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions = {};\n    }\n    if (pipelineOptions.userAgentOptions.userAgentPrefix) {\n      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;\n    } else {\n      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;\n    }\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)\n      : createFormRecognizerAzureKeyCredentialPolicy(credential);\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,\n          allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n\n    this.client = new GeneratedClient(this.endpointUrl, pipeline);\n  }\n\n  // #region content\n\n  /**\n   * Recognizes content, including text and table structure from a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_7.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContent(readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   * Recognizes content/layout information from a given document\n   * @param form - Input document\n   * @param options - Options to start content recognition operation\n   */\n  public async beginRecognizeContent(\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const client: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    const poller = new BeginRecognizeContentPoller({\n      client,\n      source: form,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes content, including text and table structure from a url to a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContentFromUrl(url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes content/layout information from a url to a form document\n   * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the content recognition operation\n   */\n  public async beginRecognizeContentFromUrl(\n    formUrl: string,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const client: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const poller = new BeginRecognizeContentPoller({\n      client,\n      source: formUrl,\n      ...options,\n      contentType: undefined\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Retrieves result of content recognition operation.\n   * @internal\n   */\n  private async getRecognizedContent(\n    resultId: string,\n    options?: GetRecognizedContentResultOptions\n  ): Promise<RecognizeContentResultResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormRecognizerClient-getRecognizedLayoutResult\",\n      realOptions\n    );\n\n    try {\n      const requestOptions = operationOptionsToRequestOptionsBase(finalOptions);\n      const analyzeResult = await this.client.getAnalyzeLayoutResult(resultId, requestOptions);\n      return toRecognizeContentResultResponse(analyzeResult);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // #endregion\n\n  // #region customforms\n\n  /**\n   * Recognizes forms from a given document using a custom form model from training.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_6.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomForms(modelId, readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   * Recognizes form information from a given document using a custom form model.\n   * @param modelId - Id of the custom form model to use\n   * @param form - Input form document\n   * @param options - Options to start the form recognition operation\n   */\n  public async beginRecognizeCustomForms(\n    modelId: string,\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeCustomFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid model id\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeCustomForms\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      modelId,\n      createOperation: span(\"customFormsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(form);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeWithCustomModel(\n            modelId,\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getCustomForms\", async (finalOptions, resultId, modelIdParam) =>\n        // using the modelId from the parameter here is important, as we could be restoring from\n        // a suspended LRO\n        this.client.getAnalyzeFormResult(\n          // Must be defined to have reached this point, but only for custom form recognition\n          modelIdParam!,\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes forms from a URL to a document using a custom form model from training.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes form information from a url to a document using a custom form model.\n   * @param modelId - Id of the custom form model to use\n   * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeCustomFormsFromUrl(\n    modelId: string,\n    formUrl: string,\n    options: BeginRecognizeCustomFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid model id\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeCustomForms\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      modelId,\n      createOperation: span(\"customFormsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeWithCustomModel(modelId, \"application/json\", {\n            fileStream: {\n              source: formUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getCustomForms\", async (finalOptions, resultId, modelIdParam) =>\n        // using the modelId from the parameter here is important, as we could be restoring from\n        // a suspended LRO\n        this.client.getAnalyzeFormResult(\n          // Must be defined to have reached this point, but only for custom form recognition\n          modelIdParam!,\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::businesscard\n\n  /**\n   * Recognizes data from business cards using a pre-built business card model, enabling you to extract structured data\n   * from business cards such as name, job title, phone numbers, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the\n   * following link: https://aka.ms/formrecognizer/businesscardfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./business-card-english.png\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeBusinessCards(readStream, {\n   *   contentType: \"image/png\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [businessCard] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes business card information from a given document\n   * @param businessCard - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeBusinessCards(\n    businessCard: FormRecognizerRequestBody,\n    options: BeginRecognizeBusinessCardsOptions = { includeFieldElements: false }\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeBusinessCards\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:businesscard\",\n      createOperation: span(\"businessCardsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(businessCard);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeBusinessCardAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getBusinessCards\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeBusinessCardResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes business card information from a url using a pre-built business card model, enabling you to extract structured data\n   * from business cards such as name, job title, phone numbers, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/businesscardfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the business card document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeBusinessCardsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [businessCard] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes business card information from a given accessible url to a document\n   * @param businessCardUrl - Url to a business card document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeBusinessCardsFromUrl(\n    businessCardUrl: string,\n    options: BeginRecognizeBusinessCardsOptions = { includeFieldElements: false }\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeBusinessCardsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:businesscard\",\n      createOperation: span(\"businessCardsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeBusinessCardAsync(\"application/json\", {\n            fileStream: {\n              source: businessCardUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getBusinessCards\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeBusinessCardResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::invoice\n\n  /**\n   * Recognizes data from invoices using a pre-built invoice model, enabling you to extract structured data\n   * from invoices such as customer address, vendor address, purchase order ID, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_1.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeInvoices(readStream, {\n   *   contentType: \"application/pdf\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [invoice] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes invoice information from a given document\n   * @param invoice - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeInvoices(\n    invoice: FormRecognizerRequestBody,\n    options: BeginRecognizeInvoicesOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeInvoices\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:invoice\",\n      createOperation: span(\"invoicesInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(invoice);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeInvoiceAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getInvoices\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeInvoiceResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes invoice information from a URL using a pre-built invoice model, enabling you to extract structured data\n   * from invoices such as customer address, vendor address, purchase order ID, etc.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the invoice document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeInvoicesFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [invoice] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes invoice information from a given accessible url to a document\n   * @param invoiceUrl - Url to an invoice document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeInvoicesFromUrl(\n    invoiceUrl: string,\n    options: BeginRecognizeInvoicesOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeInvoicesFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:invoice\",\n      createOperation: span(\"invoicesInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeInvoiceAsync(\"application/json\", {\n            fileStream: {\n              source: invoiceUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getInvoices\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeInvoiceResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::identityDocument\n\n  /**\n   * Recognizes data from identification documents using a pre-built ID\n   * document model, enabling you to extract structured data from ID documents\n   * such as first/last name, document number, expiration date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to\n   * the documentation at the following link:\n   * https://aka.ms/formrecognizer/iddocumentfields\n   *\n   * This method returns a long running operation poller that allows you to\n   * wait indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation\n   * completes in the first request, and attempting to cancel a completed copy\n   * will result in an error being thrown.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * const path = \"./license.jpg\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeIdentityDocuments(readStream, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [identityDocument] = await poller.pollUntilDone();\n   * ```\n   *\n   * @param identityDocument - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeIdentityDocuments(\n    identityDocument: FormRecognizerRequestBody,\n    options: BeginRecognizeIdentityDocumentsOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeIdentityDocuments\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:idDocument\",\n      createOperation: span(\"identityDocumentsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(identityDocument);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeIdDocumentAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getIdentityDocuments\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeIdDocumentResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes identity document information from a url using pre-built ID\n   * document model, enabling you to extract structured data from ID documents\n   * such as first/last name, document number, expiration date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to\n   * the documentation at the following link:\n   * https://aka.ms/formrecognizer/iddocumentfields\n   *\n   * This method returns a long running operation poller that allows you to\n   * wait indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation\n   * completes in the first request, and attempting to cancel a completed copy\n   * will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the identity document>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeIdentityDocumentsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   *\n   * const [identityDocument] = await poller.pollUntilDone();\n   * ```\n   *\n   * @param identityDocumentUrl - Url to an identity document that is accessible from\n   * the service. Must be a valid, encoded URL to a document of a supported\n   * content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeIdentityDocumentsFromUrl(\n    identityDocumentUrl: string,\n    options: BeginRecognizeIdentityDocumentsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeIdentityDocumentsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:idDocument\",\n      createOperation: span(\"identityDocumentsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeIdDocumentAsync(\"application/json\", {\n            fileStream: {\n              source: identityDocumentUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getIdDocuments\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeIdDocumentResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n\n  // #region prebuilt::receipt\n\n  /**\n   * Recognizes data from receipts using a pre-built receipt model, enabling you to extract structured data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./contoso-allinone.jpg\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceipts(readStream, {\n   *   contentType: \"image/jpeg\",\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const [receipt] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes receipt information from a given document\n   * @param receipt - Input document\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeReceipts(\n    receipt: FormRecognizerRequestBody,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeReceipts\", {\n      ...options,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:receipt\",\n      createOperation: span(\"receiptsInternal\", async (finalOptions) => {\n        const requestBody = await toRequestBody(receipt);\n        const contentType = finalOptions.contentType ?? (await getContentType(requestBody));\n        return processOperationLocation(\n          await this.client.analyzeReceiptAsync(\n            contentType!,\n            requestBody as Blob | ArrayBuffer | ArrayBufferView,\n            operationOptionsToRequestOptionsBase(finalOptions)\n          )\n        );\n      }),\n      getResult: span(\"getReceipts\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeReceiptResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the documentation at the\n   * following link: https://aka.ms/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   *\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the receipt document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceiptsFromUrl(url, {\n   *   includeFieldElements: true,\n   *   onProgress: (state) => {\n   *     console.log(`analyzing status: ${state.status}`);\n   *   }\n   * });\n   * const [receipt] = await poller.pollUntilDone();\n   * ```\n   *\n   * Recognizes receipt information from a given accessible url to a document\n   * @param receiptUrl - Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.\n   * @param options - Options for the recognition operation\n   */\n  public async beginRecognizeReceiptsFromUrl(\n    receiptUrl: string,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const { span } = makeSpanner(\"FormRecognizerClient-beginRecognizeReceiptsFromUrl\", {\n      ...options,\n      contentType: undefined,\n      includeTextDetails: options.includeFieldElements\n    });\n\n    const poller = new FormRecognitionPoller({\n      expectedDocType: \"prebuilt:receipt\",\n      createOperation: span(\"receiptsInternal\", async (finalOptions) => {\n        return processOperationLocation(\n          await this.client.analyzeReceiptAsync(\"application/json\", {\n            fileStream: {\n              source: receiptUrl\n            },\n            ...operationOptionsToRequestOptionsBase(finalOptions)\n          })\n        );\n      }),\n      getResult: span(\"getReceipts\", async (finalOptions, resultId) =>\n        this.client.getAnalyzeReceiptResult(\n          resultId,\n          operationOptionsToRequestOptionsBase(finalOptions)\n        )\n      ),\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  // #endregion\n}\n\n/**\n * An operation that can be queried.\n *\n * @internal\n */\ninterface RemoteOperation {\n  operationLocation?: string;\n}\n\n/**\n * Validates a remote operation's location is defined and extracts the\n * result ID from it.\n *\n * @param remoteOperation - The operation to process\n * @returns The remote operation ID\n *\n * @internal\n */\nfunction processOperationLocation({ operationLocation }: RemoteOperation): string {\n  if (!operationLocation) {\n    throw new Error(\"The service did not respond with an 'operationLocation' to retrieve results.\");\n  } else {\n    const lastSlashIndex = operationLocation.lastIndexOf(\"/\");\n    return operationLocation.substring(lastSlashIndex + 1);\n  }\n}\n\n/**\n * Type of the auto-spanner returned by `makeSpanner`\n *\n * @internal\n */\ninterface Spanner<Options> {\n  /**\n   * Invokes a handler in the context of a span. When the handler is called,\n   * an argument will be inserted at the beginning of the arguments list\n   * containing the `options` that may have been updated by the tracer.\n   *\n   * @param name - The name of this span, which will appear in the trace.\n   * @param handler - The handler to run. Its first parameter will have the\n   *   type of `options` that were passed to `makeSpanner`\n   *\n   * @returns A function that will wrap a call to the `handler` in tracing code, forwarding its parameters\n   */\n  span<Args extends unknown[], Result>(\n    name: string,\n    handler: (updatedOptions: Options, ...rest: Args) => Result\n  ): (...args: Args) => Result;\n}\n\n/**\n * Helper function to create spans for internal polling handlers\n *\n * The argument is a handler function that will be wrapped in a tracing\n * span, where tracing-updated options will be inserted as its first parameter.\n *\n * @example\n * ```typescript\n * const spanned = makeSpanner(\"FormRecognizerClient-beginRecognizeReceipts\", {\n *   ...options,\n *   // Override any options you need here\n * });\n *\n * const autoSpannedFunction = spanner(\"autoSpannedFunction\", (updatedOptions) => {\n *  // ...\n * });\n * ```\n *\n * @internal\n */\nfunction makeSpanner<Options extends OperationOptions>(\n  prefix: string,\n  options: Options\n): Spanner<Options> {\n  return {\n    span: (name, handler) => (...args) => {\n      const { span, updatedOptions } = createSpan(`${prefix}-${name}`, options);\n\n      try {\n        return handler(updatedOptions, ...args);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    }\n  };\n}\n\n/**\n * The worker function of layout analysis.\n *\n * @internal\n */\nasync function recognizeLayoutInternal(\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  client: GeneratedClient,\n  body: FormRecognizerRequestBody | string,\n  contentType?: FormContentType,\n  options?: RecognizeContentOptions,\n  _modelId?: string\n): Promise<AnalyzeLayoutAsyncResponseModel> {\n  const realOptions = options || {};\n  const { span, updatedOptions: finalOptions } = createSpan(\"analyzeLayoutInternal\", realOptions);\n  const requestBody = await toRequestBody(body);\n  const requestContentType = contentType ? contentType : await getContentType(requestBody);\n\n  try {\n    if (requestContentType) {\n      return await client.analyzeLayoutAsync(\n        requestContentType,\n        requestBody as Blob | ArrayBuffer | ArrayBufferView,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    }\n    return await client.analyzeLayoutAsync(\"application/json\", {\n      fileStream: requestBody as SourcePath,\n      ...operationOptionsToRequestOptionsBase(finalOptions)\n    });\n  } catch (e) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n"]}