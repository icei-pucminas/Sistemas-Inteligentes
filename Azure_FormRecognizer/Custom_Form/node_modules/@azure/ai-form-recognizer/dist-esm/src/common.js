// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { getFirstFourBytesFromBlob, streamToBuffer } from "./utils/utils.node";
import { MAX_INPUT_DOCUMENT_SIZE } from "./constants";
/**
 * Translate the content to a format that is understood by Form Recognizer service
 * @internal
 */
export function toRequestBody(body) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof body === "string") {
            return {
                source: body
            };
        }
        else {
            // cache stream to allow retry
            if (isReadableStream(body)) {
                return streamToBuffer(body, MAX_INPUT_DOCUMENT_SIZE);
            }
            return body;
        }
    });
}
function isReadableStream(data) {
    return "read" in data && typeof data.read === "function";
}
function isBlob(data) {
    return "size" in data && "type" in data;
}
function isArrayBuffer(data) {
    return "byteLength" in data && "slice" in data && typeof data.slice === "function";
}
function isArrayBufferView(data) {
    return "buffer" in data && "byteLength" in data && "byteOffset" in data;
}
function isSourcePath(data) {
    return "source" in data && typeof data.source === "string";
}
/**
 * Detects the content type of binary data.
 * See https://en.wikipedia.org/wiki/List_of_file_signatures
 * @internal
 */
export function getContentType(data) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isSourcePath(data)) {
            return undefined;
        }
        let bytes;
        if (isArrayBuffer(data)) {
            // ArrayBuffer
            if (data.byteLength < 4) {
                throw new RangeError("Invalid input. Expect more than 4 bytes of data");
            }
            bytes = new Uint8Array(data, 0, 4);
        }
        else if (isArrayBufferView(data)) {
            // ArrayBufferView
            if (data.byteLength < 4) {
                throw new RangeError("Invalid input. Expect more than 4 bytes of data");
            }
            bytes = new Uint8Array(data.buffer, 0, 4);
        }
        else if (isBlob(data)) {
            // Blob
            bytes = yield getFirstFourBytesFromBlob(data);
        }
        else {
            throw new Error("unsupported request body type");
        }
        if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {
            return "application/pdf";
        }
        else if (bytes[0] === 0xff && bytes[1] === 0xd8) {
            return "image/jpeg";
        }
        else if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47) {
            return "image/png";
        }
        else if ((bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2a && bytes[3] === 0x0) ||
            (bytes[0] === 0x4d && bytes[1] === 0x4d && bytes[2] === 0x0 && bytes[3] === 0x2a)) {
            return "image/tiff";
        }
        else if (bytes[0] === 0x42 && bytes[1] === 0x4d) {
            return "image/bmp";
        }
        else {
            throw new RangeError("content type could not be detected");
        }
    });
}
//# sourceMappingURL=common.js.map