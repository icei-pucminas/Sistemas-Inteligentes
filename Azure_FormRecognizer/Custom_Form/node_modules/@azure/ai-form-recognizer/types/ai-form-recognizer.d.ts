/// <reference types="node" />
/// <reference lib="esnext.asynciterable" />
import { AzureKeyCredential } from '@azure/core-auth';
import * as coreHttp from '@azure/core-http';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RestResponse } from '@azure/core-http';
import { TokenCredential } from '@azure/core-auth';

/**
 * Summary of all models in the cognitive service account.
 */
export declare interface AccountProperties {
    /**
     * Current count of trained custom models.
     */
    customModelCount: number;
    /**
     * Max number of models that can be trained for this account.
     */
    customModelLimit: number;
}
export { AzureKeyCredential }

/**
 * Options for begin copy model operation
 */
export declare type BeginCopyModelOptions = FormRecognizerOperationOptions & FormTrainingPollOperationOptions<CopyModelOperationState>;

/**
 * Options for creating a composed model from submodels.
 */
export declare type BeginCreateComposedModelOptions = FormRecognizerOperationOptions & FormTrainingPollOperationOptions<TrainingOperationState> & {
    /**
     * An optional name to associate with the composed model.
     *
     * Individual models that are part of the composition will retain their original names.
     */
    modelName?: string;
};

/**
 * Options for starting the Business Card recognition operation
 */
export declare type BeginRecognizeBusinessCardsOptions = BeginRecognizePrebuiltOptions;

/**
 * Options for the start content/layout recognition operation
 */
export declare type BeginRecognizeContentOptions = RecognizeContentOptions & {
    /**
     * Delay to wait until next poll, in milliseconds
     */
    updateIntervalInMs?: number;
    /**
     * Callback to progress events triggered in the content recognition Long-Running-Operation (LRO)
     */
    onProgress?: (state: RecognizeContentOperationState) => void;
    /**
     * A serialized poller which can be used to resume an existing paused Long-Running-Operation.
     */
    resumeFrom?: string;
    /**
     * Content type of the input. Supported types are "application/pdf",
     * "image/jpeg", "image/png", "image/tiff", and "image/bmp".
     */
    contentType?: FormContentType;
    /**
     * The BCP-47 language code of the text in the document.
     *
     * See the `KnownFormLanguage` type for a list of known languages that the
     * service supports.
     *
     * Handwritten text is only supported in English ('en').
     *
     * Content recognition supports auto language identification and multi
     * language documents, so only provide a language code if you would like to
     * override the service's default behavior and force the document to be
     * processed using a specific language.
     *
     * @see KnownFormLanguage
     */
    language?: string;
    /**
     * The reading order algorithm to use when analyzing the page and sorting
     * the output text lines. Possible values include "basic" (default) and
     * "natural".
     *
     * The "basic" reading order uses a strict top-to-bottom, left-to-right
     * reading order.
     *
     * The "natural" reading order uses positional information and heuristics to
     * keep nearby lines together.
     */
    readingOrder?: FormReadingOrder;
    /**
     * Custom page numbers for multi-page documents(PDF/TIFF). If a value is
     * provided, content information will only be provided for the selected
     * pages. A range of pages may be denoted using a hyphen.
     *
     * For example, to select pages 1, 3 and 5 through 9, set this property to
     * `["1", "3", "5-9"]`.
     */
    pages?: string[];
};

/**
 * Options for starting the custom form recognition operation.
 */
export declare interface BeginRecognizeCustomFormsOptions extends BeginRecognizeFormsOptions {
}

/**
 * Shared options for starting form recognition operations.
 */
export declare interface BeginRecognizeFormsOptions extends RecognizeFormsOptions {
    /**
     * Delay to wait until next poll, in milliseconds
     */
    updateIntervalInMs?: number;
    /**
     * Callback to progress events triggered in the Recognize Form Long-Running-Operation (LRO)
     */
    onProgress?: (state: RecognizeFormsOperationState) => void;
    /**
     * A serialized poller which can be used to resume an existing paused Long-Running-Operation.
     */
    resumeFrom?: string;
    /**
     * Custom page numbers for multi-page documents(PDF/TIFF). If a value is
     * provided, content information will only be provided for the selected
     * pages. A range of pages may be denoted using a hyphen.
     *
     * For example, to select pages 1, 3 and 5 through 9, set this property to
     * `["1", "3", "5-9"]`.
     */
    pages?: string[];
    /**
     * Content type of the input. Supported types are "application/pdf",
     * "image/jpeg", "image/png", "image/tiff", and "image/bmp".
     */
    contentType?: FormContentType;
}

/**
 * Options for starting the ID document recognition operation
 */
export declare type BeginRecognizeIdentityDocumentsOptions = BeginRecognizePrebuiltOptions;

/**
 * Options for starting the Invoice recognition operation
 */
export declare type BeginRecognizeInvoicesOptions = BeginRecognizePrebuiltOptions;

/**
 * Options for starting a recognition operation using a prebuilt model.
 */
export declare interface BeginRecognizePrebuiltOptions extends BeginRecognizeFormsOptions {
    /**
     * Locale of the document.
     *
     * Supported locales include:
     * - "en-AU"
     * - "en-CA"
     * - "en-GB"
     * - "en-IN"
     * - "en-US" (default if none provided)
     *
     * @see KnownFormLocale
     */
    locale?: string;
}

/**
 * Options for starting the receipt recognition operation
 */
export declare type BeginRecognizeReceiptsOptions = BeginRecognizePrebuiltOptions;

/**
 * Options for starting model training operation.
 */
export declare type BeginTrainingOptions = TrainingFileFilter & FormTrainingPollOperationOptions<TrainingOperationState> & {
    /**
     * An optional name to associate with the model
     */
    modelName?: string;
};

/**
 * Properties common to the recognized text field
 */
export declare interface CommonFieldValue {
    /**
     * Text content of the recognized field.
     */
    text?: string;
    /**
     * Bounding box of the field value, if appropriate.
     */
    boundingBox?: Point2D[];
    /**
     * Confidence score.
     */
    confidence?: number;
    /**
     * When includeFieldElements is set to true, a list of references to the elements constituting
     * this field.
     */
    fieldElements?: FormElement[];
    /**
     * The 1-based page number in the input document.
     */
    pageNumber?: number;
}

/**
 * The Long-Running-Operation (LRO) poller that allows you to wait until form content is recognized.
 */
export declare type ContentPollerLike = PollerLike<PollOperationState<FormPageArray>, FormPageArray>;

/**
 * Request parameter that contains authorization claims for copy operation.
 */
export declare interface CopyAuthorization {
    /**
     * Model identifier.
     */
    modelId: string;
    /**
     * Token claim used to authorize the copy request.
     */
    accessToken: string;
    /**
     * Target resource Id.
     */
    resourceId: string;
    /**
     * Target resource region.
     */
    resourceRegion: string;
    /**
     * The time when the access token expires.
     */
    expiresOn: Date;
}

/**
 * The status of a copy model operation
 */
export declare type CopyModelOperationState = PollOperationState<CustomFormModel> & {
    /**
     * A string representing the current status of the operation.
     */
    status: OperationStatus;
};

/**
 * Options for the copy custom model operation.
 */
export declare type CopyModelOptions = FormRecognizerOperationOptions;

/**
 * Represents a model from training.
 */
export declare interface CustomFormModel extends CustomFormModelInfo {
    /**
     * List of document used to train the model and any errors reported for each document.
     */
    trainingDocuments?: TrainingDocumentInfo[];
    /**
     * Errors returned during training operation.
     */
    errors?: FormRecognizerError[];
    /**
     * Form models created by training.
     */
    submodels?: CustomFormSubmodel[];
}

/**
 * Information about an identified field within a model.
 */
export declare interface CustomFormModelField {
    /**
     * Estimated extraction accuracy for this field.
     */
    accuracy?: number;
    /**
     * Training field name.
     */
    name: string;
    /**
     * Training field label.
     */
    label: string | null;
}

/**
 * Basic custom model information.
 */
export declare interface CustomFormModelInfo {
    /**
     * Model identifier.
     */
    modelId: string;
    /**
     * The name of the model that was provided during model training.
     *
     * Model names are not guaranteed to be unique.
     */
    modelName?: string;
    /**
     * Optional properties or flags associated with the model.
     */
    properties?: CustomFormModelProperties;
    /**
     * Status of the model.
     */
    status: ModelStatus;
    /**
     * Date and time (UTC) when the custom model training started.
     */
    trainingStartedOn: Date;
    /**
     * Date and time (UTC) when the training operation completed.
     */
    trainingCompletedOn: Date;
}

/**
 * Optional properties of a custom form model.
 */
export declare interface CustomFormModelProperties {
    /**
     * Indicates whether or not the model was composed.
     */
    isComposedModel?: boolean;
}

/**
 * Represents the model for a specific type of custom form from training.
 */
export declare interface CustomFormSubmodel {
    /**
     * The model ID associated with this submodel.
     */
    modelId?: string;
    /**
     * Estimated extraction accuracy for this model.
     */
    accuracy?: number;
    /**
     * Form fields
     */
    fields: Record<string, CustomFormModelField>;
    /**
     * The form type associated with this submodel.
     */
    formType: string;
}

/**
 * Options for the delete model operation.
 */
export declare type DeleteModelOptions = FormRecognizerOperationOptions;

/**
 * Represents recognized elements of label-value pairs.
 *
 * For example, "Work Address" is the label of "Work Address: One Microsoft Way, Redmond, WA"
 */
export declare interface FieldData {
    /**
     * The 1-based page number in the input document.
     */
    pageNumber: number;
    /**
     * The bounding box of the recognized label or value
     */
    boundingBox?: Point2D[];
    /**
     * When includeFieldElements is set to true, a list of references to the
     * form elements that constitute this label-value pair.
     */
    fieldElements?: FormElement[];
    /**
     * The text content of the recognized label or value
     */
    text?: string;
}

/**
 * A form field with an array of FormFields as a value.
 */
export declare interface FormArrayField extends FormFieldCommon {
    /**
     * The type of this field's value - "array"
     */
    valueType: "array";
    /**
     * The recognized array of nested fields. Each value in this array is its
     * own `FormField`.
     */
    value?: FormField[];
}

/**
 * Content types supported by Form Recognizer service.
 */
export declare type FormContentType = "application/pdf" | "image/jpeg" | "image/png" | "image/tiff" | "image/bmp";

/**
 * A form field with a value representing an administrative region or country
 * in the world.
 */
export declare interface FormCountryRegionField extends FormFieldCommon {
    /**
     * The type of this field's value - "countryRegion"
     */
    valueType: "countryRegion";
    /**
     * The recognized country or region, represented by a three-letter (ISO
     * 3166-1 alpha-3) code.
     */
    value?: string;
}

/**
 * A form field with a value representing a date.
 */
export declare interface FormDateField extends FormFieldCommon {
    /**
     * The type of this field's value - "date"
     */
    valueType: "date";
    /**
     * The value of the date field, represented as a JavaScript date object.
     */
    value?: Date;
}

/**
 * Information about a recognized element in the form. Examples include
 * words, lines, checkbox, etc.
 */
export declare type FormElement = FormWord | FormLine | FormSelectionMark;

/**
 * Represents common properties of recognized form elements.
 */
export declare interface FormElementCommon {
    /**
     * The 1-based page number in the input document.
     */
    pageNumber: number;
    /**
     * Bounding box of a recognized word.
     */
    boundingBox: Point2D[];
    /**
     * Optional text content of the form element.
     */
    text?: string;
}

/**
 * A field recognized within a form, represented as a tagged union of several
 * different types of form fields, all sharing some common elements.
 *
 * The `valueType` property of this object can be used to determine which
 * variation of FormField was recognized. For example, if the `valueType`
 * property is "number", then the FormField is a FormNumberField, and the
 * `value` property will be a `number`.
 */
export declare type FormField = FormUnknownField | FormStringField | FormNumberField | FormDateField | FormTimeField | FormPhoneNumberField | FormIntegerField | FormSelectionMarkField | FormArrayField | FormObjectField | FormCountryRegionField;

/**
 * Fields common to all variations of FormField.
 */
export declare interface FormFieldCommon {
    /**
     * The sevice's confidence (expressed as a number between zero and one) in
     * the correctness of the field value.
     */
    confidence?: number;
    /**
     * Contains the recognized field label's text, bounding box, and field elements.
     */
    labelData?: FieldData;
    /**
     * A user-defined label for the field.
     */
    name?: string;
    /**
     * Contains the recognized field value's text, bounding box, and field elements.
     */
    valueData?: FieldData;
}

/** Report for a custom model training field. */
export declare interface FormFieldsReport {
    /** Training field name. */
    fieldName: string;
    /** Estimated extraction accuracy for this field. */
    accuracy: number;
}

/**
 * A form field with an integer value.
 */
export declare interface FormIntegerField extends FormFieldCommon {
    /**
     * The type of this field's value - "integer"
     */
    valueType: "integer";
    /**
     * The value of the recognized integer.
     */
    value?: number;
}

/**
 * Represents a recognized text line.
 */
export declare interface FormLine extends FormElementCommon {
    /**
     * Element kind - "line"
     */
    kind: "line";
    /**
     * The text content of the line.
     */
    text: string;
    /**
     * List of words in the text line.
     */
    words: FormWord[];
    /**
     * Text appearance properties, such as style.
     */
    appearance?: TextAppearance;
}

/**
 * Contains the response data for retrieving a model from unlabeled training.
 */
export declare type FormModelResponse = CustomFormModel & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: Model;
    };
};

/**
 * A form field with a numeric value.
 */
export declare interface FormNumberField extends FormFieldCommon {
    /**
     * The type of this field's value - "number"
     */
    valueType: "number";
    /**
     * The value of the recognized number.
     */
    value?: number;
}

/**
 * A form field with a key-value map (an "object") as a value.
 */
export declare interface FormObjectField extends FormFieldCommon {
    /**
     * The type of this field's value - "object"
     */
    valueType: "object";
    /**
     * The recognized object structure of the field, represented as a JavaScript
     * object with the nested fields' names as properties that store their
     * values.
     */
    value?: Record<string, FormField>;
}

/**
 * Raw texts recognized from a page in the input document.
 */
export declare interface FormPage {
    /**
     * The 1-based page number in the input document.
     */
    pageNumber: number;
    /**
     * The general orientation of the text in clockwise direction, measured in degrees between (-180,
     * 180].
     */
    textAngle: number;
    /**
     * The width of the image/PDF in pixels/inches, respectively.
     */
    width: number;
    /**
     * The height of the image/PDF in pixels/inches, respectively.
     */
    height: number;
    /**
     * The unit used by the width, height and boundingBox properties. For images, the unit is
     * "pixel". For PDF, the unit is "inch". Possible values include: 'pixel', 'inch'
     */
    unit: LengthUnit;
    /**
     * When `includeFieldElements` is set to true, a list of recognized text lines. The maximum number of
     * lines returned is 300 per page. The lines are sorted top to bottom, left to right, although in
     * certain cases proximity is treated with higher priority. As the sorting order depends on the
     * detected text, it may change across images and OCR version updates. Thus, business logic
     * should be built upon the actual line location instead of order.
     */
    lines?: FormLine[];
    /**
     * List of data tables recognized in the page
     */
    tables?: FormTable[];
    /**
     * List of selection marks recognized in the page
     */
    selectionMarks?: FormSelectionMark[];
}

/**
 * Array of {@link FormPage}
 */
export declare interface FormPageArray extends Array<FormPage> {
}

/**
 * Represents a Form page range
 */
export declare interface FormPageRange {
    /**
     * The page number of the first page in the range
     */
    firstPageNumber: number;
    /**
     * The page number of the last page in the range
     */
    lastPageNumber: number;
}

/**
 * A form field with a value representing a phone number.
 */
export declare interface FormPhoneNumberField extends FormFieldCommon {
    /**
     * The type of this field's value - "phoneNumber"
     */
    valueType: "phoneNumber";
    /**
     * The value of the recognized phone number, represented as a string.
     *
     * This value is normalized to a uniform string representation, e.g.
     * "+447911123456". If the service is unable to normalize the value,
     * information about the phone number's textual appearance may appear in the
     * `text` property of the value data (see the `valueData` field of this
     * object).
     */
    value?: string;
}

/**
 * Result type of the Recognize Form Long-Running-Operation (LRO)
 */
export declare type FormPollerLike = PollerLike<RecognizeFormsOperationState, RecognizedFormArray>;

/** Defines values for FormReadingOrder. */
export declare type FormReadingOrder = "basic" | "natural";

/**
 * Client class for interacting with the Azure Form Recognizer service.
 */
export declare class FormRecognizerClient {
    /**
     * URL to an Azure Form Recognizer service endpoint
     */
    readonly endpointUrl: string;
    /* Excluded from this release type: client */
    /**
     * Creates an instance of FormRecognizerClient.
     *
     * Example usage:
     * ```ts
     * import { FormRecognizerClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormRecognizerClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     *
     * @param endpointUrl - Url to an Azure Form Recognizer service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl: string, credential: TokenCredential | KeyCredential, options?: FormRecognizerClientOptions);
    /**
     * Recognizes content, including text and table structure from a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_7.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContent(readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     * Recognizes content/layout information from a given document
     * @param form - Input document
     * @param options - Options to start content recognition operation
     */
    beginRecognizeContent(form: FormRecognizerRequestBody, options?: BeginRecognizeContentOptions): Promise<ContentPollerLike>;
    /**
     * Recognizes content, including text and table structure from a url to a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContentFromUrl(url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     *
     * Recognizes content/layout information from a url to a form document
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the content recognition operation
     */
    beginRecognizeContentFromUrl(formUrl: string, options?: BeginRecognizeContentOptions): Promise<ContentPollerLike>;
    /* Excluded from this release type: getRecognizedContent */
    /**
     * Recognizes forms from a given document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_6.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomForms(modelId, readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     * Recognizes form information from a given document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param form - Input form document
     * @param options - Options to start the form recognition operation
     */
    beginRecognizeCustomForms(modelId: string, form: FormRecognizerRequestBody, options?: BeginRecognizeCustomFormsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes forms from a URL to a document using a custom form model from training.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     *
     * Recognizes form information from a url to a document using a custom form model.
     * @param modelId - Id of the custom form model to use
     * @param formUrl - Url to a document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeCustomFormsFromUrl(modelId: string, formUrl: string, options?: BeginRecognizeCustomFormsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes data from business cards using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./business-card-english.png";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCards(readStream, {
     *   contentType: "image/png",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given document
     * @param businessCard - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCards(businessCard: FormRecognizerRequestBody, options?: BeginRecognizeBusinessCardsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes business card information from a url using a pre-built business card model, enabling you to extract structured data
     * from business cards such as name, job title, phone numbers, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/businesscardfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the business card document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeBusinessCardsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [businessCard] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes business card information from a given accessible url to a document
     * @param businessCardUrl - Url to a business card document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeBusinessCardsFromUrl(businessCardUrl: string, options?: BeginRecognizeBusinessCardsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes data from invoices using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_1.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoices(readStream, {
     *   contentType: "application/pdf",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given document
     * @param invoice - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoices(invoice: FormRecognizerRequestBody, options?: BeginRecognizeInvoicesOptions): Promise<FormPollerLike>;
    /**
     * Recognizes invoice information from a URL using a pre-built invoice model, enabling you to extract structured data
     * from invoices such as customer address, vendor address, purchase order ID, etc.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/invoicefields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the invoice document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeInvoicesFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [invoice] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes invoice information from a given accessible url to a document
     * @param invoiceUrl - Url to an invoice document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeInvoicesFromUrl(invoiceUrl: string, options?: BeginRecognizeInvoicesOptions): Promise<FormPollerLike>;
    /**
     * Recognizes data from identification documents using a pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     *
     * ```ts
     * const path = "./license.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocuments(readStream, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocument - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocuments(identityDocument: FormRecognizerRequestBody, options?: BeginRecognizeIdentityDocumentsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes identity document information from a url using pre-built ID
     * document model, enabling you to extract structured data from ID documents
     * such as first/last name, document number, expiration date, and more.
     *
     * For a list of fields that are contained in the response, please refer to
     * the documentation at the following link:
     * https://aka.ms/formrecognizer/iddocumentfields
     *
     * This method returns a long running operation poller that allows you to
     * wait indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation
     * completes in the first request, and attempting to cancel a completed copy
     * will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the identity document>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeIdentityDocumentsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     *
     * const [identityDocument] = await poller.pollUntilDone();
     * ```
     *
     * @param identityDocumentUrl - Url to an identity document that is accessible from
     * the service. Must be a valid, encoded URL to a document of a supported
     * content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeIdentityDocumentsFromUrl(identityDocumentUrl: string, options?: BeginRecognizeIdentityDocumentsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes data from receipts using a pre-built receipt model, enabling you to extract structured data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./contoso-allinone.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceipts(readStream, {
     *   contentType: "image/jpeg",
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given document
     * @param receipt - Input document
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceipts(receipt: FormRecognizerRequestBody, options?: BeginRecognizeReceiptsOptions): Promise<FormPollerLike>;
    /**
     * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the documentation at the
     * following link: https://aka.ms/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the receipt document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceiptsFromUrl(url, {
     *   includeFieldElements: true,
     *   onProgress: (state) => {
     *     console.log(`analyzing status: ${state.status}`);
     *   }
     * });
     * const [receipt] = await poller.pollUntilDone();
     * ```
     *
     * Recognizes receipt information from a given accessible url to a document
     * @param receiptUrl - Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to a document of a supported content type.
     * @param options - Options for the recognition operation
     */
    beginRecognizeReceiptsFromUrl(receiptUrl: string, options?: BeginRecognizeReceiptsOptions): Promise<FormPollerLike>;
}

/**
 * Client options used to configure Form Recognizer API requests.
 */
export declare interface FormRecognizerClientOptions extends PipelineOptions {
}

/**
 * Represents errors from Azure Form Recognizer service
 */
export declare interface FormRecognizerError {
    /**
     * Error code
     */
    code: string;
    /**
     * Error message
     */
    message: string;
}

/**
 * Options common to all form recognizer operations.
 */
export declare interface FormRecognizerOperationOptions extends OperationOptions {
}

/**
 * Types of binary data allowed as input to recognition operations
 */
export declare type FormRecognizerRequestBody = Blob | ArrayBuffer | ArrayBufferView | NodeJS.ReadableStream;

/**
 * Represents a recognized selection mark.
 *
 * Selection marks include checkboxes, radio buttons, etc.
 */
export declare interface FormSelectionMark extends FormElementCommon {
    /**
     * Element kind - "selectionMark"
     */
    kind: "selectionMark";
    /**
     * The state of the mark, either of:
     * - "selected"
     * - "unselected"
     */
    state: "selected" | "unselected";
    /**
     * Confidence value.
     */
    confidence?: number;
}

/**
 * A form field with a value representing the state of a selection mark.
 */
export declare interface FormSelectionMarkField extends FormFieldCommon {
    /**
     * The type of this field's value - "selectionMark"
     */
    valueType: "selectionMark";
    /**
     * The state of the recognized selection mark, represented as a string, with
     * one of the following values:
     *
     * - "selected"
     * - "unselected"
     */
    value?: "selected" | "unselected";
}

/**
 * A form field with a string value.
 */
export declare interface FormStringField extends FormFieldCommon {
    /**
     * The type of this field's value - "string"
     */
    valueType: "string";
    /**
     * The value of the recognized string.
     */
    value?: string;
}

/**
 * Information about the recognized table contained in a page.
 */
export declare interface FormTable {
    /**
     * Number of rows in the data table
     */
    rowCount: number;
    /**
     * Number of columns in the data table
     */
    columnCount: number;
    /**
     * The bounding box of the recognized table
     *
     * Note: This may be `undefined` for FormTables recognized from from custom models trained
     * without labels.
     */
    boundingBox?: Point2D[];
    /**
     * List of cells in the data table
     */
    cells: FormTableCell[];
    /**
     * The 1-based page number in the input document where the table appears.
     */
    pageNumber: number;
}

/**
 * Represents a cell in recognized table
 */
export declare interface FormTableCell {
    /**
     * Row index of the cell.
     */
    rowIndex: number;
    /**
     * Column index of the cell.
     */
    columnIndex: number;
    /**
     * Number of rows spanned by this cell.
     */
    rowSpan: number;
    /**
     * Number of columns spanned by this cell.
     */
    columnSpan: number;
    /**
     * Text content of the cell.
     */
    text: string;
    /**
     * Bounding box of the cell.
     */
    boundingBox: Point2D[];
    /**
     * Confidence value.
     */
    confidence: number;
    /**
     * When includeFieldElements is set to true, a list of references to the elements constituting this table cell.
     */
    fieldElements?: FormElement[];
    /**
     * Is the current cell a header cell?
     */
    isHeader: boolean;
    /**
     * Is the current cell a footer cell?
     */
    isFooter: boolean;
    /**
     * The 1-based page number in the input document where the table cell appears.
     */
    pageNumber: number;
}

/**
 * A form field with a value representing a time.
 */
export declare interface FormTimeField extends FormFieldCommon {
    /**
     * The type of this field's value - "time"
     */
    valueType: "time";
    /**
     * The value of the time field, represented as a string.
     */
    value?: string;
}

/**
 * Client class for training and managing custom form models.
 */
export declare class FormTrainingClient {
    /**
     * Url to an Azure Form Recognizer service endpoint
     */
    readonly endpointUrl: string;
    /* Excluded from this release type: credential */
    /* Excluded from this release type: clientOptions */
    /* Excluded from this release type: client */
    /**
     * Creates an instance of FormTrainingClient.
     *
     * Example usage:
     * ```ts
     * import {FormTrainingClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormTrainingClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - Url to an Azure Form Recognizer service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the client.
     */
    constructor(endpointUrl: string, credential: TokenCredential | KeyCredential, options?: FormRecognizerClientOptions);
    /**
     * Retrieves summary information about the cognitive service account
     *
     * @param options - Options to GetSummary operation
     */
    getAccountProperties(options?: GetAccountPropertiesOptions): Promise<AccountProperties>;
    /**
     * Creates an instance of {@link FormTrainingClient} to perform training operations
     * and to manage trained custom form models.
     */
    getFormRecognizerClient(): FormRecognizerClient;
    /**
     * Mark model for deletion. Model artifacts will be permanently removed within 48 hours.
     *
     * @param modelId - Id of the model to mark for deletion
     * @param options - Options to the Delete Model operation
     */
    deleteModel(modelId: string, options?: DeleteModelOptions): Promise<RestResponse>;
    /**
     * Get detailed information about a custom model from training.
     *
     * @param modelId - Id of the model to get information
     * @param options - Options to the Get Model operation
     */
    getCustomModel(modelId: string, options?: GetModelOptions): Promise<FormModelResponse>;
    private listModelsPage;
    private listModelsAll;
    /**
     * Returns an async iterable iterator to list information about all models in the cognitive service account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const client = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     * const result = client.listCustomModels();
     * let i = 1;
     * for await (const model of result) {
     *   console.log(`model ${i++}:`);
     *   console.log(model);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = client.listCustomModels();
     * let modelItem = await iter.next();
     * while (!modelItem.done) {
     *   console.log(`model ${i++}: ${modelItem.value}`);
     *   modelItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     *  let i = 1;
     *  for await (const response of client.listCustomModels().byPage()) {
     *    for (const modelInfo of response.modelList!) {
     *      console.log(`model ${i++}: ${modelInfo.modelId}`);
     *    }
     *  }
     * ```
     *
     * @param options - Options to the List Models operation
     */
    listCustomModels(options?: ListModelsOptions): PagedAsyncIterableIterator<CustomFormModelInfo, ListCustomModelsResponse>;
    private list;
    private listNextPage;
    /**
     * Creates and trains a custom form model.
     *
     * If the `useTrainingLabels` parameter is set to `true`, then the operation will search
     * for label files in addition to the training documents, and it will create a labeled
     * model with the field names specified by the labels. Otherwise, it will create an
     * unlabeled model automatically that returns generated field names for the items it
     * determines are fields within the document structure.
     *
     * This method returns a long-running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Notes:
     * - The onProgress callback will not be invoked if the operation completes in the first
     *   request, and attempting to cancel a completed copy will result in an error being thrown.
     * - Even when the training operation fails, a model is still created in the Azure Form
     *   Recognizer resource.
     *
     * Example usage:
     * ```ts
     * const trainingFilesUrl = "<url to the blob container storing training documents>";
     * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     *
     * const poller = await trainingClient.beginTraining(trainingFilesUrl, false, {
     *   onProgress: (state) => { console.log("training status: "); console.log(state); }
     * });
     * const model = await poller.pollUntilDone();
     * ```
     *
     * Creates and trains a custom form model.
     * @param trainingFilesUrl - Accessible url to an Azure Storage Blob container storing the training documents and optional label files
     * @param useTrainingLabels - Specifies whether or not to search for and train using label files
     * @param options - Options to start the model training operation
     */
    beginTraining(trainingFilesUrl: string, useTrainingLabels: boolean, options?: BeginTrainingOptions): Promise<PollerLike<TrainingOperationState, CustomFormModel>>;
    /**
     * Combines pre-existing models with labels into a single composed model.
     *
     * The composed model will contain copies of all of its input submodels, and it will
     * choose (using a machine learning algorithm) the most appropriate of its input models
     * to use during form recognition.
     *
     * This method returns a long-running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     *
     * Notes:
     * - Only labeled models can be composed. Attempting to compose an unlabeled model will
     *   result in an error.
     * - the onProgress callback will not be invoked if the operation completes in the first
     *   request, and attempting to cancel a completed copy will result in an error being thrown.
     * - evena when the training operation fails, a model is still created in the Azure Form
     *   Recognizer resource.
     *
     * Example usage:
     * ```ts
     * const modelIds = ["<model ID 1>", "<model ID 2>", "<model ID 3>"];
     * const trainingClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     *
     * const poller = await trainingClient.beginCreateComposedModel(modelIds, {
     *   modelName: "<optional name for the composed model>",
     *   onProgress: (state) => { console.log("training status: "); console.log(state); }
     * });
     * const composedModel = await poller.pollUntilDone();
     * ```
     *
     * Combines pre-existing models with labels into a single composed model.
     * @param modelIds - An array of model IDs within the Form Recognizer resouce to compose
     * @param options - Options to start the create composed model operation
     */
    beginCreateComposedModel(modelIds: string[], options: BeginCreateComposedModelOptions): Promise<PollerLike<TrainingOperationState, CustomFormModel>>;
    /**
     * Generate an authorization for copying a custom model into this Azure Form Recognizer resource.
     *
     * This method should be called on a client that is authenticated using the target resource (where the
     * model will be copied to) credentials, and the output can be passed as the `target` parameter to the
     * `beginCopyModel` method of a source client.
     *
     * The required `resourceId` and `resourceRegion` are properties of an Azure Form Recognizer resource and their values can be found in the Azure Portal.
     *
     * @param resourceId - Id of the Azure Form Recognizer resource where a custom model will be copied to
     * @param resourceRegion - Location of the Azure Form Recognizer resource, must be a valid region name supported by Azure Cognitive Services. See https://aka.ms/azsdk/cognitiveservices/regionalavailability for information about the regional availability of Azure Cognitive Services.
     * @param options - Options to get copy authorization operation
     * @returns The authorization to copy a custom model
     */
    getCopyAuthorization(resourceId: string, resourceRegion: string, options?: GetCopyAuthorizationOptions): Promise<CopyAuthorization>;
    /**
     * Copies a custom model from this resource (the source) to the specified target Form Recognizer resource.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const targetClient = new FormTrainingClient(targetEndpoint, new AzureKeyCredential(targetApiKey));
     * const authorization = await targetClient.getCopyAuthorization(targetResourceId, targetResourceRegion);
     *
     * const sourceClient = new FormTrainingClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await sourceClient.beginCopyModel(sourceModelId, authorization, {
     *   onProgress: (state) => {
     *     console.log(`Copy model status: ${state.status}`);
     *   }
     * });
     * const result = await poller.pollUntilDone();
     * ```
     * Copies custom model to target resource
     * @param modelId - Id of the custom model in this resource to be copied to the target Form Recognizer resource
     * @param target - Copy authorization produced by calling `targetTrainingClient.getCopyAuthorization()`
     * @param options - Options to copy model operation
     */
    beginCopyModel(modelId: string, target: CopyAuthorization, options?: BeginCopyModelOptions): Promise<PollerLike<CopyModelOperationState, CustomFormModelInfo>>;
    private beginCopyModelInternal;
    private getCopyModelResult;
}

/**
 * Options for configuring long-running operations.
 */
export declare interface FormTrainingPollOperationOptions<TState extends PollOperationState<unknown>> {
    /**
     * Interval (in milliseconds) between requests for status updates on the operation.
     */
    updateIntervalInMs?: number;
    /**
     * Progress handler. The Poller will call this handler with the operation state
     * after polling.
     */
    onProgress?: (state: TState) => void;
    /**
     * State of a previously-serialized poller to resume an operation.
     *
     * The state can be obtained from a poller using `poller.toString()`.
     */
    resumeFrom?: string;
}

/**
 * A catch-all form field variation with an unknown value type.
 *
 * This interface is provided for type safety and should only be encountered
 * when the `valueType` of a FormField is undefined, and there is no ordinary
 * reason that should be the case.
 */
export declare interface FormUnknownField extends FormFieldCommon {
    /**
     * The type of this form value value - undefined.
     *
     * There is no reason this should ordinarily occur, but is provided as a way
     * to hint to the type system that if `valueType` is not known, then the type
     * of value is `unknown`.
     */
    valueType?: undefined;
    /**
     * If `valueType` is undefined, then the type of the value is unknown.
     */
    value?: unknown;
}

/**
 * Represents a recognized word.
 */
export declare interface FormWord extends FormElementCommon {
    /**
     * Element kind - "word"
     */
    kind: "word";
    /**
     * The text content of the word.
     */
    text: string;
    /**
     * Confidence value.
     */
    confidence?: number;
}

/**
 * Options for the get account properties operation.
 */
export declare type GetAccountPropertiesOptions = FormRecognizerOperationOptions;

/**
 * Options for the generate copy model authorization operation.
 */
export declare type GetCopyAuthorizationOptions = FormRecognizerOperationOptions;

/**
 * Options for the get copy model result operation.
 */
export declare type GetCopyModelResultOptions = FormRecognizerOperationOptions;

/**
 * Options for the get model operation.
 */
export declare type GetModelOptions = FormRecognizerOperationOptions;

/** Keys extracted by the custom model. */
export declare interface KeysResult {
    /** Object mapping clusterIds to a list of keys. */
    clusters: {
        [propertyName: string]: string[];
    };
}

/** Information about the extracted key or value in a key-value pair. */
export declare interface KeyValueElementModel {
    /** Semantic data type of the key value element. */
    type?: KeyValueType;
    /** The text content of the key or value. */
    text: string;
    /** Bounding box of the key or value. */
    boundingBox?: number[];
    /** When includeTextDetails is set to true, a list of references to the text elements constituting this key or value. */
    elements?: string[];
}

/** Information about the extracted key-value pair. */
export declare interface KeyValuePairModel {
    /** A user defined label for the key/value pair entry. */
    label?: string;
    /** Information about the extracted key in a key-value pair. */
    key: KeyValueElementModel;
    /** Information about the extracted value in a key-value pair. */
    value: KeyValueElementModel;
    /** Confidence value. */
    confidence: number;
}

/**
 * Defines values for KeyValueType. \
 * {@link KnownKeyValueType} can be used interchangeably with KeyValueType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **string** \
 * **selectionMark**
 */
export declare type KeyValueType = string;

/** Known values of {@link FormLanguage} that the service accepts. */
export declare const enum KnownFormLanguage {
    Af = "af",
    Ast = "ast",
    Bi = "bi",
    Br = "br",
    Ca = "ca",
    Ceb = "ceb",
    Ch = "ch",
    Co = "co",
    Crh = "crh",
    Cs = "cs",
    Csb = "csb",
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fr = "fr",
    Fur = "fur",
    Fy = "fy",
    Ga = "ga",
    Gd = "gd",
    Gil = "gil",
    Gl = "gl",
    Gv = "gv",
    Hni = "hni",
    Hsb = "hsb",
    Ht = "ht",
    Hu = "hu",
    Ia = "ia",
    Id = "id",
    It = "it",
    Iu = "iu",
    Ja = "ja",
    Jv = "jv",
    Kaa = "kaa",
    Kac = "kac",
    Kea = "kea",
    Kha = "kha",
    Kl = "kl",
    Ko = "ko",
    Ku = "ku",
    Kw = "kw",
    Lb = "lb",
    Ms = "ms",
    Mww = "mww",
    Nap = "nap",
    Nl = "nl",
    No = "no",
    Oc = "oc",
    Pl = "pl",
    Pt = "pt",
    Quc = "quc",
    Rm = "rm",
    Sco = "sco",
    Sl = "sl",
    Sq = "sq",
    Sv = "sv",
    Sw = "sw",
    Tet = "tet",
    Tr = "tr",
    Tt = "tt",
    Uz = "uz",
    Vo = "vo",
    Wae = "wae",
    Yua = "yua",
    Za = "za",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant",
    Zu = "zu"
}

/** Known values of {@link FormLocale} that the service accepts. */
export declare const enum KnownFormLocale {
    EnAU = "en-AU",
    EnCA = "en-CA",
    EnGB = "en-GB",
    EnIN = "en-IN",
    EnUS = "en-US"
}

/** Defines values for LengthUnit. */
export declare type LengthUnit = "pixel" | "inch";

/**
 * Contains response data for the listCustomModels operation.
 */
export declare type ListCustomModelsResponse = Models & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: Models;
    };
};

/**
 * Options for model listing operation.
 */
export declare type ListModelsOptions = FormRecognizerOperationOptions;

/**
 * Response to the get custom model operation.
 */
export declare interface Model {
    /**
     * Basic custom model information.
     */
    modelInfo: CustomFormModelInfo;
    /**
     * Keys extracted by the custom model.
     */
    keys?: KeysResult;
    /**
     * Custom model training result.
     */
    trainResult?: TrainResult;
}

/**
 * Response to the list custom models operation.
 */
export declare interface Models {
    /**
     * Summary of all trained custom models.
     */
    summary?: ModelsSummary;
    /**
     * Collection of trained custom models.
     */
    modelList?: CustomFormModelInfo[];
    /**
     * Link to the next page of custom models.
     */
    nextLink?: string;
}

/** Summary of all trained custom models. */
export declare interface ModelsSummary {
    /** Current count of trained custom models. */
    count: number;
    /** Max number of models that can be trained for this account. */
    limit: number;
    /** Date and time (UTC) when the summary was last updated. */
    lastModified: Date;
}

/** Defines values for ModelStatus. */
declare type ModelStatus = "creating" | "ready" | "invalid";
export { ModelStatus as CustomFormModelStatus }
export { ModelStatus }

/** Defines values for OperationStatus. */
export declare type OperationStatus = "notStarted" | "running" | "succeeded" | "failed";

/**
 * Represents a point used to defined bounding boxes. The unit is either 'pixel' or 'inch', @see {@link LengthUnit}.
 */
export declare interface Point2D {
    /**
     * x coordinate
     */
    x: number;
    /**
     * y coordinate
     */
    y: number;
}

/**
 * The state of a recognize content operation
 */
export declare type RecognizeContentOperationState = PollOperationState<FormPageArray> & {
    /**
     * A string representing the current status of the operation.
     */
    status: OperationStatus;
};

/**
 * Options for content/layout recognition.
 */
export declare type RecognizeContentOptions = FormRecognizerOperationOptions;

/**
 * Represent recognized form consists of text fields that have semantic meanings.
 */
export declare interface RecognizedForm {
    /**
     * The type of the form.
     */
    formType: string;
    /**
     * Confidence in the correctness of the form type.
     *
     * For unlabeled models, this value will always be undefined.
     */
    formTypeConfidence?: number;
    /**
     * The model ID used to analyze the contents of this document.
     */
    modelId?: string;
    /**
     * First and last page number where the document is found.
     */
    pageRange: FormPageRange;
    /**
     * Dictionary of named field values.
     */
    fields: Record<string, FormField>;
    /**
     * Texts and tables extracted from a page in the input
     */
    pages: FormPage[];
}

/**
 * Array of {@link RecognizedForm}
 */
export declare interface RecognizedFormArray extends Array<RecognizedForm> {
}

/**
 * The status of a form recognition operation
 */
export declare interface RecognizeFormsOperationState extends PollOperationState<RecognizedFormArray> {
    /**
     * Identifier for the recognition operation.
     */
    modelId?: string;
    /**
     * Expected document type from recognition.
     */
    expectedDocType?: string;
    /**
     * Identifier for the recognition operation
     */
    resultId?: string;
    /**
     * Last-known status of the recognition operation
     */
    status: OperationStatus;
}

/**
 * Options for recognition of forms
 */
export declare interface RecognizeFormsOptions extends FormRecognizerOperationOptions {
    /**
     * Specifies whether to include text lines and element references in the result
     */
    includeFieldElements?: boolean;
}
export { RestResponse }

/**
 * Represents the appearance of a line of text in a form.
 */
export declare interface TextAppearance {
    /**
     * The identified style of writing, can be one of:
     * - "handwriting"
     * - "other"
     */
    styleName: "handwriting" | "other";
    /**
     * Confidence value.
     */
    styleConfidence: number;
}

/**
 * Report for a custom model training document.
 */
export declare interface TrainingDocumentInfo {
    /**
     * Training document name.
     */
    name: string;
    /**
     * The model ID associated with this training document
     */
    modelId?: string;
    /**
     * Total number of pages trained.
     */
    pageCount: number;
    /**
     * List of errors.
     */
    errors: FormRecognizerError[];
    /**
     * Status of the training operation.
     */
    status: TrainingStatus;
}

/**
 * Options for training models
 */
export declare type TrainingFileFilter = FormRecognizerOperationOptions & {
    prefix?: string;
    includeSubfolders?: boolean;
};

/**
 * The status of a form training operation
 */
export declare type TrainingOperationState = PollOperationState<CustomFormModelInfo> & {
    /**
     * A string representing the current status of the operation.
     */
    status: ModelStatus;
};

/** Defines values for TrainStatus. */
export declare type TrainingStatus = "succeeded" | "partiallySucceeded" | "failed";

/**
 * Custom model training result.
 */
export declare interface TrainResult {
    /**
     * List of the documents used to train the model and any errors reported in each document.
     */
    trainingDocuments: TrainingDocumentInfo[];
    /**
     * List of fields used to train the model and the train operation error reported by each.
     */
    fields?: FormFieldsReport[];
    /**
     * Average accuracy.
     */
    averageModelAccuracy?: number;
    /**
     * Errors returned during the training operation.
     */
    errors?: FormRecognizerError[];
}

export { }
