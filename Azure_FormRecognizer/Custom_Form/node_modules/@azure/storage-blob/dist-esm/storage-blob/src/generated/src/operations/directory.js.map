{"version":3,"file":"directory.js","sourceRoot":"","sources":["../../../../../../src/generated/src/operations/directory.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Models from \"../models\";\nimport * as Mappers from \"../models/directoryMappers\";\nimport * as Parameters from \"../models/parameters\";\nimport { StorageClientContext } from \"../storageClientContext\";\n\n/** Class representing a Directory. */\nexport class Directory {\n  private readonly client: StorageClientContext;\n\n  /**\n   * Create a Directory.\n   * @param {StorageClientContext} client Reference to the service client.\n   */\n  constructor(client: StorageClientContext) {\n    this.client = client;\n  }\n\n  /**\n   * Create a directory. By default, the destination is overwritten and if the destination already\n   * exists and has a lease the lease is broken. This operation supports conditional HTTP requests.\n   * For more information, see [Specifying Conditional Headers for Blob Service\n   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).\n   * To fail if the destination already exists, use a conditional request with If-None-Match: \"*\".\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DirectoryCreateResponse>\n   */\n  create(options?: Models.DirectoryCreateOptionalParams): Promise<Models.DirectoryCreateResponse>;\n  /**\n   * @param callback The callback\n   */\n  create(callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  create(options: Models.DirectoryCreateOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  create(options?: Models.DirectoryCreateOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.DirectoryCreateResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      createOperationSpec,\n      callback) as Promise<Models.DirectoryCreateResponse>;\n  }\n\n  /**\n   * Rename a directory. By default, the destination is overwritten and if the destination already\n   * exists and has a lease the lease is broken. This operation supports conditional HTTP requests.\n   * For more information, see [Specifying Conditional Headers for Blob Service\n   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).\n   * To fail if the destination already exists, use a conditional request with If-None-Match: \"*\".\n   * @param renameSource The file or directory to be renamed. The value must have the following\n   * format: \"/{filesysystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will\n   * overwrite the existing properties; otherwise, the existing properties will be preserved.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DirectoryRenameResponse>\n   */\n  rename(renameSource: string, options?: Models.DirectoryRenameOptionalParams): Promise<Models.DirectoryRenameResponse>;\n  /**\n   * @param renameSource The file or directory to be renamed. The value must have the following\n   * format: \"/{filesysystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will\n   * overwrite the existing properties; otherwise, the existing properties will be preserved.\n   * @param callback The callback\n   */\n  rename(renameSource: string, callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param renameSource The file or directory to be renamed. The value must have the following\n   * format: \"/{filesysystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will\n   * overwrite the existing properties; otherwise, the existing properties will be preserved.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  rename(renameSource: string, options: Models.DirectoryRenameOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  rename(renameSource: string, options?: Models.DirectoryRenameOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.DirectoryRenameResponse> {\n    return this.client.sendOperationRequest(\n      {\n        renameSource,\n        options\n      },\n      renameOperationSpec,\n      callback) as Promise<Models.DirectoryRenameResponse>;\n  }\n\n  /**\n   * Deletes the directory\n   * @param recursiveDirectoryDelete If \"true\", all paths beneath the directory will be deleted. If\n   * \"false\" and the directory is non-empty, an error occurs.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DirectoryDeleteResponse>\n   */\n  deleteMethod(recursiveDirectoryDelete: boolean, options?: Models.DirectoryDeleteMethodOptionalParams): Promise<Models.DirectoryDeleteResponse>;\n  /**\n   * @param recursiveDirectoryDelete If \"true\", all paths beneath the directory will be deleted. If\n   * \"false\" and the directory is non-empty, an error occurs.\n   * @param callback The callback\n   */\n  deleteMethod(recursiveDirectoryDelete: boolean, callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param recursiveDirectoryDelete If \"true\", all paths beneath the directory will be deleted. If\n   * \"false\" and the directory is non-empty, an error occurs.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  deleteMethod(recursiveDirectoryDelete: boolean, options: Models.DirectoryDeleteMethodOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  deleteMethod(recursiveDirectoryDelete: boolean, options?: Models.DirectoryDeleteMethodOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.DirectoryDeleteResponse> {\n    return this.client.sendOperationRequest(\n      {\n        recursiveDirectoryDelete,\n        options\n      },\n      deleteMethodOperationSpec,\n      callback) as Promise<Models.DirectoryDeleteResponse>;\n  }\n\n  /**\n   * Set the owner, group, permissions, or access control list for a directory.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DirectorySetAccessControlResponse>\n   */\n  setAccessControl(options?: Models.DirectorySetAccessControlOptionalParams): Promise<Models.DirectorySetAccessControlResponse>;\n  /**\n   * @param callback The callback\n   */\n  setAccessControl(callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  setAccessControl(options: Models.DirectorySetAccessControlOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  setAccessControl(options?: Models.DirectorySetAccessControlOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.DirectorySetAccessControlResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      setAccessControlOperationSpec,\n      callback) as Promise<Models.DirectorySetAccessControlResponse>;\n  }\n\n  /**\n   * Get the owner, group, permissions, or access control list for a directory.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DirectoryGetAccessControlResponse>\n   */\n  getAccessControl(options?: Models.DirectoryGetAccessControlOptionalParams): Promise<Models.DirectoryGetAccessControlResponse>;\n  /**\n   * @param callback The callback\n   */\n  getAccessControl(callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getAccessControl(options: Models.DirectoryGetAccessControlOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  getAccessControl(options?: Models.DirectoryGetAccessControlOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.DirectoryGetAccessControlResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      getAccessControlOperationSpec,\n      callback) as Promise<Models.DirectoryGetAccessControlResponse>;\n  }\n}\n\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers, true);\nconst createOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PUT\",\n  path: \"{filesystem}/{path}\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds,\n    Parameters.resource\n  ],\n  headerParameters: [\n    Parameters.directoryProperties,\n    Parameters.posixPermissions,\n    Parameters.posixUmask,\n    Parameters.version,\n    Parameters.requestId,\n    Parameters.cacheControl,\n    Parameters.contentType,\n    Parameters.contentEncoding,\n    Parameters.contentLanguage,\n    Parameters.contentDisposition,\n    Parameters.leaseId0,\n    Parameters.ifModifiedSince,\n    Parameters.ifUnmodifiedSince,\n    Parameters.ifMatch,\n    Parameters.ifNoneMatch\n  ],\n  responses: {\n    201: {\n      headersMapper: Mappers.DirectoryCreateHeaders\n    },\n    default: {\n      bodyMapper: Mappers.DataLakeStorageError,\n      headersMapper: Mappers.DirectoryCreateHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst renameOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PUT\",\n  path: \"{filesystem}/{path}\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds,\n    Parameters.marker1,\n    Parameters.pathRenameMode\n  ],\n  headerParameters: [\n    Parameters.renameSource,\n    Parameters.directoryProperties,\n    Parameters.posixPermissions,\n    Parameters.posixUmask,\n    Parameters.sourceLeaseId,\n    Parameters.version,\n    Parameters.requestId,\n    Parameters.cacheControl,\n    Parameters.contentType,\n    Parameters.contentEncoding,\n    Parameters.contentLanguage,\n    Parameters.contentDisposition,\n    Parameters.leaseId0,\n    Parameters.ifModifiedSince,\n    Parameters.ifUnmodifiedSince,\n    Parameters.ifMatch,\n    Parameters.ifNoneMatch,\n    Parameters.sourceIfModifiedSince,\n    Parameters.sourceIfUnmodifiedSince,\n    Parameters.sourceIfMatch,\n    Parameters.sourceIfNoneMatch\n  ],\n  responses: {\n    201: {\n      headersMapper: Mappers.DirectoryRenameHeaders\n    },\n    default: {\n      bodyMapper: Mappers.DataLakeStorageError,\n      headersMapper: Mappers.DirectoryRenameHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst deleteMethodOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"{filesystem}/{path}\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds,\n    Parameters.recursiveDirectoryDelete,\n    Parameters.marker1\n  ],\n  headerParameters: [\n    Parameters.version,\n    Parameters.requestId,\n    Parameters.leaseId0,\n    Parameters.ifModifiedSince,\n    Parameters.ifUnmodifiedSince,\n    Parameters.ifMatch,\n    Parameters.ifNoneMatch\n  ],\n  responses: {\n    200: {\n      headersMapper: Mappers.DirectoryDeleteHeaders\n    },\n    default: {\n      bodyMapper: Mappers.DataLakeStorageError,\n      headersMapper: Mappers.DirectoryDeleteHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst setAccessControlOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PATCH\",\n  path: \"{filesystem}/{path}\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds,\n    Parameters.action5\n  ],\n  headerParameters: [\n    Parameters.owner,\n    Parameters.group,\n    Parameters.posixPermissions,\n    Parameters.posixAcl,\n    Parameters.requestId,\n    Parameters.version,\n    Parameters.leaseId0,\n    Parameters.ifMatch,\n    Parameters.ifNoneMatch,\n    Parameters.ifModifiedSince,\n    Parameters.ifUnmodifiedSince\n  ],\n  responses: {\n    200: {\n      headersMapper: Mappers.DirectorySetAccessControlHeaders\n    },\n    default: {\n      bodyMapper: Mappers.DataLakeStorageError,\n      headersMapper: Mappers.DirectorySetAccessControlHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst getAccessControlOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"HEAD\",\n  path: \"{filesystem}/{path}\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds,\n    Parameters.upn,\n    Parameters.action6\n  ],\n  headerParameters: [\n    Parameters.requestId,\n    Parameters.version,\n    Parameters.leaseId0,\n    Parameters.ifMatch,\n    Parameters.ifNoneMatch,\n    Parameters.ifModifiedSince,\n    Parameters.ifUnmodifiedSince\n  ],\n  responses: {\n    200: {\n      headersMapper: Mappers.DirectoryGetAccessControlHeaders\n    },\n    default: {\n      bodyMapper: Mappers.DataLakeStorageError,\n      headersMapper: Mappers.DirectoryGetAccessControlHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n"]}