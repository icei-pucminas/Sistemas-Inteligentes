// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __extends, __generator } from "tslib";
import { AvroReadable } from "./AvroReadable";
import { AbortError } from "@azure/abort-controller";
var ABORT_ERROR = new AbortError("Reading from the avro stream was aborted.");
var AvroReadableFromStream = /** @class */ (function (_super) {
    __extends(AvroReadableFromStream, _super);
    function AvroReadableFromStream(readable) {
        var _this = _super.call(this) || this;
        _this._readable = readable;
        _this._position = 0;
        return _this;
    }
    AvroReadableFromStream.prototype.toUint8Array = function (data) {
        if (typeof data === "string") {
            return Buffer.from(data);
        }
        return data;
    };
    Object.defineProperty(AvroReadableFromStream.prototype, "position", {
        get: function () {
            return this._position;
        },
        enumerable: false,
        configurable: true
    });
    AvroReadableFromStream.prototype.read = function (size, options) {
        var _a;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            var _this = this;
            return __generator(this, function (_b) {
                if ((_a = options.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    throw ABORT_ERROR;
                }
                if (size < 0) {
                    throw new Error("size parameter should be positive: " + size);
                }
                if (size === 0) {
                    return [2 /*return*/, new Uint8Array()];
                }
                if (!this._readable.readable) {
                    throw new Error("Stream no longer readable.");
                }
                chunk = this._readable.read(size);
                if (chunk) {
                    this._position += chunk.length;
                    // chunk.length maybe less than desired size if the stream ends.
                    return [2 /*return*/, this.toUint8Array(chunk)];
                }
                else {
                    // register callback to wait for enough data to read
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var cleanUp = function () {
                                _this._readable.removeListener("readable", readableCallback);
                                _this._readable.removeListener("error", rejectCallback);
                                _this._readable.removeListener("end", rejectCallback);
                                _this._readable.removeListener("close", rejectCallback);
                                if (options.abortSignal) {
                                    options.abortSignal.removeEventListener("abort", abortHandler);
                                }
                            };
                            var readableCallback = function () {
                                var chunk = _this._readable.read(size);
                                if (chunk) {
                                    _this._position += chunk.length;
                                    cleanUp();
                                    // chunk.length maybe less than desired size if the stream ends.
                                    resolve(_this.toUint8Array(chunk));
                                }
                            };
                            var rejectCallback = function () {
                                cleanUp();
                                reject();
                            };
                            var abortHandler = function () {
                                cleanUp();
                                reject(ABORT_ERROR);
                            };
                            _this._readable.on("readable", readableCallback);
                            _this._readable.once("error", rejectCallback);
                            _this._readable.once("end", rejectCallback);
                            _this._readable.once("close", rejectCallback);
                            if (options.abortSignal) {
                                options.abortSignal.addEventListener("abort", abortHandler);
                            }
                        })];
                }
                return [2 /*return*/];
            });
        });
    };
    return AvroReadableFromStream;
}(AvroReadable));
export { AvroReadableFromStream };
//# sourceMappingURL=AvroReadableFromStream.js.map